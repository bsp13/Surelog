
<!DOCTYPE html>
<html>
<head>
<style>
body {
background-color: #93B874;
}
</style>
<h3>./external/basejump_stl/bsg_dataflow/bsg_fifo_tracker.v</h3>
<pre>                          , ptr_width_lp = `BSG_SAFE_CLOG2(els_p)</pre>
<pre>                          )</pre>
<pre>    , input reset_i</pre>
<pre></pre>
<pre>    , input deq_i</pre>
<pre></pre>
<pre>    , output [ptr_width_lp-1:0] rptr_r_o</pre>
<pre></pre>
<pre>    , output empty_o</pre>
<pre>    );</pre>
<pre></pre>
<pre>   assign rptr_r_o = rptr_r;</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre>                      ,.max_add_p(1    )</pre>
<pre>                      ) rptr</pre>
<pre style="background-color: #FF0000;">     ( .clk      (clk_i  )</pre>
<pre>       , .reset_i(reset_i)</pre>
<pre>       , .add_i  (deq_i )</pre>
<pre>       , .o      (rptr_r )</pre>
<pre>       );</pre>
<pre>                      ,.max_add_p(1    )</pre>
<pre>                      ) wptr</pre>
<pre style="background-color: #FF0000;">     ( .clk      (clk_i  )</pre>
<pre>       , .reset_i(reset_i)</pre>
<pre>       , .add_i  (enq_i  )</pre>
<pre>       , .o      (wptr_r )</pre>
<pre>       );</pre>
<pre>     if (reset_i)</pre>
<pre>       begin</pre>
<pre>          enq_r <= 1'b0;</pre>
<pre>          deq_r <= 1'b1;</pre>
<pre>       end</pre>
<pre>          // update "last operation" when</pre>
<pre>            begin</pre>
<pre>               enq_r <= enq_i;</pre>
<pre>               deq_r <= deq_i;</pre>
<pre>            end</pre>
<pre>   assign empty_o    = equal_ptrs & deq_r;</pre>
<pre>   assign full_o     = equal_ptrs & enq_r;</pre>
<pre></pre>
<h3>./external/basejump_stl/bsg_dataflow/bsg_shift_reg.v</h3>
<pre>module bsg_shift_reg #(parameter width_p = "inv"</pre>
<pre>                       , parameter stages_p = "inv"</pre>
<pre>   (input clk</pre>
<pre>    , input reset_i</pre>
<pre>    , input valid_i</pre>
<pre>    , input [width_p-1:0] data_i</pre>
<pre>    , output valid_o</pre>
<pre>    , output [width_p-1:0] data_o</pre>
<pre>   logic [stages_p-1:0][width_p+1-1:0] shift_r;</pre>
<pre>   always_ff @(posedge clk)</pre>
<pre>     if (reset_i)</pre>
<pre>       shift_r <= '0;</pre>
<pre>       begin</pre>
<pre>	  shift_r[0] <= { valid_i, data_i };</pre>
<pre>       end</pre>
<pre></pre>
<h3>./external/basejump_stl/bsg_dataflow/bsg_parallel_in_serial_out_dynamic.v</h3>
<pre>module bsg_parallel_in_serial_out_dynamic</pre>
<pre> #(parameter width_p          = "inv"</pre>
<pre>  ,parameter lg_max_els_lp    = `BSG_SAFE_CLOG2(max_els_p)</pre>
<pre>  )</pre>
<pre>  ,input reset_i</pre>
<pre>  </pre>
<pre>  ,input  [lg_max_els_lp-1:0]          len_i</pre>
<pre>  ,input  [max_els_p-1:0][width_p-1:0] data_i</pre>
<pre>  ,output                              ready_o</pre>
<pre>  </pre>
<pre>  ,output                              len_v_o</pre>
<pre>  ,output [width_p-1:0]                data_o</pre>
<pre>  ,input                               yumi_i</pre>
<pre>  );</pre>
<pre>  logic [lg_max_els_lp-1:0]          len_lo;</pre>
<pre>  logic [max_els_p-1:0][width_p-1:0] fifo_data_lo;</pre>
<pre>  </pre>
<pre> #(.width_p(lg_max_els_lp  )</pre>
<pre>  ) go_fifo</pre>
<pre style="background-color: #FF0000;">  (.clk_i  (clk_i          )</pre>
<pre>  ,.reset_i(reset_i        )</pre>
<pre>  </pre>
<pre>  ,.data_i (len_i          )</pre>
<pre>  ,.v_i    (v_i            )</pre>
<pre>  </pre>
<pre>  ,.data_o (len_lo         )</pre>
<pre>  ,.yumi_i (go_fifo_yumi_li)</pre>
<pre>  );</pre>
<pre> #(.width_p(max_els_p*width_p)</pre>
<pre>  ) data_fifo</pre>
<pre style="background-color: #FF0000;">  (.clk_i  (clk_i            )</pre>
<pre>  ,.reset_i(reset_i          )</pre>
<pre>                             </pre>
<pre>  ,.data_i (data_i           )</pre>
<pre>  ,.v_i    (v_i              )</pre>
<pre>                             </pre>
<pre>  ,.data_o (fifo_data_lo     )</pre>
<pre>  ,.yumi_i (go_fifo_yumi_li  )</pre>
<pre>  );</pre>
<pre>  logic clear_li, up_li;</pre>
<pre>  logic count_r_is_zero, count_r_is_last;</pre>
<pre>  </pre>
<pre>  </pre>
<pre>  assign count_r_is_last = (count_lo == len_lo           );</pre>
<pre>  </pre>
<pre>  </pre>
<pre>  </pre>
<pre>  assign go_fifo_yumi_li = clear_li;</pre>
<pre>  </pre>
<pre> #(.max_val_p (max_els_p-1)</pre>
<pre>  ,.init_val_p(0)</pre>
<pre>  ) ctr</pre>
<pre style="background-color: #FF0000;">  (.clk_i     (clk_i   )</pre>
<pre>  ,.reset_i   (reset_i )</pre>
<pre>  ,.clear_i   (clear_li)</pre>
<pre>  ,.up_i      (up_li   )</pre>
<pre>  ,.count_o   (count_r )</pre>
<pre>  );</pre>
<pre> #(.width_p(width_p     )</pre>
<pre>  ,.els_p  (max_els_p   )</pre>
<pre>  ) data_mux</pre>
<pre style="background-color: #FF0000;">  (.data_i (fifo_data_lo)</pre>
<pre>  ,.sel_i  (count_lo    )</pre>
<pre>  ,.data_o (data_o      )</pre>
<pre>  );</pre>
<h3>./external/basejump_stl/bsg_dataflow/bsg_round_robin_n_to_1.v</h3>
<pre>module bsg_round_robin_n_to_1 #(parameter width_p = -1</pre>
<pre>                                ,parameter num_in_p = -1</pre>
<pre>                                ,parameter tag_width_lp = `BSG_SAFE_CLOG2(num_in_p)</pre>
<pre>                                )</pre>
<pre>    , input  reset_i</pre>
<pre></pre>
<pre>    , input  [num_in_p-1:0] v_i</pre>
<pre>    , output [num_in_p-1:0] yumi_o</pre>
<pre></pre>
<pre>    , output [width_p-1:0]     data_o</pre>
<pre>    , output [tag_width_lp-1:0] tag_o</pre>
<pre>    , input  yumi_i</pre>
<pre>    );</pre>
<pre>     begin : strict</pre>
<pre>        wire [tag_width_lp-1:0] ptr_r;</pre>
<pre></pre>
<pre>                           ,.max_add_p(1)</pre>
<pre>                           ) circular_ptr</pre>
<pre style="background-color: #FF0000;">          (.clk     (clk_i  )</pre>
<pre>           ,.reset_i(reset_i)</pre>
<pre>           ,.add_i  (yumi_i )</pre>
<pre>           ,.o      (ptr_r  )</pre>
<pre>           );</pre>
<pre>        assign data_o  = data_i  [ptr_r];</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre>        rr_arb_ctrl</pre>
<pre style="background-color: #FF0000;">          (.clk_i</pre>
<pre>           ,.reset_i</pre>
<pre>           ,.grants_en_i(1'b1)</pre>
<pre></pre>
<pre>           ,.grants_o (grants_lo)</pre>
<pre>           ,.sel_one_hot_o()</pre>
<pre></pre>
<pre>           ,.tag_o   (tag_o    )</pre>
<pre>           ,.yumi_i  (yumi_i & v_o )  // based on v_o, downstream</pre>
<pre>                                  // node decides if it will accept</pre>
<pre>                              ,.o_els_p(1       )</pre>
<pre>                              ,.width_p(width_p)</pre>
<pre>                              ) xbar</pre>
<pre style="background-color: #FF0000;">          (.i                (data_i   )</pre>
<pre>           ,.sel_oi_one_hot_i(grants_lo)</pre>
<pre>           ,.o               (data_o   )</pre>
<pre>           );</pre>
<pre></pre>
<h3>./external/basejump_stl/bsg_dataflow/bsg_serial_in_parallel_out_dynamic.v</h3>
<pre>module bsg_serial_in_parallel_out_dynamic</pre>
<pre> #(parameter width_p          = "inv"</pre>
<pre>  ,parameter lg_max_els_lp    = `BSG_SAFE_CLOG2(max_els_p)</pre>
<pre>  )</pre>
<pre>  ,input reset_i</pre>
<pre>  </pre>
<pre>  ,input  [lg_max_els_lp-1:0]          len_i</pre>
<pre>  ,input  [width_p-1:0]                data_i</pre>
<pre>  ,output                              ready_o</pre>
<pre>  ,output                              len_ready_o</pre>
<pre>  </pre>
<pre>  ,output [max_els_p-1:0][width_p-1:0] data_o</pre>
<pre>  ,input                               yumi_i</pre>
<pre>  );</pre>
<pre style="background-color: #FF0000;">  </pre>
<pre>  assign yumi_lo = v_i & ready_o;</pre>
<pre>  </pre>
<pre>  logic clear_li, up_li, dff_en_li, go_fifo_v_li;</pre>
<pre>  logic count_r_is_zero, count_r_is_last;</pre>
<pre>  </pre>
<pre>  </pre>
<pre>  </pre>
<pre>  assign count_r_is_last = (count_lo == len_lo           );</pre>
<pre>  </pre>
<pre>  </pre>
<pre>  </pre>
<pre>  assign go_fifo_v_li = clear_li;</pre>
<pre>  </pre>
<pre>  </pre>
<pre> #(.max_val_p (max_els_p-1)</pre>
<pre>  ,.init_val_p(0)</pre>
<pre>  ) ctr</pre>
<pre style="background-color: #FF0000;">  (.clk_i     (clk_i   )</pre>
<pre>  ,.reset_i   (reset_i )</pre>
<pre>  ,.clear_i   (clear_li)</pre>
<pre>  ,.up_i      (up_li   )</pre>
<pre>  ,.count_o   (count_r )</pre>
<pre>  );</pre>
<pre> #(.width_p    (lg_max_els_lp)</pre>
<pre>  ,.reset_val_p(0)</pre>
<pre>  ) dff_len</pre>
<pre style="background-color: #FF0000;">  (.clk_i      (clk_i    )</pre>
<pre>  ,.reset_i    (reset_i  )</pre>
<pre>  ,.en_i       (dff_en_li)</pre>
<pre>  ,.data_i     (len_i    )</pre>
<pre>  ,.data_o     (len_r    )</pre>
<pre>  );</pre>
<pre>  </pre>
<pre> #(.width_p(1)</pre>
<pre>  ) go_fifo</pre>
<pre style="background-color: #FF0000;">  (.clk_i  (clk_i          )</pre>
<pre>  ,.reset_i(reset_i        )</pre>
<pre>  ,.ready_o(/* This fifo has same size of lowest word data fifo</pre>
<pre>               No need to check ready_o here */)</pre>
<pre>  ,.v_i    (go_fifo_v_li   )</pre>
<pre>  ,.v_o    (v_o            )</pre>
<pre>  ,.data_o (one_word_lo    )</pre>
<pre>  ,.yumi_i (yumi_i         )</pre>
<pre>  );</pre>
<pre>  logic [max_els_p-1:0] fifo_valid_lo, fifo_yumi_li;</pre>
<pre>  </pre>
<pre></pre>
<pre style="background-color: #FF0000;">  begin: rof0</pre>
<pre style="background-color: #FF0000;">    if (i == 0)</pre>
<pre style="background-color: #FF0000;">        // Lowest word fifo always dequeue (packet should have at least one word)</pre>
<pre style="background-color: #FF0000;">    else</pre>
<pre style="background-color: #FF0000;">  end</pre>
<pre> #(.num_out_p(max_els_p)</pre>
<pre>  ) bdwv</pre>
<pre style="background-color: #FF0000;">  (.i  (count_lo     )</pre>
<pre>  ,.v_i(v_i          )</pre>
<pre>  ,.o  (fifo_valid_li)</pre>
<pre>  );</pre>
<pre style="background-color: #FF0000;">  begin: fifos</pre>
<pre style="background-color: #FF0000;">    if (i == 0)</pre>
<pre style="background-color: #FF0000;">      begin: twofifo</pre>
<pre style="background-color: #FF0000;">        // Use two element fifo to avoid bubble</pre>
<pre style="background-color: #FF0000;">       #(.width_p(width_p)</pre>
<pre style="background-color: #FF0000;">        ) fifo</pre>
<pre style="background-color: #FF0000;">        (.clk_i  (clk_i  )</pre>
<pre style="background-color: #FF0000;">        ,.reset_i(reset_i)</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">        ,.data_i (data_i          )</pre>
<pre style="background-color: #FF0000;">        ,.v_i    (fifo_valid_li[i])</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">        ,.data_o (data_o       [i])</pre>
<pre style="background-color: #FF0000;">        ,.yumi_i (fifo_yumi_li [i])</pre>
<pre style="background-color: #FF0000;">        );</pre>
<pre style="background-color: #FF0000;">        // Must use one element fifo to work correctly!</pre>
<pre style="background-color: #FF0000;">       #(.width_p(width_p)</pre>
<pre style="background-color: #FF0000;">        ) fifo</pre>
<pre style="background-color: #FF0000;">        (.clk_i  (clk_i  )</pre>
<pre style="background-color: #FF0000;">        ,.reset_i(reset_i)</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">        ,.data_i (data_i          )</pre>
<pre style="background-color: #FF0000;">        ,.v_i    (fifo_valid_li[i])</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">        ,.data_o (data_o       [i])</pre>
<pre style="background-color: #FF0000;">        ,.yumi_i (fifo_yumi_li [i])</pre>
<pre style="background-color: #FF0000;">        );</pre>
<h3>./external/basejump_stl/bsg_mem/bsg_mem_1rw_sync_mask_write_byte.v</h3>
<pre>                                          ,parameter addr_width_lp = `BSG_SAFE_CLOG2(els_p)</pre>
<pre></pre>
<pre>                                          ,parameter latch_last_read_p=0</pre>
<pre>                                          ,parameter write_mask_width_lp = data_width_p>>3</pre>
<pre>                                          ,parameter enable_clock_gating_p=0</pre>
<pre>                                         )</pre>
<pre>   ,input reset_i</pre>
<pre></pre>
<pre>   ,input w_i</pre>
<pre></pre>
<pre>   ,input [data_width_p-1:0]        data_i</pre>
<pre>    // for each bit set in the mask, a byte is written</pre>
<pre></pre>
<pre>  );</pre>
<pre></pre>
<pre>     begin</pre>
<pre style="background-color: #FF0000;">       bsg_clkgate_optional icg</pre>
<pre style="background-color: #FF0000;">         (.clk_i( clk_i )</pre>
<pre style="background-color: #FF0000;">         ,.en_i( v_i )</pre>
<pre style="background-color: #FF0000;">         ,.bypass_i( 1'b0 )</pre>
<pre style="background-color: #FF0000;">         ,.gated_clock_o( clk_lo )</pre>
<pre style="background-color: #FF0000;">         );</pre>
<pre>       assign clk_lo = clk_i;</pre>
<pre>     end</pre>
<pre>     #(.els_p(els_p), .data_width_p(data_width_p), .latch_last_read_p(latch_last_read_p))</pre>
<pre>   synth</pre>
<pre style="background-color: #FF0000;">   (.clk_i(clk_lo)</pre>
<pre>   ,.reset_i</pre>
<pre>   ,.v_i</pre>
<pre>   ,.w_i</pre>
<pre>   ,.addr_i</pre>
<pre>   ,.data_i</pre>
<pre>   ,.write_mask_i</pre>
<pre>   ,.data_o</pre>
<pre>   );</pre>
<pre>    assert (data_width_p % 8 == 0)</pre>
<pre>      else $error("data width should be a multiple of 8 for byte masking");</pre>
<pre></pre>
<pre style="background-color: #FF0000;">     begin</pre>
<pre>        $display("## %L: instantiating data_width_p=%d, els_p=%d (%m)",data_width_p,els_p);</pre>
<pre>     end</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_counter_up_down.v</h3>
<pre>module bsg_counter_up_down #( parameter max_val_p    = -1</pre>
<pre>                                     , parameter init_val_p   = -1</pre>
<pre>                                     , parameter max_step_p   = -1</pre>
<pre>                                        `BSG_WIDTH(max_step_p)</pre>
<pre>                                     , parameter ptr_width_lp =</pre>
<pre>                                        `BSG_WIDTH(max_val_p))</pre>
<pre>   ( input                            clk_i</pre>
<pre>   , input                            reset_i</pre>
<pre></pre>
<pre>   , input        [step_width_lp-1:0] down_i</pre>
<pre></pre>
<pre>    );</pre>
<pre>  begin</pre>
<pre>    if (reset_i)</pre>
<pre>			count_o <= init_val_p;</pre>
<pre>    else</pre>
<pre>  end</pre>
<pre>    if ((count_o==max_val_p) & up_i   & (reset_i === 1'b0))</pre>
<pre>		  $display("%m error: counter overflow at time %t", $time);</pre>
<pre>	  if ((count_o==0)         & down_i & (reset_i === 1'b0))</pre>
<pre>		  $display("%m error: counter underflow at time %t", $time);</pre>
<pre>  end</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_counter_up_down_variable.v</h3>
<pre>module bsg_counter_up_down_variable #( parameter max_val_p    = -1</pre>
<pre>                                     , parameter init_val_p   = -1</pre>
<pre>                                     , parameter max_step_p   = -1</pre>
<pre>                                        `BSG_WIDTH(max_step_p)</pre>
<pre>                                     , parameter ptr_width_lp =</pre>
<pre>                                        `BSG_WIDTH(max_val_p)</pre>
<pre>                                     )</pre>
<pre>    , input                            reset_i</pre>
<pre></pre>
<pre>    , input        [step_width_lp-1:0] down_i</pre>
<pre></pre>
<pre>    );</pre>
<pre>  begin</pre>
<pre>    if (reset_i)</pre>
<pre>			count_o <= init_val_p;</pre>
<pre>    else</pre>
<pre>  end</pre>
<pre>     if ((count_o==max_val_p) & up_i   & (reset_i===0))</pre>
<pre>       $display("%m error: counter overflow at time %t", $time);</pre>
<pre>     if ((count_o==0)         & down_i & (reset_i===0))</pre>
<pre>       $display("%m error: counter underflow at time %t", $time);</pre>
<pre>  end</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_crossbar_o_by_i.v</h3>
<pre>module bsg_crossbar_o_by_i #( parameter i_els_p = -1</pre>
<pre>                             ,parameter o_els_p = -1</pre>
<pre>                             ,parameter width_p = -1</pre>
<pre>  ( input  [i_els_p-1:0][width_p-1:0] i</pre>
<pre>   ,input  [o_els_p-1:0][i_els_p-1:0] sel_oi_one_hot_i</pre>
<pre>   ,output [o_els_p-1:0][width_p-1:0] o</pre>
<pre style="background-color: #FF0000;">  genvar lineout;</pre>
<pre>  for(lineout=0; lineout<o_els_p; lineout++)</pre>
<pre>  begin</pre>
<pre>    bsg_mux_one_hot #( .width_p(width_p)</pre>
<pre>                      ,.els_p  (i_els_p)</pre>
<pre style="background-color: #FF0000;">                     ) mux_one_hot</pre>
<pre>                     ( .data_i        (i)</pre>
<pre>                      ,.sel_one_hot_i (sel_oi_one_hot_i[lineout])</pre>
<pre>                      ,.data_o        (o[lineout])</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_dff.v</h3>
<pre>module bsg_dff #(width_p=-1</pre>
<pre style="background-color: #FF0000;">		 ,harden_p=0</pre>
<pre style="background-color: #FF0000;">		 ,strength_p=1   // set drive strength</pre>
<pre>   (input   clk_i</pre>
<pre>    ,input  [width_p-1:0] data_i</pre>
<pre>    ,output [width_p-1:0] data_o</pre>
<pre>   reg [width_p-1:0] data_r;</pre>
<pre>   assign data_o = data_r;</pre>
<pre>   always @(posedge clk_i)</pre>
<pre>     data_r <= data_i;</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_decode.v</h3>
<pre>module bsg_decode #(parameter num_out_p="inv")</pre>
<pre>  ,output logic [num_out_p-1:0] o</pre>
<pre>);</pre>
<pre>    // suppress unused signal warning</pre>
<pre>    assign o = 1'b1;</pre>
<pre>  end</pre>
<pre>    assign o = (num_out_p) ' (1'b1 << i);</pre>
<pre>  end</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_decode_with_v.v</h3>
<pre>module bsg_decode_with_v #(num_out_p=-1)</pre>
<pre>    ,input v_i</pre>
<pre>    ,output [num_out_p-1:0] o</pre>
<pre>    );</pre>
<pre></pre>
<pre>                ) bd</pre>
<pre style="background-color: #FF0000;">     (.i</pre>
<pre>      ,.o(lo)</pre>
<pre>      );</pre>
<pre></pre>
<h3>./external/basejump_stl/bsg_misc/bsg_encode_one_hot.v</h3>
<pre>module bsg_encode_one_hot #(parameter width_p=8, parameter lo_to_hi_p=1)</pre>
<pre>    , output [`BSG_SAFE_CLOG2(width_p)-1:0] addr_o  // feed 32 bits in, requires spots 32 to encode (0..31)</pre>
<pre>    , output v_o                           // whether any bit was found</pre>
<pre>    );</pre>
<pre>   localparam aligned_width_lp = 1 << $clog2(width_p);</pre>
<pre></pre>
<pre></pre>
<pre>     begin : base</pre>
<pre>        assign v_o = i;</pre>
<pre></pre>
<pre>     end</pre>
<pre style="background-color: #FF0000;">       begin : unaligned</pre>
<pre style="background-color: #FF0000;">	  wire [$clog2(aligned_width_lp)-1:0] aligned_addr;</pre>
<pre>	  wire [aligned_width_lp-width_p-1:0] zero_pad = { (aligned_width_lp-width_p) {1'b0} };</pre>
<pre>	  wire [aligned_width_lp-1:0] 	      padded = lo_to_hi_p ? { zero_pad, i } : { i, zero_pad };</pre>
<pre>	  </pre>
<pre style="background-color: #FF0000;">          align(.i      (padded      )</pre>
<pre style="background-color: #FF0000;">                ,.addr_o(aligned_addr)</pre>
<pre style="background-color: #FF0000;">                ,.v_o   (v_o         )</pre>
<pre style="background-color: #FF0000;">                );</pre>
<pre>       end</pre>
<pre style="background-color: #FF0000;">          wire [1:0] [`BSG_SAFE_CLOG2(half_width_lp)-1:0] addrs;</pre>
<pre style="background-color: #FF0000;">          wire [1:0]                     vs;</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">            (.i      (i    [0+:half_width_lp])</pre>
<pre style="background-color: #FF0000;">             ,.addr_o(addrs[0]               )</pre>
<pre style="background-color: #FF0000;">             ,.v_o   (vs   [0]               )</pre>
<pre style="background-color: #FF0000;">             );</pre>
<pre style="background-color: #FF0000;">            (.i      (i[half_width_lp+:half_width_lp])</pre>
<pre style="background-color: #FF0000;">             ,.addr_o(addrs[1]                       )</pre>
<pre style="background-color: #FF0000;">             ,.v_o   (vs   [1]                       )</pre>
<pre style="background-color: #FF0000;">             );</pre>
<pre style="background-color: #FF0000;">	  if (width_p == 2)</pre>
<pre style="background-color: #FF0000;">	    assign addr_lo = vs[lo_to_hi_p];</pre>
<pre style="background-color: #FF0000;">	  else</pre>
<pre style="background-color: #FF0000;">       end // block: aligned</pre>
<pre>      ? addr_lo</pre>
<pre>      : {`BSG_SAFE_CLOG2(width_p){1'bx}};</pre>
<pre>  `endif</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_dff_en_bypass.v</h3>
<pre>module bsg_dff_en_bypass</pre>
<pre>  #(parameter width_p="inv"</pre>
<pre>    , parameter harden_p=0</pre>
<pre>    , parameter strength_p=0</pre>
<pre>    input clk_i</pre>
<pre>    , input en_i</pre>
<pre>    , input [width_p-1:0] data_i</pre>
<pre>    , output logic [width_p-1:0] data_o</pre>
<pre>  logic [width_p-1:0] data_r;</pre>
<pre style="background-color: #FF0000;">  bsg_dff_en #(</pre>
<pre style="background-color: #FF0000;">    .width_p(width_p)</pre>
<pre style="background-color: #FF0000;">    ,.harden_p(harden_p)</pre>
<pre style="background-color: #FF0000;">    ,.strength_p(strength_p)</pre>
<pre style="background-color: #FF0000;">  ) dff (</pre>
<pre style="background-color: #FF0000;">    .clk_i(clk_i)</pre>
<pre style="background-color: #FF0000;">    ,.en_i(en_i)</pre>
<pre style="background-color: #FF0000;">    ,.data_i(data_i)</pre>
<pre style="background-color: #FF0000;">    ,.data_o(data_r)</pre>
<pre>  assign data_o = en_i</pre>
<pre>    ? data_i</pre>
<pre>    : data_r;</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_dff_reset.v</h3>
<pre>module bsg_dff_reset #(width_p=-1, reset_val_p=0, harden_p=0)</pre>
<pre>   (input   clk_i</pre>
<pre>   ,input  reset_i</pre>
<pre>    ,input  [width_p-1:0] data_i</pre>
<pre>    ,output [width_p-1:0] data_o</pre>
<pre>   reg [width_p-1:0] data_r;</pre>
<pre>   assign data_o = data_r;</pre>
<pre>   always @(posedge clk_i)</pre>
<pre>     begin</pre>
<pre>        if (reset_i)</pre>
<pre>          data_r <= width_p'(reset_val_p);</pre>
<pre>          data_r <= data_i;</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_dff_en.v</h3>
<pre>module bsg_dff_en #(parameter width_p="inv"</pre>
<pre>                   ,parameter harden_p=1   // mbt fixme: maybe this should not be a default</pre>
<pre>                   ,parameter strength_p=1)</pre>
<pre>  input clk_i</pre>
<pre>  ,input [width_p-1:0] data_i</pre>
<pre>  ,input en_i</pre>
<pre>  ,output logic [width_p-1:0] data_o</pre>
<pre>  logic [width_p-1:0] data_r;</pre>
<pre>  assign data_o = data_r;</pre>
<pre>  always_ff @ (posedge clk_i) begin</pre>
<pre>    if (en_i) begin</pre>
<pre>      data_r <= data_i;</pre>
<h3>./bp_be/src/v/bp_be_checker/bp_be_checker_top.v</h3>
<pre style="background-color: #FF0000;"> *   bp_be_checker_top.v</pre>
<pre style="background-color: #FF0000;"> * </pre>
<pre style="background-color: #FF0000;"> * Description:</pre>
<pre> *   This is a wrapper for the Checker, which is responsible for scheduling instruction</pre>
<pre> *     execution and protecting architectural state from the effects of speculation. It </pre>
<pre> *     contains 3 main components: the Scheduler, the Director and the Detector. </pre>
<pre> *   The Scheduler accepts PC/instruction pairs from the FE and issues them to the Calculator. </pre>
<pre> *   The Detector detects structural, control and data hazards and generates control signals </pre>
<pre> *     for the Calculator to flush or inserts bubbles into the execution pipeline.</pre>
<pre> *</pre>
<pre> * Notes:</pre>
<pre> *</pre>
<pre> */</pre>
<pre></pre>
<pre>module bp_be_checker_top </pre>
<pre> import bp_common_pkg::*;</pre>
<pre> import bp_common_aviary_pkg::*;</pre>
<pre> import bp_common_rv64_pkg::*;</pre>
<pre> import bp_be_pkg::*;</pre>
<pre> import bp_cfg_link_pkg::*;</pre>
<pre> #(parameter bp_cfg_e cfg_p = e_bp_inv_cfg</pre>
<pre>    `declare_bp_proc_params(cfg_p)</pre>
<pre>    `declare_bp_fe_be_if_widths(vaddr_width_p, paddr_width_p, asid_width_p, branch_metadata_fwd_width_p)</pre>
<pre></pre>
<pre>   // Generated parameters</pre>
<pre>   , localparam isd_status_width_lp = `bp_be_isd_status_width</pre>
<pre>   , localparam calc_status_width_lp = `bp_be_calc_status_width(vaddr_width_p, branch_metadata_fwd_width_p)</pre>
<pre>   , localparam issue_pkt_width_lp   = `bp_be_issue_pkt_width(vaddr_width_p, branch_metadata_fwd_width_p)</pre>
<pre>   // VM parameters</pre>
<pre>   , localparam tlb_entry_width_lp = `bp_pte_entry_leaf_width(paddr_width_p)</pre>
<pre>   )</pre>
<pre>  (input                              clk_i</pre>
<pre>   , input                            reset_i</pre>
<pre>   , input                            freeze_i</pre>
<pre></pre>
<pre>   // Config channel</pre>
<pre style="background-color: #FF0000;">   , input                            cfg_w_v_i</pre>
<pre>   , input [cfg_addr_width_p-1:0]     cfg_addr_i</pre>
<pre>   , input [cfg_data_width_p-1:0]     cfg_data_i</pre>
<pre></pre>
<pre>   // FE cmd interface</pre>
<pre>   , output [fe_cmd_width_lp-1:0]     fe_cmd_o</pre>
<pre>   , output                           fe_cmd_v_o</pre>
<pre>   , input                            fe_cmd_ready_i</pre>
<pre></pre>
<pre>   // FE queue interface</pre>
<pre>   , output                           fe_queue_roll_o</pre>
<pre>   , output                           fe_queue_deq_o</pre>
<pre></pre>
<pre>   , input                            fe_queue_v_i</pre>
<pre>   , output                           fe_queue_yumi_o</pre>
<pre></pre>
<pre>   // Instruction issue interface</pre>
<pre>   , output [issue_pkt_width_lp-1:0]  issue_pkt_o</pre>
<pre>   , output                           issue_pkt_v_o</pre>
<pre>   , input                            issue_pkt_ready_i</pre>
<pre></pre>
<pre>   // Dependency information</pre>
<pre>   , input [isd_status_width_lp-1:0]  isd_status_i</pre>
<pre>   , input [calc_status_width_lp-1:0] calc_status_i</pre>
<pre>   , input                            mmu_cmd_ready_i</pre>
<pre>   , input                            credits_full_i</pre>
<pre>   , input                            credits_empty_i</pre>
<pre></pre>
<pre>   // Checker pipeline control information</pre>
<pre>   , output                           chk_roll_o</pre>
<pre>   , output                           chk_poison_iss_o</pre>
<pre>   , output                           chk_poison_isd_o</pre>
<pre>   , output                           chk_poison_ex1_o</pre>
<pre>   , output                           chk_poison_ex2_o</pre>
<pre></pre>
<pre>   // CSR interface</pre>
<pre>   , input                            trap_v_i</pre>
<pre>   , input                            ret_v_i</pre>
<pre>   , output [vaddr_width_p-1:0]       pc_o</pre>
<pre>   , input [vaddr_width_p-1:0]        tvec_i</pre>
<pre>   , input [vaddr_width_p-1:0]        epc_i</pre>
<pre>   , input                            tlb_fence_i</pre>
<pre>   </pre>
<pre>    , input                           itlb_fill_v_i</pre>
<pre>    , input [vaddr_width_p-1:0]       itlb_fill_vaddr_i</pre>
<pre>    , input [tlb_entry_width_lp-1:0]  itlb_fill_entry_i</pre>
<pre>   );</pre>
<pre></pre>
<pre>// Declare parameterizable structures</pre>
<pre>`declare_bp_be_internal_if_structs(vaddr_width_p, paddr_width_p, asid_width_p, branch_metadata_fwd_width_p); </pre>
<pre style="background-color: #FF0000;"></pre>
<pre>bp_be_calc_status_s calc_status_cast_i;</pre>
<pre>assign calc_status_cast_i = calc_status_i;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">// Intermediate connections</pre>
<pre>logic [vaddr_width_p-1:0] expected_npc_lo;</pre>
<pre>logic flush;</pre>
<pre></pre>
<pre>// Datapath</pre>
<pre>bp_be_director </pre>
<pre> #(.cfg_p(cfg_p))</pre>
<pre> director</pre>
<pre>  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre>   ,.freeze_i(freeze_i)</pre>
<pre></pre>
<pre>   ,.cfg_w_v_i(cfg_w_v_i)</pre>
<pre>   ,.cfg_addr_i(cfg_addr_i)</pre>
<pre>   ,.cfg_data_i(cfg_data_i)</pre>
<pre></pre>
<pre>   ,.calc_status_i(calc_status_i) </pre>
<pre>   ,.expected_npc_o(expected_npc_lo)</pre>
<pre>   ,.flush_o(flush)</pre>
<pre></pre>
<pre>   ,.fe_cmd_o(fe_cmd_o)</pre>
<pre>   ,.fe_cmd_v_o(fe_cmd_v_o)</pre>
<pre>   ,.fe_cmd_ready_i(fe_cmd_ready_i)</pre>
<pre></pre>
<pre>   ,.trap_v_i(trap_v_i)</pre>
<pre>   ,.ret_v_i(ret_v_i)</pre>
<pre>   ,.pc_o(pc_o)</pre>
<pre>   ,.tvec_i(tvec_i)</pre>
<pre>   ,.epc_i(epc_i)</pre>
<pre>   ,.tlb_fence_i(tlb_fence_i)</pre>
<pre></pre>
<pre>   ,.itlb_fill_vaddr_i(itlb_fill_vaddr_i)</pre>
<pre>   ,.itlb_fill_entry_i(itlb_fill_entry_i)</pre>
<pre>   );</pre>
<pre>bp_be_detector </pre>
<pre> #(.cfg_p(cfg_p))</pre>
<pre> detector</pre>
<pre>  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>   ,.isd_status_i(isd_status_i)</pre>
<pre>   ,.calc_status_i(calc_status_i)</pre>
<pre>   ,.expected_npc_i(expected_npc_lo)</pre>
<pre>   ,.mmu_cmd_ready_i(mmu_cmd_ready_i)</pre>
<pre>   ,.credits_full_i(credits_full_i)</pre>
<pre>   ,.credits_empty_i(credits_empty_i)</pre>
<pre></pre>
<pre>   ,.flush_i(flush)</pre>
<pre></pre>
<pre>   ,.chk_dispatch_v_o(chk_dispatch_v_o)</pre>
<pre>   ,.chk_roll_o(chk_roll_o)</pre>
<pre>   ,.chk_poison_iss_o(chk_poison_iss_o)</pre>
<pre>   ,.chk_poison_isd_o(chk_poison_isd_o)</pre>
<pre>   ,.chk_poison_ex1_o(chk_poison_ex1_o)</pre>
<pre>   ,.chk_poison_ex2_o(chk_poison_ex2_o)</pre>
<pre>   );</pre>
<pre></pre>
<pre style="background-color: #FF0000;">bp_be_scheduler </pre>
<pre> #(.cfg_p(cfg_p))</pre>
<pre> scheduler</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>   ,.cmt_v_i(calc_status_cast_i.mem3_cmt_v)</pre>
<pre></pre>
<pre>   ,.fe_queue_roll_o(fe_queue_roll_o)</pre>
<pre></pre>
<pre>   ,.fe_queue_v_i(fe_queue_v_i)</pre>
<pre>   ,.fe_queue_yumi_o(fe_queue_yumi_o)</pre>
<pre></pre>
<pre>   ,.issue_pkt_v_o(issue_pkt_v_o)</pre>
<pre>   ,.issue_pkt_ready_i(issue_pkt_ready_i)</pre>
<pre>   );</pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./bp_be/src/v/bp_be_mem/bp_be_dcache/bp_be_dcache.v</h3>
<pre> *    set-associative.</pre>
<pre> *</pre>
<pre> *    There are three different 1rw memory blocks: data_mem, tag_mem, stat_mem.</pre>
<pre> *    word_offset ^ way_id".  </pre>
<pre> *    </pre>
<pre> *    tag_mem contains tag and coherence state bits.</pre>
<pre> *    </pre>
<pre> *    stat_mem contains information about dirty bits for each cache block and</pre>
<pre> *    LRU info about each way group. This cache uses pseudo tree-LRU</pre>
<pre> *    algorithm.</pre>
<pre> *</pre>
<pre> *    There are two pipeline stages: tag lookup (tl) and tag verity (tv) stages.</pre>
<pre> *    Signals or registers belonging to each stage is suffixed by "_tl" or</pre>
<pre> *    </pre>
<pre> *    There is write buffer which allows holding write data info that left tv stage,</pre>
<pre> *    in forms of "bp_be_dcache_wbuf_entry_s" until data_mem becomes free from incoming</pre>
<pre> *    load instructions. It also allows bypassing of store data when load moving</pre>
<pre> *    from tl to tv stage has the same address as the entries in write buffer.</pre>
<pre> *    LCE can snoop write buffer entries to hold off lce_data_mem operations until entries</pre>
<pre> *</pre>
<pre> *    Load reserved and store conditional are implemented at a cache line granularity.</pre>
<pre> *    A load reserved acts as a normal load with the following addtional properties:</pre>
<pre> *    1) If the block is not in an exclusive ownership state (M or E in MESI), then the cache</pre>
<pre>module bp_be_dcache</pre>
<pre>   `declare_bp_proc_params(cfg_p)</pre>
<pre></pre>
<pre>    , localparam data_mask_width_lp=(dword_width_p>>3)</pre>
<pre>    , localparam byte_offset_width_lp=`BSG_SAFE_CLOG2(dword_width_p>>3)</pre>
<pre>    , localparam word_offset_width_lp=`BSG_SAFE_CLOG2(block_size_in_words_lp)</pre>
<pre>    , localparam block_offset_width_lp=(word_offset_width_lp+byte_offset_width_lp)</pre>
<pre>    , localparam index_width_lp=`BSG_SAFE_CLOG2(lce_sets_p)</pre>
<pre>    , localparam ptag_width_lp=(paddr_width_p-bp_page_offset_width_gp)</pre>
<pre>    , localparam tag_width_lp=(paddr_width_p-block_offset_width_lp-index_width_lp)</pre>
<pre>    , localparam way_id_width_lp=`BSG_SAFE_CLOG2(lce_assoc_p)</pre>
<pre>  </pre>
<pre>    , localparam lce_data_width_lp=(lce_assoc_p*dword_width_p)</pre>
<pre>    , localparam lce_id_width_lp=`BSG_SAFE_CLOG2(num_lce_p)</pre>
<pre></pre>
<pre>    , localparam dcache_pkt_width_lp=`bp_be_dcache_pkt_width(page_offset_width_p,dword_width_p)</pre>
<pre>    , localparam tag_info_width_lp=`bp_be_dcache_tag_info_width(tag_width_lp)</pre>
<pre>    , localparam stat_info_width_lp=`bp_be_dcache_stat_info_width(lce_assoc_p)</pre>
<pre>   </pre>
<pre>    `declare_bp_lce_cce_if_widths(num_cce_p, num_lce_p, paddr_width_p, lce_assoc_p, dword_width_p, cce_block_width_p) </pre>
<pre>  )</pre>
<pre>    , input reset_i</pre>
<pre>    , input freeze_i</pre>
<pre>    </pre>
<pre>    // Config channel</pre>
<pre>    , input                        cfg_w_v_i</pre>
<pre>    , input [cfg_addr_width_p-1:0] cfg_addr_i</pre>
<pre>    , input [cfg_data_width_p-1:0] cfg_data_i</pre>
<pre></pre>
<pre>    , input [lce_id_width_lp-1:0] lce_id_i</pre>
<pre></pre>
<pre>    , input [dcache_pkt_width_lp-1:0] dcache_pkt_i</pre>
<pre>    , input v_i</pre>
<pre>    , output logic ready_o</pre>
<pre></pre>
<pre>    , output logic [dword_width_p-1:0] data_o</pre>
<pre>    , output logic v_o</pre>
<pre></pre>
<pre>    // TLB interface</pre>
<pre>    , input tlb_miss_i</pre>
<pre>    , input [ptag_width_lp-1:0] ptag_i</pre>
<pre>    , input uncached_i</pre>
<pre></pre>
<pre style="background-color: #FF0000;">    // ctrl</pre>
<pre>    , input poison_i</pre>
<pre></pre>
<pre>    // LCE-CCE interface</pre>
<pre>    , output logic lce_req_v_o</pre>
<pre>    , input lce_req_ready_i</pre>
<pre></pre>
<pre>    , output logic [lce_cce_resp_width_lp-1:0] lce_resp_o</pre>
<pre>    , output logic lce_resp_v_o</pre>
<pre>    , input lce_resp_ready_i</pre>
<pre></pre>
<pre>    // CCE-LCE interface</pre>
<pre>    , input [lce_cmd_width_lp-1:0] lce_cmd_i</pre>
<pre>    , input lce_cmd_v_i</pre>
<pre>    , output logic lce_cmd_ready_o</pre>
<pre></pre>
<pre>    // LCE-LCE interface</pre>
<pre>    , output logic [lce_cmd_width_lp-1:0] lce_cmd_o</pre>
<pre>    , output logic lce_cmd_v_o</pre>
<pre>    , input lce_cmd_ready_i </pre>
<pre></pre>
<pre>    , output credits_full_o</pre>
<pre>    , output credits_empty_o</pre>
<pre></pre>
<pre>    , output load_access_fault_o</pre>
<pre>    , output store_access_fault_o</pre>
<pre>  );</pre>
<pre>  // packet decoding</pre>
<pre style="background-color: #FF0000;">  `declare_bp_be_dcache_pkt_s(bp_page_offset_width_gp, dword_width_p);</pre>
<pre>  assign dcache_pkt = dcache_pkt_i;</pre>
<pre></pre>
<pre>  logic sc_op;</pre>
<pre>  logic load_op;</pre>
<pre>  logic store_op;</pre>
<pre>  logic signed_op;</pre>
<pre>  logic [1:0] size_op;</pre>
<pre>  logic double_op;</pre>
<pre>  logic word_op;</pre>
<pre>  logic half_op;</pre>
<pre>  logic byte_op;</pre>
<pre>  logic [index_width_lp-1:0] addr_index;</pre>
<pre>  logic [word_offset_width_lp-1:0] addr_word_offset;</pre>
<pre></pre>
<pre>    lr_op     = 1'b0;</pre>
<pre>    sc_op     = 1'b0;</pre>
<pre>    load_op   = 1'b0;</pre>
<pre>    store_op  = 1'b0;</pre>
<pre>    signed_op = 1'b1;</pre>
<pre>    double_op = 1'b0;</pre>
<pre>    word_op   = 1'b0;</pre>
<pre>    half_op   = 1'b0;</pre>
<pre>    byte_op   = 1'b0;</pre>
<pre>    size_op   = 1'b0;</pre>
<pre></pre>
<pre>      e_dcache_opcode_lrw, e_dcache_opcode_lrd: begin</pre>
<pre>        // An LR is a load operation of either double word or word size, inherently signed</pre>
<pre>        load_op   = 1'b1;</pre>
<pre>      end</pre>
<pre>        // An SC is a store operation of either double word or word size, inherently signed</pre>
<pre>        store_op  = 1'b1;</pre>
<pre>      end</pre>
<pre>        load_op   = 1'b1;</pre>
<pre>      end</pre>
<pre>        load_op   = 1'b1;</pre>
<pre>        signed_op = 1'b0;</pre>
<pre>      end</pre>
<pre>        store_op  = 1'b1;</pre>
<pre>      end</pre>
<pre>      e_dcache_opcode_ld, e_dcache_opcode_lrd, e_dcache_opcode_sd, e_dcache_opcode_scd: begin</pre>
<pre>        double_op = 1'b1;</pre>
<pre>        size_op   = 2'b11;</pre>
<pre>      end</pre>
<pre>        , e_dcache_opcode_lrw, e_dcache_opcode_scw: begin</pre>
<pre>        word_op = 1'b1;</pre>
<pre>        size_op = 2'b10;</pre>
<pre>      end</pre>
<pre>        half_op = 1'b1;</pre>
<pre>        size_op = 2'b01;</pre>
<pre>      end</pre>
<pre>        byte_op = 1'b1;</pre>
<pre>        size_op = 2'b00;</pre>
<pre>      end</pre>
<pre>  assign addr_word_offset = dcache_pkt.page_offset[byte_offset_width_lp+:word_offset_width_lp];</pre>
<pre>  </pre>
<pre>  logic tl_we;</pre>
<pre>  logic lr_op_tl_r;</pre>
<pre>  logic sc_op_tl_r;</pre>
<pre>  logic load_op_tl_r;</pre>
<pre>  logic store_op_tl_r;</pre>
<pre>  logic signed_op_tl_r;</pre>
<pre>  logic [1:0] size_op_tl_r;</pre>
<pre>  logic double_op_tl_r;</pre>
<pre>  logic word_op_tl_r;</pre>
<pre>  logic half_op_tl_r;</pre>
<pre>  logic byte_op_tl_r;</pre>
<pre>  logic [bp_page_offset_width_gp-1:0] page_offset_tl_r;</pre>
<pre>  logic [dword_width_p-1:0] data_tl_r;</pre>
<pre></pre>
<pre> </pre>
<pre>    if (reset_i) begin</pre>
<pre>      v_tl_r <= 1'b0;</pre>
<pre>    end</pre>
<pre>      v_tl_r <= tl_we;</pre>
<pre>      if (tl_we) begin</pre>
<pre>        lr_op_tl_r <= lr_op;</pre>
<pre>        sc_op_tl_r <= sc_op;</pre>
<pre>        load_op_tl_r <= load_op;</pre>
<pre>        store_op_tl_r <= store_op;</pre>
<pre>        signed_op_tl_r <= signed_op;</pre>
<pre>        size_op_tl_r <= size_op;</pre>
<pre>        double_op_tl_r <= double_op;</pre>
<pre>        word_op_tl_r <= word_op;</pre>
<pre>        half_op_tl_r <= half_op;</pre>
<pre>        byte_op_tl_r <= byte_op;</pre>
<pre>        page_offset_tl_r <= dcache_pkt.page_offset;</pre>
<pre>      end</pre>
<pre>        data_tl_r <= dcache_pkt.data;</pre>
<pre>      end</pre>
<pre>  logic tag_mem_w_li;</pre>
<pre>  logic [index_width_lp-1:0] tag_mem_addr_li;</pre>
<pre>  bp_be_dcache_tag_info_s [lce_assoc_p-1:0] tag_mem_data_li;</pre>
<pre>  bp_be_dcache_tag_info_s [lce_assoc_p-1:0] tag_mem_mask_li;</pre>
<pre>  bp_be_dcache_tag_info_s [lce_assoc_p-1:0] tag_mem_data_lo;</pre>
<pre>  </pre>
<pre>    #(.width_p(tag_info_width_lp*lce_assoc_p)</pre>
<pre>      ,.els_p(lce_sets_p)</pre>
<pre>    )</pre>
<pre style="background-color: #FF0000;">      (.clk_i(clk_i)</pre>
<pre>      ,.reset_i(reset_i)</pre>
<pre>      ,.v_i(~reset_i & tag_mem_v_li)</pre>
<pre>      ,.w_i(tag_mem_w_li)</pre>
<pre>      ,.addr_i(tag_mem_addr_li)</pre>
<pre>      ,.data_i(tag_mem_data_li)</pre>
<pre>      ,.w_mask_i(tag_mem_mask_li)</pre>
<pre>      ,.data_o(tag_mem_data_lo)</pre>
<pre>      );</pre>
<pre style="background-color: #FF0000;">  logic [lce_assoc_p-1:0] data_mem_v_li;</pre>
<pre>  logic data_mem_w_li;</pre>
<pre>  logic [lce_assoc_p-1:0][index_width_lp+word_offset_width_lp-1:0] data_mem_addr_li;</pre>
<pre>  logic [lce_assoc_p-1:0][dword_width_p-1:0] data_mem_data_li;</pre>
<pre>  logic [lce_assoc_p-1:0][data_mask_width_lp-1:0] data_mem_mask_li;</pre>
<pre>  logic [lce_assoc_p-1:0][dword_width_p-1:0] data_mem_data_lo;</pre>
<pre>  </pre>
<pre>    bsg_mem_1rw_sync_mask_write_byte</pre>
<pre>      #(.data_width_p(dword_width_p)</pre>
<pre>        ,.els_p(lce_sets_p*lce_assoc_p)</pre>
<pre>        )</pre>
<pre style="background-color: #FF0000;">      data_mem</pre>
<pre style="background-color: #FF0000;">        (.clk_i(clk_i)</pre>
<pre>        ,.reset_i(reset_i)</pre>
<pre>        ,.v_i(~reset_i & data_mem_v_li[i])</pre>
<pre>        ,.w_i(data_mem_w_li)</pre>
<pre>        ,.addr_i(data_mem_addr_li[i])</pre>
<pre>        ,.data_i(data_mem_data_li[i])</pre>
<pre>        ,.write_mask_i(data_mem_mask_li[i])</pre>
<pre>        ,.data_o(data_mem_data_lo[i])</pre>
<pre>        );</pre>
<pre>  logic tv_we;</pre>
<pre>  logic lr_op_tv_r;</pre>
<pre>  logic sc_op_tv_r;</pre>
<pre>  logic load_op_tv_r;</pre>
<pre>  logic store_op_tv_r;</pre>
<pre>  logic signed_op_tv_r;</pre>
<pre>  logic [1:0] size_op_tv_r;</pre>
<pre>  logic double_op_tv_r;</pre>
<pre>  logic word_op_tv_r;</pre>
<pre>  logic half_op_tv_r;</pre>
<pre>  logic byte_op_tv_r;</pre>
<pre>  logic uncached_tv_r;</pre>
<pre>  logic [paddr_width_p-1:0] paddr_tv_r;</pre>
<pre>  logic [dword_width_p-1:0] data_tv_r;</pre>
<pre>  bp_be_dcache_tag_info_s [lce_assoc_p-1:0] tag_info_tv_r;</pre>
<pre>  logic [lce_assoc_p-1:0][dword_width_p-1:0] ld_data_tv_r;</pre>
<pre>  logic [tag_width_lp-1:0] addr_tag_tv;</pre>
<pre>  logic [index_width_lp-1:0] addr_index_tv;</pre>
<pre>  logic [word_offset_width_lp-1:0] addr_word_offset_tv;</pre>
<pre></pre>
<pre></pre>
<pre>    if (reset_i) begin</pre>
<pre>      v_tv_r <= 1'b0;</pre>
<pre></pre>
<pre>      sc_op_tv_r <= '0;</pre>
<pre>      load_op_tv_r <= '0;</pre>
<pre>      store_op_tv_r <= '0;</pre>
<pre>      uncached_tv_r <= '0;</pre>
<pre>      signed_op_tv_r <= '0;</pre>
<pre>      size_op_tv_r <= '0;</pre>
<pre>      double_op_tv_r <= '0;</pre>
<pre>      word_op_tv_r <= '0;</pre>
<pre>      half_op_tv_r <= '0;</pre>
<pre>      byte_op_tv_r <= '0;</pre>
<pre>      paddr_tv_r <= '0;</pre>
<pre>      tag_info_tv_r <= '0;</pre>
<pre></pre>
<pre>      v_tv_r <= tv_we;</pre>
<pre></pre>
<pre>        lr_op_tv_r <= lr_op_tl_r;</pre>
<pre>        sc_op_tv_r <= sc_op_tl_r;</pre>
<pre>        load_op_tv_r <= load_op_tl_r;</pre>
<pre>        store_op_tv_r <= store_op_tl_r;</pre>
<pre>        signed_op_tv_r <= signed_op_tl_r;</pre>
<pre>        size_op_tv_r <= size_op_tl_r;</pre>
<pre>        double_op_tv_r <= double_op_tl_r;</pre>
<pre>        word_op_tv_r <= word_op_tl_r;</pre>
<pre>        half_op_tv_r <= half_op_tl_r;</pre>
<pre>        byte_op_tv_r <= byte_op_tl_r;</pre>
<pre>        paddr_tv_r <= {ptag_i, page_offset_tl_r};</pre>
<pre>        tag_info_tv_r <= tag_mem_data_lo;</pre>
<pre>        uncached_tv_r <= uncached_i;</pre>
<pre>      end</pre>
<pre>        ld_data_tv_r <= data_mem_data_lo;</pre>
<pre>      end</pre>
<pre>        data_tv_r <= data_tl_r;</pre>
<pre>      end</pre>
<pre>  assign addr_index_tv = paddr_tv_r[block_offset_width_lp+:index_width_lp];</pre>
<pre>  assign addr_word_offset_tv = paddr_tv_r[byte_offset_width_lp+:word_offset_width_lp];</pre>
<pre></pre>
<pre>  logic [lce_assoc_p-1:0] load_hit_tv;</pre>
<pre>  logic [lce_assoc_p-1:0] store_hit_tv;</pre>
<pre>  logic [lce_assoc_p-1:0] invalid_tv;</pre>
<pre>  logic load_miss_tv;</pre>
<pre>  logic store_miss_tv;</pre>
<pre>  logic load_hit;</pre>
<pre>  logic store_hit;</pre>
<pre>  logic [way_id_width_lp-1:0] load_hit_way;</pre>
<pre>  logic [way_id_width_lp-1:0] store_hit_way;</pre>
<pre></pre>
<pre>    assign tag_match_tv[i] = addr_tag_tv == tag_info_tv_r[i].tag;</pre>
<pre>    assign load_hit_tv[i] = tag_match_tv[i] & (tag_info_tv_r[i].coh_state != e_COH_I);</pre>
<pre>    assign store_hit_tv[i] = tag_match_tv[i] & ((tag_info_tv_r[i].coh_state == e_COH_M)</pre>
<pre>                                                || (tag_info_tv_r[i].coh_state == e_COH_E));</pre>
<pre>    assign invalid_tv[i] = (tag_info_tv_r[i].coh_state == e_COH_I);</pre>
<pre>  end</pre>
<pre>    #(.width_p(lce_assoc_p)</pre>
<pre>      ,.lo_to_hi_p(1)</pre>
<pre>      )</pre>
<pre style="background-color: #FF0000;">    (.i(load_hit_tv)</pre>
<pre>      ,.v_o(load_hit)</pre>
<pre>      ,.addr_o(load_hit_way)</pre>
<pre>      );</pre>
<pre>    #(.width_p(lce_assoc_p)</pre>
<pre>      ,.lo_to_hi_p(1)</pre>
<pre>      )</pre>
<pre style="background-color: #FF0000;">    (.i(store_hit_tv)</pre>
<pre>      ,.v_o(store_hit)</pre>
<pre>      ,.addr_o(store_hit_way)</pre>
<pre>      );</pre>
<pre>  assign store_miss_tv = ~store_hit & v_tv_r & store_op_tv_r & ~uncached_tv_r & ~sc_op_tv_r;</pre>
<pre></pre>
<pre>  logic uncached_store_req;</pre>
<pre>  logic uncached_load_data_v_r;</pre>
<pre>  logic [dword_width_p-1:0] uncached_load_data_r;</pre>
<pre></pre>
<pre>  logic sc_success;</pre>
<pre>  logic sc_fail;</pre>
<pre>  logic [ptag_width_lp-1:0]  load_reserved_tag_r;</pre>
<pre>  logic [index_width_lp-1:0] load_reserved_index_r;</pre>
<pre>  logic load_reserved_v_r;</pre>
<pre></pre>
<pre>  // Succeed if the address matches and we have a store hit</pre>
<pre>                       & (load_reserved_tag_r == addr_tag_tv)</pre>
<pre>                       & (load_reserved_index_r == addr_index_tv);</pre>
<pre>  // Fail if we have a store conditional without success</pre>
<pre>  assign uncached_load_req = v_tv_r & load_op_tv_r & uncached_tv_r & ~uncached_load_data_v_r;</pre>
<pre>  assign uncached_store_req = v_tv_r & store_op_tv_r & uncached_tv_r;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">  `declare_bp_be_dcache_wbuf_entry_s(paddr_width_p, dword_width_p, lce_assoc_p);</pre>
<pre>  logic wbuf_v_li;</pre>
<pre></pre>
<pre>  logic wbuf_v_lo;</pre>
<pre>  logic wbuf_yumi_li;</pre>
<pre>  </pre>
<pre>  </pre>
<pre>  logic bypass_addr_li;</pre>
<pre>  logic [dword_width_p-1:0] bypass_data_lo;</pre>
<pre>  logic [data_mask_width_lp-1:0] bypass_mask_lo;</pre>
<pre></pre>
<pre>  logic [way_id_width_lp-1:0] lce_snoop_way_li;</pre>
<pre>  logic lce_snoop_match_lo; </pre>
<pre> </pre>
<pre>    #(.data_width_p(dword_width_p)</pre>
<pre>      ,.paddr_width_p(paddr_width_p)</pre>
<pre>      ,.ways_p(lce_assoc_p)</pre>
<pre>      ,.sets_p(lce_sets_p)</pre>
<pre>      )</pre>
<pre style="background-color: #FF0000;">    ( .clk_i(clk_i)</pre>
<pre>      ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>      ,.wbuf_entry_i(wbuf_entry_in)</pre>
<pre></pre>
<pre>      ,.yumi_i(wbuf_yumi_li)</pre>
<pre>      ,.wbuf_entry_o(wbuf_entry_out)</pre>
<pre></pre>
<pre>    </pre>
<pre>      ,.bypass_addr_i({ptag_i, page_offset_tl_r})</pre>
<pre>      ,.bypass_data_o(bypass_data_lo)</pre>
<pre>      ,.bypass_mask_o(bypass_mask_lo)</pre>
<pre></pre>
<pre>      ,.lce_snoop_way_i(lce_snoop_way_li)</pre>
<pre>      ,.lce_snoop_match_o(lce_snoop_match_lo)</pre>
<pre>      );</pre>
<pre>  logic [index_width_lp-1:0] wbuf_entry_out_index;</pre>
<pre></pre>
<pre>  assign wbuf_entry_out_index = wbuf_entry_out.paddr[block_offset_width_lp+:index_width_lp];</pre>
<pre></pre>
<pre>  assign wbuf_entry_in.way_id = store_hit_way;</pre>
<pre></pre>
<pre>    assign wbuf_entry_in.data = double_op_tv_r</pre>
<pre>      ? data_tv_r</pre>
<pre>      : (word_op_tv_r</pre>
<pre>        ? {2{data_tv_r[0+:32]}}</pre>
<pre>        : (half_op_tv_r</pre>
<pre>          ? {4{data_tv_r[0+:16]}}</pre>
<pre>          : {8{data_tv_r[0+:8]}}));</pre>
<pre></pre>
<pre>      ? 8'b1111_1111</pre>
<pre>      : (word_op_tv_r</pre>
<pre>        ? {{4{paddr_tv_r[2]}}, {4{~paddr_tv_r[2]}}}</pre>
<pre>        : (half_op_tv_r</pre>
<pre>          ? {{2{paddr_tv_r[2] & paddr_tv_r[1]}}, {2{paddr_tv_r[2] & ~paddr_tv_r[1]}},</pre>
<pre>             {2{~paddr_tv_r[2] & paddr_tv_r[1]}}, {2{~paddr_tv_r[2] & ~paddr_tv_r[1]}}}</pre>
<pre>          : {(paddr_tv_r[2] & paddr_tv_r[1] & paddr_tv_r[0]), </pre>
<pre>             (paddr_tv_r[2] & paddr_tv_r[1] & ~paddr_tv_r[0]),</pre>
<pre>             (paddr_tv_r[2] & ~paddr_tv_r[1] & paddr_tv_r[0]),</pre>
<pre>             (paddr_tv_r[2] & ~paddr_tv_r[1] & ~paddr_tv_r[0]),</pre>
<pre>             (~paddr_tv_r[2] & paddr_tv_r[1] & paddr_tv_r[0]),</pre>
<pre>             (~paddr_tv_r[2] & paddr_tv_r[1] & ~paddr_tv_r[0]),</pre>
<pre>             (~paddr_tv_r[2] & ~paddr_tv_r[1] & paddr_tv_r[0]),</pre>
<pre>             (~paddr_tv_r[2] & ~paddr_tv_r[1] & ~paddr_tv_r[0])</pre>
<pre>            }));</pre>
<pre style="background-color: #FF0000;">  `declare_bp_be_dcache_stat_info_s(lce_assoc_p);</pre>
<pre>  logic stat_mem_w_li;</pre>
<pre>  logic [index_width_lp-1:0] stat_mem_addr_li;</pre>
<pre>  bp_be_dcache_stat_info_s stat_mem_data_li;</pre>
<pre>  bp_be_dcache_stat_info_s stat_mem_mask_li;</pre>
<pre>  bp_be_dcache_stat_info_s stat_mem_data_lo;</pre>
<pre></pre>
<pre>    #(.width_p(stat_info_width_lp)</pre>
<pre>      ,.els_p(lce_sets_p)</pre>
<pre>      )</pre>
<pre style="background-color: #FF0000;">      (.clk_i(clk_i)</pre>
<pre>      ,.reset_i(reset_i)</pre>
<pre>      ,.v_i(~reset_i & stat_mem_v_li)</pre>
<pre>      ,.w_i(stat_mem_w_li)</pre>
<pre>      ,.addr_i(stat_mem_addr_li)</pre>
<pre>      ,.data_i(stat_mem_data_li)</pre>
<pre>      ,.w_mask_i(stat_mem_mask_li)</pre>
<pre>      ,.data_o(stat_mem_data_lo)</pre>
<pre>      );</pre>
<pre></pre>
<pre>    .ways_p(lce_assoc_p)</pre>
<pre>  ) lru_encoder (</pre>
<pre style="background-color: #FF0000;">    .lru_i(stat_mem_data_lo.lru)</pre>
<pre>    ,.way_id_o(lru_encode)</pre>
<pre>  );</pre>
<pre>  logic [way_id_width_lp-1:0] invalid_way;</pre>
<pre>  bsg_priority_encode</pre>
<pre>    #(.width_p(lce_assoc_p)</pre>
<pre>      ,.lo_to_hi_p(1)</pre>
<pre>      )</pre>
<pre style="background-color: #FF0000;">      (.i(invalid_tv)</pre>
<pre>      ,.v_o(invalid_exist)</pre>
<pre>      ,.addr_o(invalid_way)</pre>
<pre>      );</pre>
<pre>  assign lce_lru_way_li = invalid_exist ? invalid_way : lru_encode;</pre>
<pre> </pre>
<pre style="background-color: #FF0000;">  `declare_bp_be_dcache_lce_data_mem_pkt_s(lce_sets_p, lce_assoc_p, dword_width_p*lce_assoc_p);</pre>
<pre style="background-color: #FF0000;">  `declare_bp_be_dcache_lce_tag_mem_pkt_s(lce_sets_p, lce_assoc_p, tag_width_lp);</pre>
<pre style="background-color: #FF0000;">  `declare_bp_be_dcache_lce_stat_mem_pkt_s(lce_sets_p, lce_assoc_p);</pre>
<pre>  bp_be_dcache_lce_tag_mem_pkt_s lce_tag_mem_pkt;</pre>
<pre>  bp_be_dcache_lce_stat_mem_pkt_s lce_stat_mem_pkt;</pre>
<pre></pre>
<pre>  logic [lce_assoc_p-1:0][dword_width_p-1:0] lce_data_mem_data_li;</pre>
<pre>  logic lce_data_mem_pkt_yumi;</pre>
<pre></pre>
<pre>  logic lce_tag_mem_pkt_yumi;</pre>
<pre></pre>
<pre>  logic lce_stat_mem_pkt_yumi;</pre>
<pre></pre>
<pre> </pre>
<pre>    #(.cfg_p(cfg_p))</pre>
<pre>    lce</pre>
<pre style="background-color: #FF0000;">      (.clk_i(clk_i)</pre>
<pre>      ,.reset_i(reset_i)</pre>
<pre>      ,.freeze_i(freeze_i)</pre>
<pre>    </pre>
<pre>      ,.cfg_addr_i(cfg_addr_i)</pre>
<pre>      ,.cfg_data_i(cfg_data_i)</pre>
<pre></pre>
<pre></pre>
<pre>      ,.cache_miss_o(cache_miss_o)</pre>
<pre>    </pre>
<pre>      ,.store_miss_i(store_miss_tv)</pre>
<pre>      ,.lr_miss_i(lr_miss_tv)</pre>
<pre>      ,.uncached_load_req_i(uncached_load_req)</pre>
<pre>      ,.uncached_store_req_i(uncached_store_req)</pre>
<pre></pre>
<pre>      ,.size_op_i(size_op_tv_r)</pre>
<pre>      ,.store_data_i(data_tv_r)</pre>
<pre></pre>
<pre>      ,.data_mem_pkt_o(lce_data_mem_pkt)</pre>
<pre>      ,.data_mem_data_i(lce_data_mem_data_li)</pre>
<pre>      ,.data_mem_pkt_yumi_i(lce_data_mem_pkt_yumi)</pre>
<pre></pre>
<pre>      ,.tag_mem_pkt_o(lce_tag_mem_pkt)</pre>
<pre>      ,.tag_mem_pkt_yumi_i(lce_tag_mem_pkt_yumi)</pre>
<pre></pre>
<pre>      ,.stat_mem_pkt_o(lce_stat_mem_pkt)</pre>
<pre>      ,.dirty_i(stat_mem_data_lo.dirty)</pre>
<pre>      ,.lru_way_i(lce_lru_way_li)</pre>
<pre>      ,.stat_mem_pkt_yumi_i(lce_stat_mem_pkt_yumi)</pre>
<pre>  </pre>
<pre>      ,.lce_req_v_o(lce_req_v_o)</pre>
<pre>      ,.lce_req_ready_i(lce_req_ready_i)</pre>
<pre></pre>
<pre>      ,.lce_resp_v_o(lce_resp_v_o)</pre>
<pre>      ,.lce_resp_ready_i(lce_resp_ready_i)</pre>
<pre></pre>
<pre>      ,.lce_cmd_v_i(lce_cmd_v_i)</pre>
<pre>      ,.lce_cmd_ready_o(lce_cmd_ready_o)</pre>
<pre></pre>
<pre>      ,.lce_cmd_v_o(lce_cmd_v_o)</pre>
<pre>      ,.lce_cmd_ready_i(lce_cmd_ready_i)</pre>
<pre></pre>
<pre>      ,.credits_empty_o(credits_empty_o)</pre>
<pre></pre>
<pre>      );</pre>
<pre>    ? (load_op_tv_r & ~uncached_tv_r)</pre>
<pre>    : 1'b0;</pre>
<pre>  assign store_access_fault_o = (lce_mode_lo == e_dcache_lce_mode_uncached)</pre>
<pre>    ? (store_op_tv_r & ~uncached_tv_r)</pre>
<pre>    : 1'b0;</pre>
<pre></pre>
<pre>    if (v_tv_r) begin</pre>
<pre>      if (uncached_tv_r) begin</pre>
<pre>        if (load_op_tv_r) begin</pre>
<pre>          v_o = uncached_load_data_v_r;</pre>
<pre>        end</pre>
<pre>          // uncached store_op can be committed,</pre>
<pre>        end</pre>
<pre>          v_o = 1'b0; // this should never happen</pre>
<pre>        end</pre>
<pre>        v_o = v_tv_r & ~cache_miss_o; // cached request</pre>
<pre>      end</pre>
<pre>      v_o = 1'b0;</pre>
<pre>    end</pre>
<pre>  logic [dword_width_p-1:0] bypass_data_masked;</pre>
<pre></pre>
<pre>    .width_p(dword_width_p)</pre>
<pre>    ,.els_p(lce_assoc_p)</pre>
<pre>  ) ld_data_set_select_mux (</pre>
<pre style="background-color: #FF0000;">    .data_i(ld_data_tv_r)</pre>
<pre>    ,.sel_i(load_hit_way ^ addr_word_offset_tv)</pre>
<pre>    ,.data_o(ld_data_way_picked)</pre>
<pre>  );</pre>
<pre>    .segments_p(data_mask_width_lp)</pre>
<pre>    ,.segment_width_p(8)</pre>
<pre>  ) bypass_mux_segmented (</pre>
<pre style="background-color: #FF0000;">    .data0_i(ld_data_way_picked)</pre>
<pre>    ,.data1_i(bypass_data_lo)</pre>
<pre>    ,.sel_i(bypass_mask_lo)</pre>
<pre>    ,.data_o(bypass_data_masked)</pre>
<pre>  );</pre>
<pre>  bsg_mux #(</pre>
<pre>    .width_p(dword_width_p)</pre>
<pre>    ,.els_p(2)</pre>
<pre>  ) final_data_mux (</pre>
<pre style="background-color: #FF0000;">    .data_i({uncached_load_data_r, bypass_data_masked})</pre>
<pre>    ,.sel_i(uncached_load_data_v_r)</pre>
<pre>    ,.data_o(final_data)</pre>
<pre>  );</pre>
<pre>    logic [31:0] data_word_selected;</pre>
<pre>    logic [15:0] data_half_selected;</pre>
<pre>    logic [7:0] data_byte_selected;</pre>
<pre>    logic word_sigext;</pre>
<pre>    logic half_sigext;</pre>
<pre>    logic byte_sigext;</pre>
<pre>    </pre>
<pre>      .width_p(32)</pre>
<pre>      ,.els_p(2)</pre>
<pre>    ) word_mux (</pre>
<pre style="background-color: #FF0000;">      .data_i(final_data)</pre>
<pre>      ,.sel_i(paddr_tv_r[2])</pre>
<pre>      ,.data_o(data_word_selected)</pre>
<pre>    );</pre>
<pre>      .width_p(16)</pre>
<pre>      ,.els_p(4)</pre>
<pre>    ) half_mux (</pre>
<pre style="background-color: #FF0000;">      .data_i(final_data)</pre>
<pre>      ,.sel_i(paddr_tv_r[2:1])</pre>
<pre>      ,.data_o(data_half_selected)</pre>
<pre>    );</pre>
<pre>      .width_p(8)</pre>
<pre>      ,.els_p(8)</pre>
<pre>    ) byte_mux (</pre>
<pre style="background-color: #FF0000;">      .data_i(final_data)</pre>
<pre>      ,.sel_i(paddr_tv_r[2:0])</pre>
<pre>      ,.data_o(data_byte_selected)</pre>
<pre>    );</pre>
<pre>    assign half_sigext = signed_op_tv_r & data_half_selected[15]; </pre>
<pre>    assign byte_sigext = signed_op_tv_r & data_byte_selected[7]; </pre>
<pre></pre>
<pre>      ? (double_op_tv_r</pre>
<pre>        ? final_data</pre>
<pre>        : (word_op_tv_r</pre>
<pre>          ? {{32{word_sigext}}, data_word_selected}</pre>
<pre>          : (half_op_tv_r</pre>
<pre>            ? {{48{half_sigext}}, data_half_selected}</pre>
<pre>            : {{56{byte_sigext}}, data_byte_selected})))</pre>
<pre>      : (sc_op_tv_r & ~sc_success</pre>
<pre>         ? 64'b1</pre>
<pre>         : 64'b0);;</pre>
<pre></pre>
<pre>  bsg_decode #(</pre>
<pre>    .num_out_p(lce_assoc_p)</pre>
<pre>  ) wbuf_data_mem_v_decode (</pre>
<pre style="background-color: #FF0000;">    .i(wbuf_entry_out.way_id ^ wbuf_entry_out_word_offset)</pre>
<pre>    ,.o(wbuf_data_mem_v)</pre>
<pre>  );  </pre>
<pre>  assign lce_data_mem_v = (lce_data_mem_pkt.opcode != e_dcache_lce_data_mem_uncached)</pre>
<pre>    & lce_data_mem_pkt_yumi;</pre>
<pre></pre>
<pre>    ? {lce_assoc_p{1'b1}}</pre>
<pre>    : (wbuf_yumi_li</pre>
<pre>      ? wbuf_data_mem_v</pre>
<pre>      : {lce_assoc_p{lce_data_mem_v}});</pre>
<pre></pre>
<pre>    | (lce_data_mem_pkt_yumi & lce_data_mem_pkt.opcode == e_dcache_lce_data_mem_write);</pre>
<pre></pre>
<pre></pre>
<pre>    assign data_mem_addr_li[i] = (load_op & tl_we)</pre>
<pre>      ? {addr_index, addr_word_offset}</pre>
<pre>      : (wbuf_yumi_li</pre>
<pre>        ? {wbuf_entry_out_index, wbuf_entry_out_word_offset}</pre>
<pre>        : {lce_data_mem_pkt.index, lce_data_mem_pkt.way_id ^ ((word_offset_width_lp)'(i))});</pre>
<pre>    assign data_mem_data_li[i] = wbuf_yumi_li</pre>
<pre>      ? wbuf_entry_out.data</pre>
<pre>      : lce_data_mem_write_data[i];</pre>
<pre>  </pre>
<pre>      ? wbuf_entry_out.mask</pre>
<pre>      : {data_mask_width_lp{1'b1}};</pre>
<pre>  end</pre>
<pre>    .width_p(dword_width_p)</pre>
<pre>    ,.els_p(lce_assoc_p)</pre>
<pre>  ) write_mux_butterfly (</pre>
<pre style="background-color: #FF0000;">    .data_i(lce_data_mem_pkt.data)</pre>
<pre>    ,.sel_i(lce_data_mem_pkt.way_id)</pre>
<pre>    ,.data_o(lce_data_mem_write_data)</pre>
<pre>  );</pre>
<pre>  assign tag_mem_w_li = ~tl_we & lce_tag_mem_pkt_v;</pre>
<pre>  assign tag_mem_addr_li = tl_we </pre>
<pre>    ? addr_index</pre>
<pre>    : lce_tag_mem_pkt.index;</pre>
<pre></pre>
<pre>  bsg_decode</pre>
<pre>    #(.num_out_p(lce_assoc_p))</pre>
<pre>    lce_tag_mem_way_decode</pre>
<pre style="background-color: #FF0000;">      (.i(lce_tag_mem_pkt.way_id)</pre>
<pre>      ,.o(lce_tag_mem_way_one_hot)</pre>
<pre>      );</pre>
<pre>    case (lce_tag_mem_pkt.opcode)</pre>
<pre>      e_dcache_lce_tag_mem_set_clear: begin</pre>
<pre>        tag_mem_data_li = {(tag_info_width_lp*lce_assoc_p){1'b0}};</pre>
<pre>        tag_mem_mask_li = {(tag_info_width_lp*lce_assoc_p){1'b1}};</pre>
<pre>      end</pre>
<pre>        tag_mem_data_li = {((tag_info_width_lp)*lce_assoc_p){1'b0}};</pre>
<pre>        for (integer i = 0; i < lce_assoc_p; i++) begin </pre>
<pre>          tag_mem_mask_li[i].coh_state = {`bp_coh_bits{lce_tag_mem_way_one_hot[i]}};</pre>
<pre>          tag_mem_mask_li[i].tag = {tag_width_lp{1'b0}};</pre>
<pre>        end</pre>
<pre>        tag_mem_data_li = {lce_assoc_p{lce_tag_mem_pkt.state, lce_tag_mem_pkt.tag}};</pre>
<pre>        for (integer i = 0; i < lce_assoc_p; i++) begin</pre>
<pre>          tag_mem_mask_li[i].coh_state = {`bp_coh_bits{lce_tag_mem_way_one_hot[i]}};</pre>
<pre>          tag_mem_mask_li[i].tag = {tag_width_lp{lce_tag_mem_way_one_hot[i]}};</pre>
<pre>        end</pre>
<pre>        tag_mem_data_li = {(tag_info_width_lp*lce_assoc_p){1'b0}};</pre>
<pre>        tag_mem_mask_li = {(tag_info_width_lp*lce_assoc_p){1'b0}};</pre>
<pre>      end</pre>
<pre>  assign stat_mem_w_li = v_tv_r </pre>
<pre>    ? ~(load_miss_tv | store_miss_tv | lr_miss_tv)</pre>
<pre>    : lce_stat_mem_pkt_yumi & (lce_stat_mem_pkt.opcode != e_dcache_lce_stat_mem_read);</pre>
<pre>  assign stat_mem_addr_li = v_tv_r</pre>
<pre>    ? addr_index_tv</pre>
<pre>    : lce_stat_mem_pkt.index;</pre>
<pre></pre>
<pre>  logic [lce_assoc_p-2:0] lru_decode_data_lo;</pre>
<pre>  logic [lce_assoc_p-2:0] lru_decode_mask_lo;</pre>
<pre></pre>
<pre>    .ways_p(lce_assoc_p)</pre>
<pre>  ) lru_decode (</pre>
<pre style="background-color: #FF0000;">    .way_id_i(lru_decode_way_li)</pre>
<pre>    ,.data_o(lru_decode_data_lo)</pre>
<pre>    ,.mask_o(lru_decode_mask_lo)</pre>
<pre>  );</pre>
<pre>  logic dirty_mask_v_li;</pre>
<pre>  logic [lce_assoc_p-1:0] dirty_mask_lo;</pre>
<pre></pre>
<pre>    #(.num_out_p(lce_assoc_p))</pre>
<pre>    dirty_mask_decode</pre>
<pre style="background-color: #FF0000;">      (.i(dirty_mask_way_li)</pre>
<pre>      ,.v_i(dirty_mask_v_li)</pre>
<pre>      ,.o(dirty_mask_lo)</pre>
<pre>      );</pre>
<pre>    if (v_tv_r) begin</pre>
<pre>      lru_decode_way_li = store_op_tv_r ? store_hit_way : load_hit_way;</pre>
<pre>      dirty_mask_way_li = store_hit_way;</pre>
<pre>      dirty_mask_v_li = store_op_tv_r;</pre>
<pre>      </pre>
<pre>      stat_mem_data_li.dirty = {lce_assoc_p{1'b1}};</pre>
<pre>      stat_mem_mask_li = {lru_decode_mask_lo, dirty_mask_lo};</pre>
<pre>    end</pre>
<pre>      lru_decode_way_li = lce_stat_mem_pkt.way_id;</pre>
<pre>      dirty_mask_way_li = lce_stat_mem_pkt.way_id;</pre>
<pre>      dirty_mask_v_li = 1'b1;</pre>
<pre>      case (lce_stat_mem_pkt.opcode)</pre>
<pre>        e_dcache_lce_stat_mem_set_clear: begin</pre>
<pre>          stat_mem_data_li = {(stat_info_width_lp){1'b0}};</pre>
<pre>          stat_mem_mask_li = {(stat_info_width_lp){1'b1}};</pre>
<pre>        end</pre>
<pre>          stat_mem_data_li = {(stat_info_width_lp){1'b0}};</pre>
<pre>          stat_mem_mask_li.lru = {(lce_assoc_p-1){1'b0}};</pre>
<pre>          stat_mem_mask_li.dirty = dirty_mask_lo;</pre>
<pre>        end</pre>
<pre>          stat_mem_data_li = {(stat_info_width_lp){1'b0}};</pre>
<pre>          stat_mem_mask_li = {(stat_info_width_lp){1'b0}};</pre>
<pre>        end</pre>
<pre>  assign wbuf_yumi_li = wbuf_v_lo & ~(load_op & tl_we);</pre>
<pre>  assign bypass_v_li = tv_we & load_op_tl_r;</pre>
<pre>  assign lce_snoop_index_li = lce_data_mem_pkt.index;</pre>
<pre>  assign lce_snoop_way_li = lce_data_mem_pkt.way_id;</pre>
<pre></pre>
<pre></pre>
<pre>    if (lce_data_mem_pkt_yumi & (lce_data_mem_pkt.opcode == e_dcache_lce_data_mem_read)) begin</pre>
<pre>      lce_data_mem_pkt_way_r <= lce_data_mem_pkt.way_id;</pre>
<pre>    end</pre>
<pre>    .width_p(dword_width_p)</pre>
<pre>    ,.els_p(lce_assoc_p)</pre>
<pre>  ) read_mux_butterfly (</pre>
<pre style="background-color: #FF0000;">    .data_i(data_mem_data_lo)</pre>
<pre>    ,.sel_i(lce_data_mem_pkt_way_r)</pre>
<pre>    ,.data_o(lce_data_mem_data_li)</pre>
<pre>  );</pre>
<pre>    ? lce_data_mem_pkt_v</pre>
<pre>    : ~(load_op & tl_we) & ~wbuf_v_lo & ~lce_snoop_match_lo & lce_data_mem_pkt_v;</pre>
<pre></pre>
<pre>    if (reset_i) begin</pre>
<pre>      load_reserved_v_r <= 1'b0;</pre>
<pre>    end</pre>
<pre>      // The LR has successfully completed, without a cache miss or upgrade request</pre>
<pre>        load_reserved_v_r     <= 1'b1;</pre>
<pre>        load_reserved_tag_r   <= paddr_tv_r[block_offset_width_lp+index_width_lp+:tag_width_lp];</pre>
<pre>        load_reserved_index_r <= paddr_tv_r[block_offset_width_lp+:index_width_lp];</pre>
<pre>      // All SCs clear the reservation (regardless of success)</pre>
<pre>        load_reserved_v_r <= 1'b0;</pre>
<pre>      // Invalidates from other harts which match the reservation address clear the reservation</pre>
<pre>                  & (lce_tag_mem_pkt.tag == load_reserved_tag_r) </pre>
<pre>                  & (lce_tag_mem_pkt.index == load_reserved_index_r)) begin</pre>
<pre>        load_reserved_v_r <= 1'b0;</pre>
<pre>      end</pre>
<pre>    if (reset_i) begin</pre>
<pre>      uncached_load_data_v_r <= 1'b0;</pre>
<pre>    end</pre>
<pre>      if (lce_data_mem_pkt_yumi & (lce_data_mem_pkt.opcode == e_dcache_lce_data_mem_uncached)) begin</pre>
<pre>        uncached_load_data_r <= lce_data_mem_pkt.data[0+:dword_width_p];</pre>
<pre>        uncached_load_data_v_r <= 1'b1;</pre>
<pre>      end</pre>
<pre>        // once uncached load request is replayed, and v_o goes high,</pre>
<pre>          uncached_load_data_v_r <= 1'b0;</pre>
<pre>        end</pre>
<pre>  </pre>
<pre></pre>
<pre style="background-color: #FF0000;">    bp_be_dcache_axe_trace_gen</pre>
<pre style="background-color: #FF0000;">      #(.addr_width_p(paddr_width_p)</pre>
<pre style="background-color: #FF0000;">        ,.data_width_p(dword_width_p)</pre>
<pre style="background-color: #FF0000;">        ,.num_lce_p(num_lce_p)</pre>
<pre style="background-color: #FF0000;">        )</pre>
<pre style="background-color: #FF0000;">        (.clk_i(clk_i)</pre>
<pre style="background-color: #FF0000;">        ,.id_i(lce_id_i)</pre>
<pre style="background-color: #FF0000;">        ,.v_i(v_o)</pre>
<pre style="background-color: #FF0000;">        ,.addr_i(paddr_tv_r)</pre>
<pre style="background-color: #FF0000;">        ,.load_data_i(data_o)</pre>
<pre style="background-color: #FF0000;">        ,.store_data_i(data_tv_r)</pre>
<pre style="background-color: #FF0000;">        ,.load_i(load_op_tv_r)</pre>
<pre style="background-color: #FF0000;">        ,.store_i(store_op_tv_r)</pre>
<pre style="background-color: #FF0000;">        );</pre>
<pre>    if (v_tv_r) begin</pre>
<pre>      assert($countones(load_hit_tv) <= 1)</pre>
<pre>        else $error("multiple load hit: %b. id = %0d", load_hit_tv, lce_id_i);</pre>
<pre>      assert($countones(store_hit_tv) <= 1)</pre>
<pre>        else $error("multiple store hit: %b. id = %0d", store_hit_tv, lce_id_i);</pre>
<pre>      assert (~(sc_op_tv_r & load_reserved_v_r & (load_reserved_tag_r == addr_tag_tv) & (load_reserved_index_r == addr_index_tv)) | store_hit)</pre>
<pre>          else $error("sc success without exclusive ownership of cache line: %x %x", load_reserved_tag_r, load_reserved_index_r);</pre>
<pre>    end</pre>
<pre>    assert(dword_width_p == 64) else $error("dword_width_p has to be 64");</pre>
<pre>    assert(lce_assoc_p == 8) else $error("lce_assoc_p has to be 8");</pre>
<pre>  end</pre>
<h3>./bp_be/src/v/bp_be_checker/bp_be_director.v</h3>
<pre> *   bp_be_director.v</pre>
<pre style="background-color: #FF0000;"> * </pre>
<pre> * Description:</pre>
<pre> *   Directs the PC for the FE and the calculator. Keeps track of the next PC</pre>
<pre> *     and sends redirect signals to the FE when a misprediction is detected.</pre>
<pre style="background-color: #FF0000;"> *</pre>
<pre style="background-color: #FF0000;"> * Notes:</pre>
<pre style="background-color: #FF0000;"> *   We don't need the entirety of the calc_status structure here, but for simplicity </pre>
<pre style="background-color: #FF0000;"> *     we pass it all. If the compiler doesn't flatten and optimize, we can do it ourselves.</pre>
<pre style="background-color: #FF0000;"> *   Branch_metadata should come from the target instruction, not the branch instruction,</pre>
<pre style="background-color: #FF0000;"> *     eliminating the need to store this in the BE</pre>
<pre style="background-color: #FF0000;"> *   We don't currently support MTVAL or EPC, so error muxes are disconnected</pre>
<pre> *   FE cmd adapter could be split into a separate module</pre>
<pre style="background-color: #FF0000;"> */</pre>
<pre></pre>
<pre>module bp_be_director </pre>
<pre> import bp_common_pkg::*;</pre>
<pre> import bp_common_aviary_pkg::*;</pre>
<pre> import bp_common_rv64_pkg::*;</pre>
<pre> import bp_be_pkg::*;</pre>
<pre> import bp_cfg_link_pkg::*;</pre>
<pre> #(parameter bp_cfg_e cfg_p = e_bp_inv_cfg</pre>
<pre>   `declare_bp_proc_params(cfg_p)</pre>
<pre>   `declare_bp_fe_be_if_widths(vaddr_width_p, paddr_width_p, asid_width_p, branch_metadata_fwd_width_p)</pre>
<pre></pre>
<pre>   // Generated parameters</pre>
<pre style="background-color: #FF0000;">   , localparam calc_status_width_lp = `bp_be_calc_status_width(vaddr_width_p, branch_metadata_fwd_width_p)</pre>
<pre>   , localparam tlb_entry_width_lp   = `bp_pte_entry_leaf_width(paddr_width_p)</pre>
<pre>   )</pre>
<pre style="background-color: #FF0000;">  (input                              clk_i</pre>
<pre>   , input                            reset_i</pre>
<pre>   , input                            freeze_i</pre>
<pre></pre>
<pre>   // Config channel</pre>
<pre style="background-color: #FF0000;">   , input                            cfg_w_v_i</pre>
<pre>   , input [cfg_addr_width_p-1:0]     cfg_addr_i</pre>
<pre>   , input [cfg_data_width_p-1:0]     cfg_data_i</pre>
<pre></pre>
<pre style="background-color: #FF0000;">   // Dependency information</pre>
<pre>   , input [calc_status_width_lp-1:0] calc_status_i</pre>
<pre>   , output [vaddr_width_p-1:0]       expected_npc_o</pre>
<pre>   , output                           flush_o</pre>
<pre></pre>
<pre>   // FE-BE interface</pre>
<pre style="background-color: #FF0000;">   , output [fe_cmd_width_lp-1:0]     fe_cmd_o</pre>
<pre>   , output                           fe_cmd_v_o</pre>
<pre>   , input                            fe_cmd_ready_i</pre>
<pre></pre>
<pre>   // CSR interface</pre>
<pre>   , input                            trap_v_i</pre>
<pre>   , input                            ret_v_i</pre>
<pre>   , output [vaddr_width_p-1:0]       pc_o </pre>
<pre>   , input [vaddr_width_p-1:0]        tvec_i</pre>
<pre>   , input [vaddr_width_p-1:0]        epc_i</pre>
<pre>   , input                            tlb_fence_i</pre>
<pre>   </pre>
<pre>   //iTLB fill interface</pre>
<pre>   , input                            itlb_fill_v_i</pre>
<pre>   , input [vaddr_width_p-1:0]        itlb_fill_vaddr_i</pre>
<pre>   , input [tlb_entry_width_lp-1:0]   itlb_fill_entry_i</pre>
<pre>  );</pre>
<pre></pre>
<pre>// Declare parameterized structures</pre>
<pre>`declare_bp_fe_be_if(vaddr_width_p, paddr_width_p, asid_width_p, branch_metadata_fwd_width_p);</pre>
<pre>`declare_bp_be_internal_if_structs(vaddr_width_p, paddr_width_p, asid_width_p, branch_metadata_fwd_width_p); </pre>
<pre></pre>
<pre>// Cast input and output ports </pre>
<pre>bp_be_calc_status_s              calc_status;</pre>
<pre>bp_fe_cmd_s                      fe_cmd;</pre>
<pre>logic                            fe_cmd_v;</pre>
<pre>bp_fe_cmd_pc_redirect_operands_s fe_cmd_pc_redirect_operands;</pre>
<pre>bp_mtvec_s                       tvec;</pre>
<pre></pre>
<pre>assign fe_cmd_o    = fe_cmd;</pre>
<pre>assign fe_cmd_v_o  = fe_cmd_v;</pre>
<pre>assign tvec        = tvec_i;</pre>
<pre></pre>
<pre>// Declare intermediate signals</pre>
<pre>logic [vaddr_width_p-1:0]               npc_plus4;</pre>
<pre>logic [vaddr_width_p-1:0]               npc_n, npc_r, pc_r;</pre>
<pre>logic                                   npc_mismatch_v;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">// Logic for handling coming out of reset</pre>
<pre>enum bit [1:0] {e_reset, e_boot, e_run} state_n, state_r;</pre>
<pre></pre>
<pre>// Control signals</pre>
<pre>logic npc_w_v, btaken_v, attaboy_pending;</pre>
<pre></pre>
<pre>logic [vaddr_width_p-1:0] br_mux_o, roll_mux_o, ret_mux_o, exc_mux_o;</pre>
<pre></pre>
<pre>wire cfg_pc_lo_w_v = cfg_w_v_i & (cfg_addr_i == bp_cfg_reg_start_pc_lo_gp);</pre>
<pre>wire cfg_pc_hi_w_v = cfg_w_v_i & (cfg_addr_i == bp_cfg_reg_start_pc_hi_gp);</pre>
<pre>wire [vaddr_width_p-1:0] cfg_pc_part_li = </pre>
<pre>  cfg_pc_hi_w_v</pre>
<pre>  ? {cfg_data_i[0+:vaddr_width_p-cfg_data_width_p], npc_r[0+:cfg_data_width_p]}</pre>
<pre>  : {npc_r[vaddr_width_p-1:cfg_data_width_p], cfg_data_i[0+:cfg_data_width_p]};</pre>
<pre></pre>
<pre>// Module instantiations</pre>
<pre>// Update the NPC on a valid instruction in ex1 or a cache miss or a tlb miss</pre>
<pre>assign npc_w_v = (cfg_pc_lo_w_v | cfg_pc_hi_w_v)</pre>
<pre>                 |(calc_status.ex1_instr_v & ~npc_mismatch_v) </pre>
<pre>                 | calc_status.mem3_miss_v</pre>
<pre>                 | trap_v_i</pre>
<pre>                 | ret_v_i;</pre>
<pre>bsg_dff_en </pre>
<pre> #(.width_p(vaddr_width_p)</pre>
<pre>   ) </pre>
<pre> npc</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.en_i(npc_w_v)</pre>
<pre>  </pre>
<pre style="background-color: #FF0000;">   ,.data_i(npc_n)</pre>
<pre>   ,.data_o(npc_r)</pre>
<pre>   );</pre>
<pre></pre>
<pre>bsg_dff_reset_en</pre>
<pre> #(.width_p(vaddr_width_p))</pre>
<pre> pc</pre>
<pre>  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre>   ,.en_i(npc_w_v)</pre>
<pre></pre>
<pre>   ,.data_i(npc_r)</pre>
<pre>   ,.data_o(pc_r)</pre>
<pre>   );</pre>
<pre>// NPC calculation</pre>
<pre>bsg_mux </pre>
<pre> #(.width_p(vaddr_width_p)</pre>
<pre>   ,.els_p(2)   </pre>
<pre>   )</pre>
<pre> init_mux</pre>
<pre>  (.data_i({cfg_pc_part_li, exc_mux_o})</pre>
<pre>   ,.sel_i(cfg_w_v_i)</pre>
<pre>   ,.data_o(npc_n)</pre>
<pre>   );</pre>
<pre></pre>
<pre>bsg_mux </pre>
<pre> #(.width_p(vaddr_width_p)</pre>
<pre>   ,.els_p(2)   </pre>
<pre>   )</pre>
<pre> exception_mux</pre>
<pre>  (.data_i({ret_mux_o, roll_mux_o})</pre>
<pre>   ,.sel_i(trap_v_i | ret_v_i)</pre>
<pre>   ,.data_o(exc_mux_o)</pre>
<pre>   );</pre>
<pre></pre>
<pre>bsg_mux </pre>
<pre> #(.width_p(vaddr_width_p)</pre>
<pre>   ,.els_p(2)</pre>
<pre>   )</pre>
<pre> roll_mux</pre>
<pre>  (.data_i({calc_status.mem3_pc, br_mux_o})</pre>
<pre>   ,.sel_i(calc_status.mem3_miss_v)</pre>
<pre>   ,.data_o(roll_mux_o)</pre>
<pre>   );</pre>
<pre>assign npc_plus4 = npc_r + vaddr_width_p'(4);</pre>
<pre>assign btaken_v  = calc_status.int1_v & calc_status.int1_btaken;</pre>
<pre>bsg_mux </pre>
<pre> #(.width_p(vaddr_width_p)</pre>
<pre>   ,.els_p(2)</pre>
<pre>   )</pre>
<pre> br_mux</pre>
<pre>  (.data_i({calc_status.int1_br_tgt, npc_plus4})</pre>
<pre>   ,.sel_i(btaken_v)</pre>
<pre>   ,.data_o(br_mux_o)</pre>
<pre>   );</pre>
<pre> #(.width_p(vaddr_width_p)</pre>
<pre>   ,.els_p(2)</pre>
<pre>   )</pre>
<pre style="background-color: #FF0000;">  (.data_i({epc_i[0+:vaddr_width_p], {tvec.base[0+:vaddr_width_p-2], 2'b00}})</pre>
<pre>   ,.sel_i(ret_v_i)</pre>
<pre>   ,.data_o(ret_mux_o)</pre>
<pre>   );</pre>
<pre></pre>
<pre> #(.width_p(1))</pre>
<pre> attaboy_pending_reg</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre>   ,.en_i(calc_status.ex1_v)</pre>
<pre></pre>
<pre>   ,.data_o(attaboy_pending)</pre>
<pre>   );</pre>
<pre>// The current PC, used for interrupts</pre>
<pre></pre>
<pre>  begin</pre>
<pre>    unique casez (state_r)</pre>
<pre>      e_reset : state_n = freeze_i ? e_reset : e_boot;</pre>
<pre>      e_boot  : state_n = fe_cmd_v ? e_run : e_boot;</pre>
<pre>      e_run   : state_n = e_run;</pre>
<pre>      default : state_n = e_reset;</pre>
<pre>    endcase</pre>
<pre>  if (reset_i)</pre>
<pre>      state_r <= e_reset;</pre>
<pre>  else</pre>
<pre>      state_r <= state_n;</pre>
<pre>    end</pre>
<pre></pre>
<pre>  begin : fe_cmd_adapter</pre>
<pre>    fe_cmd = 'b0;</pre>
<pre>    fe_cmd_v = 1'b0;</pre>
<pre></pre>
<pre>      begin</pre>
<pre>        fe_cmd.opcode = e_op_state_reset;</pre>
<pre>        fe_cmd.vaddr  = npc_r;</pre>
<pre></pre>
<pre>      end</pre>
<pre>      begin</pre>
<pre>        fe_cmd.opcode                                     = e_op_itlb_fill_response;</pre>
<pre>        fe_cmd.vaddr                                      = itlb_fill_vaddr_i;</pre>
<pre>        fe_cmd.operands.itlb_fill_response.pte_entry_leaf = itlb_fill_entry_i;</pre>
<pre>      </pre>
<pre>      end</pre>
<pre>      begin</pre>
<pre>        fe_cmd.opcode = e_op_itlb_fence;</pre>
<pre>        fe_cmd.vaddr  = calc_status.mem3_pc;</pre>
<pre>        </pre>
<pre>      end</pre>
<pre>      begin</pre>
<pre>        fe_cmd.opcode = e_op_icache_fence;</pre>
<pre>        fe_cmd.vaddr  = expected_npc_o;</pre>
<pre></pre>
<pre>      end</pre>
<pre>      begin</pre>
<pre>        fe_cmd_pc_redirect_operands = '0;</pre>
<pre></pre>
<pre>        fe_cmd.vaddr                                     = npc_n;</pre>
<pre>        // TODO: Fill in missing subopcodes.  They're not used by FE yet...</pre>
<pre>        fe_cmd_pc_redirect_operands.branch_metadata_fwd  =  calc_status.int1_branch_metadata_fwd;</pre>
<pre>        fe_cmd_pc_redirect_operands.misprediction_reason = e_not_a_branch;</pre>
<pre>        fe_cmd.operands.pc_redirect_operands             = fe_cmd_pc_redirect_operands;</pre>
<pre></pre>
<pre>        fe_cmd_v = fe_cmd_ready_i;</pre>
<pre></pre>
<pre>      begin</pre>
<pre>        fe_cmd_pc_redirect_operands = '0;</pre>
<pre></pre>
<pre>        fe_cmd.vaddr                                     = expected_npc_o;</pre>
<pre>        fe_cmd_pc_redirect_operands.subopcode            = e_subop_branch_mispredict;</pre>
<pre>        fe_cmd_pc_redirect_operands.branch_metadata_fwd  =  calc_status.int1_branch_metadata_fwd;</pre>
<pre>        fe_cmd_pc_redirect_operands.misprediction_reason = calc_status.int1_br_or_jmp </pre>
<pre>                                                           ? e_incorrect_prediction </pre>
<pre>                                                           : e_not_a_branch;</pre>
<pre>        fe_cmd.operands.pc_redirect_operands             = fe_cmd_pc_redirect_operands;</pre>
<pre></pre>
<pre>      end </pre>
<pre>      begin</pre>
<pre>        fe_cmd.opcode                      = e_op_attaboy;</pre>
<pre>        fe_cmd.vaddr                       = calc_status.ex1_pc;</pre>
<pre>        fe_cmd.operands.attaboy            = '{branch_metadata_fwd: calc_status.int1_branch_metadata_fwd</pre>
<pre>                                               ,default: '0</pre>
<pre>                                               };</pre>
<pre>      end</pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./bp_be/src/v/bp_be_checker/bp_be_scheduler.v</h3>
<pre> *   bp_be_scheduler.v</pre>
<pre style="background-color: #FF0000;"> * </pre>
<pre style="background-color: #FF0000;"> * Description:</pre>
<pre style="background-color: #FF0000;"> *   Schedules instruction issue from the FE queue to the Calculator.</pre>
<pre style="background-color: #FF0000;"> *</pre>
<pre style="background-color: #FF0000;"> * Notes:</pre>
<pre style="background-color: #FF0000;"> *   It might make sense to use an enum for RISC-V opcodes rather than `defines.</pre>
<pre style="background-color: #FF0000;"> *   Floating point instruction decoding is not implemented, so we do not predecode.</pre>
<pre style="background-color: #FF0000;"> */</pre>
<pre style="background-color: #FF0000;"></pre>
<pre>module bp_be_scheduler</pre>
<pre style="background-color: #FF0000;"> import bp_common_pkg::*;</pre>
<pre> import bp_common_aviary_pkg::*;</pre>
<pre style="background-color: #FF0000;"> import bp_common_rv64_pkg::*;</pre>
<pre> import bp_be_pkg::*;</pre>
<pre> #(parameter bp_cfg_e cfg_p = e_bp_inv_cfg</pre>
<pre>   `declare_bp_proc_params(cfg_p)</pre>
<pre></pre>
<pre>   // Generated parameters</pre>
<pre>   , localparam fe_queue_width_lp  = `bp_fe_queue_width(vaddr_width_p, branch_metadata_fwd_width_p)</pre>
<pre>   , localparam issue_pkt_width_lp = `bp_be_issue_pkt_width(vaddr_width_p, branch_metadata_fwd_width_p)</pre>
<pre>   )</pre>
<pre>  (input                             clk_i</pre>
<pre>   , input                           reset_i</pre>
<pre></pre>
<pre>   , input                           cache_miss_v_i</pre>
<pre>   , input                           cmt_v_i</pre>
<pre></pre>
<pre>   // Fetch interface</pre>
<pre style="background-color: #FF0000;">   , output                          fe_queue_roll_o</pre>
<pre>   , output                          fe_queue_deq_o</pre>
<pre></pre>
<pre>   , input [fe_queue_width_lp-1:0]   fe_queue_i</pre>
<pre>   , input                           fe_queue_v_i</pre>
<pre>   , output                          fe_queue_yumi_o</pre>
<pre></pre>
<pre>   // Issue interface</pre>
<pre>   , output [issue_pkt_width_lp-1:0] issue_pkt_o</pre>
<pre>   , output                          issue_pkt_v_o</pre>
<pre>   , input                           issue_pkt_ready_i</pre>
<pre>   );</pre>
<pre></pre>
<pre>wire unused = &{clk_i, reset_i};</pre>
<pre></pre>
<pre>`declare_bp_fe_be_if(vaddr_width_p, paddr_width_p, asid_width_p, branch_metadata_fwd_width_p);</pre>
<pre>`declare_bp_be_internal_if_structs(vaddr_width_p, paddr_width_p, asid_width_p, branch_metadata_fwd_width_p);</pre>
<pre></pre>
<pre>// Cast input and output ports </pre>
<pre>bp_fe_queue_s     fe_queue_cast_i;</pre>
<pre>bp_be_issue_pkt_s issue_pkt_cast_o;</pre>
<pre>rv64_instr_s      fetch_instr;</pre>
<pre></pre>
<pre>assign fe_queue_cast_i = fe_queue_i;</pre>
<pre>assign issue_pkt_o     = issue_pkt_cast_o;</pre>
<pre>assign fetch_instr     = fe_queue_cast_i.msg.fetch.instr;</pre>
<pre></pre>
<pre>always_comb</pre>
<pre>  case (fe_queue_cast_i.msg_type)</pre>
<pre>    // Populate the issue packet with a valid pc/instruction pair.</pre>
<pre>      begin</pre>
<pre>        issue_pkt_cast_o = '0;</pre>
<pre></pre>
<pre>        issue_pkt_cast_o.fe_exception_not_instr = 1'b0;</pre>
<pre>        issue_pkt_cast_o.pc                     = fe_queue_cast_i.msg.fetch.pc;</pre>
<pre>        issue_pkt_cast_o.branch_metadata_fwd    = fe_queue_cast_i.msg.fetch.branch_metadata_fwd;</pre>
<pre>        issue_pkt_cast_o.instr                  = fe_queue_cast_i.msg.fetch.instr;</pre>
<pre></pre>
<pre>        // Decide whether to read from integer regfile (saves power)</pre>
<pre>        casez (fetch_instr.opcode)</pre>
<pre>          `RV64_JALR_OP, `RV64_LOAD_OP, `RV64_OP_IMM_OP, `RV64_OP_IMM_32_OP, `RV64_SYSTEM_OP :</pre>
<pre>            begin </pre>
<pre>              issue_pkt_cast_o.irs1_v = '1; </pre>
<pre>              issue_pkt_cast_o.irs2_v = '0;</pre>
<pre>            end</pre>
<pre>            begin </pre>
<pre>              issue_pkt_cast_o.irs1_v = '1; </pre>
<pre>              issue_pkt_cast_o.irs2_v = '1; </pre>
<pre>            end</pre>
<pre>        // Decide whether to read from floating point regfile (saves power)</pre>
<pre style="background-color: #FF0000;">        issue_pkt_cast_o.frs1_v = '0;</pre>
<pre>        issue_pkt_cast_o.frs2_v = '0;</pre>
<pre></pre>
<pre>        // Pre-decode</pre>
<pre>        issue_pkt_cast_o.fence_v = (fetch_instr.opcode == `RV64_MISC_MEM_OP);</pre>
<pre>        </pre>
<pre>        // Immediate extraction</pre>
<pre>        unique casez (fetch_instr.opcode)</pre>
<pre>          `RV64_LUI_OP, `RV64_AUIPC_OP: </pre>
<pre>            issue_pkt_cast_o.imm = `rv64_signext_u_imm(fetch_instr);</pre>
<pre>          `RV64_JAL_OP: </pre>
<pre>            issue_pkt_cast_o.imm = `rv64_signext_j_imm(fetch_instr);</pre>
<pre>          `RV64_BRANCH_OP: </pre>
<pre>            issue_pkt_cast_o.imm = `rv64_signext_b_imm(fetch_instr);</pre>
<pre>          `RV64_STORE_OP: </pre>
<pre>            issue_pkt_cast_o.imm = `rv64_signext_s_imm(fetch_instr);</pre>
<pre>          `RV64_JALR_OP, `RV64_LOAD_OP, `RV64_OP_IMM_OP, `RV64_OP_IMM_32_OP: </pre>
<pre>            issue_pkt_cast_o.imm = `rv64_signext_i_imm(fetch_instr);</pre>
<pre>          `RV64_SYSTEM_OP:</pre>
<pre>            issue_pkt_cast_o.imm = `rv64_signext_c_imm(fetch_instr);</pre>
<pre>          default: begin end</pre>
<pre>    e_fe_exception: </pre>
<pre>      begin</pre>
<pre>        issue_pkt_cast_o = '0;</pre>
<pre></pre>
<pre>        issue_pkt_cast_o.fe_exception_not_instr = 1'b1;</pre>
<pre>        issue_pkt_cast_o.fe_exception_code      = fe_queue_cast_i.msg.exception.exception_code;</pre>
<pre>        issue_pkt_cast_o.pc                     = fe_queue_cast_i.msg.exception.vaddr;</pre>
<pre>      end</pre>
<pre>// Interface handshakes</pre>
<pre>assign fe_queue_yumi_o = fe_queue_v_i & issue_pkt_ready_i;</pre>
<pre>assign issue_pkt_v_o   = fe_queue_yumi_o;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">// Queue control signals</pre>
<pre>assign fe_queue_deq_o  = ~cache_miss_v_i & cmt_v_i;</pre>
<pre></pre>
<pre>endmodule</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./bp_be/src/v/bp_be_mem/bp_be_ptw.v</h3>
<pre>module bp_be_ptw</pre>
<pre>  import bp_common_rv64_pkg::*;</pre>
<pre style="background-color: #FF0000;">  import bp_common_aviary_pkg::*;</pre>
<pre style="background-color: #FF0000;">  import bp_be_pkg::*;</pre>
<pre>  import bp_be_dcache_pkg::*;</pre>
<pre>  #(parameter bp_cfg_e cfg_p = e_bp_inv_cfg</pre>
<pre>    `declare_bp_proc_params(cfg_p)</pre>
<pre style="background-color: #FF0000;">    `declare_bp_fe_be_if_widths(vaddr_width_p, paddr_width_p, asid_width_p, branch_metadata_fwd_width_p)</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">    ,parameter pte_width_p              = bp_sv39_pte_width_gp</pre>
<pre>    ,parameter page_table_depth_p       = bp_sv39_page_table_depth_gp</pre>
<pre>    </pre>
<pre>    ,localparam vpn_width_lp            = vaddr_width_p - page_offset_width_p</pre>
<pre>    ,localparam ppn_width_lp            = paddr_width_p - page_offset_width_p</pre>
<pre>    ,localparam dcache_pkt_width_lp     = `bp_be_dcache_pkt_width(page_offset_width_p, pte_width_p)    </pre>
<pre>    ,localparam tlb_entry_width_lp      = `bp_pte_entry_leaf_width(paddr_width_p)</pre>
<pre>    ,localparam lg_page_table_depth_lp  = `BSG_SAFE_CLOG2(page_table_depth_p)</pre>
<pre></pre>
<pre style="background-color: #FF0000;">    ,localparam pte_size_in_bytes_lp    = pte_width_p/rv64_byte_width_gp</pre>
<pre>    ,localparam lg_pte_size_in_bytes_lp = `BSG_SAFE_CLOG2(pte_size_in_bytes_lp)</pre>
<pre>    ,localparam partial_vpn_width_lp    = page_offset_width_p - lg_pte_size_in_bytes_lp</pre>
<pre>  )</pre>
<pre style="background-color: #FF0000;">  (input                                    clk_i</pre>
<pre>   , input                                  reset_i</pre>
<pre>   , input [ppn_width_lp-1:0]               base_ppn_i</pre>
<pre>   , input                                  translation_en_i</pre>
<pre>   , output                                 busy_o</pre>
<pre>   </pre>
<pre style="background-color: #FF0000;">   , input                                  itlb_not_dtlb_i</pre>
<pre>   , output logic                           itlb_not_dtlb_o</pre>
<pre>   </pre>
<pre style="background-color: #FF0000;">   , input                                  store_not_load_i</pre>
<pre>   </pre>
<pre style="background-color: #FF0000;">   , output logic                           instr_page_fault_o</pre>
<pre>   , output logic                           load_page_fault_o</pre>
<pre>   , output logic                           store_page_fault_o</pre>
<pre>   </pre>
<pre style="background-color: #FF0000;">   // TLB connections</pre>
<pre style="background-color: #FF0000;">   , input                                  tlb_miss_v_i</pre>
<pre>   , input [vpn_width_lp-1:0]               tlb_miss_vtag_i</pre>
<pre>   </pre>
<pre>   , output logic [vpn_width_lp-1:0]        tlb_w_vtag_o</pre>
<pre>   , output logic [tlb_entry_width_lp-1:0]  tlb_w_entry_o</pre>
<pre></pre>
<pre style="background-color: #FF0000;">   // D-Cache connections</pre>
<pre>   , input [pte_width_p-1:0]                dcache_data_i</pre>
<pre>   </pre>
<pre style="background-color: #FF0000;">   , output logic                           dcache_v_o</pre>
<pre>   , output logic [dcache_pkt_width_lp-1:0] dcache_pkt_o</pre>
<pre>   , output logic [ppn_width_lp-1:0]        dcache_ptag_o</pre>
<pre>   , input                                  dcache_rdy_i</pre>
<pre>   , input                                  dcache_miss_i</pre>
<pre>  );</pre>
<pre style="background-color: #FF0000;">  </pre>
<pre style="background-color: #FF0000;">  `declare_bp_fe_be_if(vaddr_width_p, paddr_width_p, asid_width_p, branch_metadata_fwd_width_p);</pre>
<pre style="background-color: #FF0000;">  `declare_bp_be_dcache_pkt_s(page_offset_width_p, pte_width_p);</pre>
<pre>  </pre>
<pre style="background-color: #FF0000;">  typedef enum bit [2:0] { eIdle, eSendLoad, eWaitLoad, eWriteBack, eStuck } state_e;</pre>
<pre>  </pre>
<pre style="background-color: #FF0000;">  bp_be_dcache_pkt_s  dcache_pkt;</pre>
<pre>  bp_sv39_pte_s       dcache_data;</pre>
<pre>  bp_pte_entry_leaf_s tlb_w_entry;</pre>
<pre>  </pre>
<pre style="background-color: #FF0000;">  state_e state_r, state_n;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">  logic pte_is_leaf;</pre>
<pre>  logic start;</pre>
<pre>  logic [lg_page_table_depth_lp-1:0] level_cntr;</pre>
<pre>  logic                              level_cntr_en;</pre>
<pre>  logic [vpn_width_lp-1:0]           vpn_r, vpn_n;</pre>
<pre>  logic [ppn_width_lp-1:0]           ppn_r, ppn_n, writeback_ppn;</pre>
<pre>  logic                              ppn_en;</pre>
<pre>  </pre>
<pre>  logic [page_table_depth_p-1:0] [partial_vpn_width_lp-1:0] partial_vpn;</pre>
<pre>  logic [page_table_depth_p-2:0] [partial_vpn_width_lp-1:0] partial_ppn;</pre>
<pre>  </pre>
<pre style="background-color: #FF0000;">  logic store_not_load_r;</pre>
<pre>  logic page_fault_v;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">  genvar i;</pre>
<pre style="background-color: #FF0000;">  generate </pre>
<pre style="background-color: #FF0000;">    for(i=0; i<page_table_depth_p; i++) begin</pre>
<pre style="background-color: #FF0000;">      assign partial_vpn[i] = vpn_r[partial_vpn_width_lp*i +: partial_vpn_width_lp];</pre>
<pre>    end</pre>
<pre>      assign partial_ppn[i] = ppn_r[partial_vpn_width_lp*i +: partial_vpn_width_lp];</pre>
<pre style="background-color: #FF0000;">      assign writeback_ppn[partial_vpn_width_lp*i +: partial_vpn_width_lp] = (level_cntr > i)? partial_vpn[i] : partial_ppn[i];</pre>
<pre>    end</pre>
<pre>  endgenerate</pre>
<pre>  assign dcache_pkt_o           = dcache_pkt;</pre>
<pre>  assign dcache_ptag_o          = ppn_r;</pre>
<pre>  assign dcache_data            = dcache_data_i;</pre>
<pre>  </pre>
<pre>  assign tlb_w_v_o              = (state_r == eWriteBack);</pre>
<pre>  assign tlb_w_vtag_o           = vpn_r;</pre>
<pre>  assign tlb_w_entry_o          = tlb_w_entry;</pre>
<pre>  </pre>
<pre>  assign tlb_w_entry.ptag       = translation_en_i ? writeback_ppn : ppn_width_lp'(vpn_r);</pre>
<pre>  assign tlb_w_entry.g          = translation_en_i ? dcache_data.g : 1'b0;</pre>
<pre>  assign tlb_w_entry.u          = translation_en_i ? dcache_data.u : 1'b0;</pre>
<pre>  assign tlb_w_entry.x          = translation_en_i ? dcache_data.x : 1'b1;</pre>
<pre>  assign tlb_w_entry.w          = translation_en_i ? dcache_data.w : 1'b1;</pre>
<pre>  assign tlb_w_entry.r          = translation_en_i ? dcache_data.r : 1'b1;</pre>
<pre></pre>
<pre>  // PMA attributes</pre>
<pre>  assign tlb_w_entry.uc         = (tlb_w_entry.ptag < (dram_base_addr_gp >> page_offset_width_p));</pre>
<pre></pre>
<pre>  assign dcache_v_o             = (state_r == eSendLoad);</pre>
<pre>  assign dcache_pkt.opcode      = e_dcache_opcode_ld;</pre>
<pre>  assign dcache_pkt.page_offset = {partial_vpn[level_cntr], (lg_pte_size_in_bytes_lp)'(0)};</pre>
<pre>  assign dcache_pkt.data        = '0;</pre>
<pre>    </pre>
<pre>  assign busy_o                 = (state_r != eIdle);</pre>
<pre>    </pre>
<pre>  assign start                  = (state_r == eIdle) & tlb_miss_v_i;</pre>
<pre>  </pre>
<pre>  assign pte_is_leaf            = dcache_data.x | dcache_data.w | dcache_data.r;</pre>
<pre>  </pre>
<pre>  assign level_cntr_en          = busy_o & dcache_v_i & ~pte_is_leaf;</pre>
<pre>  </pre>
<pre>  assign ppn_en                 = start | (busy_o & dcache_v_i);</pre>
<pre>  assign ppn_n                  = (state_r == eIdle)? base_ppn_i : dcache_data.ppn[0+:ppn_width_lp];</pre>
<pre>  assign vpn_n                  = tlb_miss_vtag_i;</pre>
<pre>  </pre>
<pre>  assign instr_page_fault_o     = busy_o & dcache_v_i & itlb_not_dtlb_o & ((level_cntr == '0 & ~dcache_data.v) | (pte_is_leaf & ~dcache_data.x));</pre>
<pre>  assign load_page_fault_o      = busy_o & dcache_v_i & ~itlb_not_dtlb_o & ~store_not_load_r & ((level_cntr == '0 & ~dcache_data.v) | (pte_is_leaf & ~dcache_data.r));</pre>
<pre>  assign store_page_fault_o     = busy_o & dcache_v_i & ~itlb_not_dtlb_o & store_not_load_r & ((level_cntr == '0 & ~dcache_data.v) | (pte_is_leaf & ~dcache_data.w));</pre>
<pre>  assign page_fault_v           = instr_page_fault_o | load_page_fault_o | store_page_fault_o;</pre>
<pre>  </pre>
<pre>  always_comb begin</pre>
<pre>    case(state_r)</pre>
<pre>      eIdle:      state_n = tlb_miss_v_i </pre>
<pre>                             ? (translation_en_i ? eSendLoad : eWriteBack) </pre>
<pre>                             : eIdle;                           </pre>
<pre>      eSendLoad:  state_n = dcache_rdy_i ? eWaitLoad : eSendLoad; </pre>
<pre>      eWaitLoad:  state_n = dcache_miss_i</pre>
<pre>                            ? eSendLoad</pre>
<pre>                            : (dcache_v_i</pre>
<pre>                                ? (page_fault_v</pre>
<pre>                                    ? eIdle</pre>
<pre>                                    : (pte_is_leaf ? eWriteBack : eSendLoad))</pre>
<pre>                                    : eWaitLoad);                                                             </pre>
<pre>      eWriteBack: state_n = eIdle;</pre>
<pre>      default: state_n = eStuck;</pre>
<pre>    endcase</pre>
<pre>  </pre>
<pre>  always_ff @(posedge clk_i) begin</pre>
<pre>    if(reset_i) begin</pre>
<pre>      level_cntr <= '0;</pre>
<pre>    end</pre>
<pre>      level_cntr <= page_table_depth_p - 1;</pre>
<pre>    end</pre>
<pre>      level_cntr <= level_cntr - 'b1;</pre>
<pre>    end</pre>
<pre>  always_ff @(posedge clk_i) begin</pre>
<pre>    if(reset_i) begin</pre>
<pre>      state_r <= eIdle;</pre>
<pre>    end</pre>
<pre>      state_r <= state_n;</pre>
<pre>    end</pre>
<pre>    vpn_reg</pre>
<pre style="background-color: #FF0000;">    (.clk_i(clk_i)</pre>
<pre>     ,.reset_i(reset_i)</pre>
<pre>     ,.en_i(start)</pre>
<pre>     ,.data_i(vpn_n)</pre>
<pre>     ,.data_o(vpn_r)</pre>
<pre>    );</pre>
<pre>    ppn_reg</pre>
<pre style="background-color: #FF0000;">    (.clk_i(clk_i)</pre>
<pre>     ,.reset_i(reset_i)</pre>
<pre>     ,.en_i(ppn_en)</pre>
<pre>     ,.data_i(ppn_n)</pre>
<pre>     ,.data_o(ppn_r)</pre>
<pre>    );</pre>
<pre>    tlb_sel_reg</pre>
<pre style="background-color: #FF0000;">    (.clk_i(clk_i)</pre>
<pre>     ,.reset_i(reset_i)</pre>
<pre>     ,.en_i(start)</pre>
<pre>     ,.data_i(itlb_not_dtlb_i)</pre>
<pre>     ,.data_o(itlb_not_dtlb_o)</pre>
<pre>    );</pre>
<pre>    cmd_sel_reg</pre>
<pre style="background-color: #FF0000;">    (.clk_i(clk_i)</pre>
<pre>     ,.reset_i(reset_i)</pre>
<pre>     ,.en_i(start)</pre>
<pre>     ,.data_i(store_not_load_i)</pre>
<pre>     ,.data_o(store_not_load_r)</pre>
<pre>    );</pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./bp_be/src/v/bp_be_mem/bp_be_dcache/bp_be_dcache_lce_cmd.v</h3>
<pre> *    in the cache. Once LCE has received sync command from all the CCEs, and</pre>
<pre style="background-color: #FF0000;"> *    has responded with ack, it asserts lce_sync_done_o signal to indicate</pre>
<pre style="background-color: #FF0000;"> *    that the cache may begin start accepting load/store instructions from</pre>
<pre>module bp_be_dcache_lce_cmd</pre>
<pre>  #(parameter num_cce_p="inv"</pre>
<pre>    , parameter num_lce_p="inv"</pre>
<pre>    , parameter paddr_width_p="inv"</pre>
<pre>    , parameter lce_data_width_p="inv"</pre>
<pre>    , parameter sets_p="inv"</pre>
<pre>    , parameter ways_p="inv"</pre>
<pre>    , parameter data_width_p="inv"</pre>
<pre>    , localparam block_size_in_words_lp=ways_p</pre>
<pre>    , localparam byte_offset_width_lp=`BSG_SAFE_CLOG2(data_width_p>>3)</pre>
<pre>    , localparam word_offset_width_lp=`BSG_SAFE_CLOG2(block_size_in_words_lp)</pre>
<pre>    , localparam block_offset_width_lp=(word_offset_width_lp+byte_offset_width_lp)</pre>
<pre>    , localparam index_width_lp=`BSG_SAFE_CLOG2(sets_p)</pre>
<pre>    , localparam tag_width_lp=(paddr_width_p-index_width_lp-block_offset_width_lp)</pre>
<pre>    , localparam way_id_width_lp=`BSG_SAFE_CLOG2(ways_p)</pre>
<pre>    , localparam lce_id_width_lp=`BSG_SAFE_CLOG2(num_lce_p)</pre>
<pre>    , localparam cce_id_width_lp=`BSG_SAFE_CLOG2(num_cce_p)</pre>
<pre>    </pre>
<pre>    `declare_bp_lce_cce_if_widths(num_cce_p, num_lce_p, paddr_width_p, ways_p, data_width_p, lce_data_width_p) </pre>
<pre></pre>
<pre>    , localparam dcache_lce_data_mem_pkt_width_lp=</pre>
<pre>      `bp_be_dcache_lce_data_mem_pkt_width(sets_p, ways_p, lce_data_width_p)</pre>
<pre>      `bp_be_dcache_lce_tag_mem_pkt_width(sets_p, ways_p, tag_width_lp)</pre>
<pre>      `bp_be_dcache_lce_stat_mem_pkt_width(sets_p, ways_p)</pre>
<pre>    , input reset_i</pre>
<pre>    , input freeze_i</pre>
<pre></pre>
<pre>    , input [lce_id_width_lp-1:0] lce_id_i</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre>    , output logic set_tag_received_o</pre>
<pre>    , output logic set_tag_wakeup_received_o</pre>
<pre>    , output logic uncached_store_done_received_o</pre>
<pre>    , output logic cce_data_received_o</pre>
<pre>    , output logic uncached_data_received_o</pre>
<pre></pre>
<pre>    , input lce_cmd_v_i</pre>
<pre>    , output logic lce_cmd_ready_o</pre>
<pre></pre>
<pre>    , output logic [lce_cce_resp_width_lp-1:0] lce_resp_o</pre>
<pre>    , output logic lce_resp_v_o</pre>
<pre>    , input lce_resp_yumi_i</pre>
<pre></pre>
<pre>    // LCE_data_cmd_out</pre>
<pre>    , output logic [lce_cmd_width_lp-1:0] lce_cmd_o</pre>
<pre>    , output logic lce_cmd_v_o</pre>
<pre>    , input lce_cmd_ready_i </pre>
<pre></pre>
<pre>    // data_mem</pre>
<pre>    , output logic [dcache_lce_data_mem_pkt_width_lp-1:0] data_mem_pkt_o</pre>
<pre>    , input [lce_data_width_p-1:0] data_mem_data_i</pre>
<pre>    , input data_mem_pkt_yumi_i</pre>
<pre>  </pre>
<pre>    , output logic [dcache_lce_tag_mem_pkt_width_lp-1:0] tag_mem_pkt_o</pre>
<pre>    , input tag_mem_pkt_yumi_i</pre>
<pre>    </pre>
<pre>    , output logic [dcache_lce_stat_mem_pkt_width_lp-1:0] stat_mem_pkt_o</pre>
<pre>    , input [ways_p-1:0] dirty_i</pre>
<pre>    , input stat_mem_pkt_yumi_i</pre>
<pre>  );</pre>
<pre>  `declare_bp_lce_cce_if(num_cce_p, num_lce_p, paddr_width_p, ways_p, data_width_p, lce_data_width_p)</pre>
<pre style="background-color: #FF0000;">  `declare_bp_be_dcache_lce_data_mem_pkt_s(sets_p, ways_p, lce_data_width_p);</pre>
<pre>  `declare_bp_be_dcache_lce_tag_mem_pkt_s(sets_p, ways_p, tag_width_lp);</pre>
<pre style="background-color: #FF0000;">  `declare_bp_be_dcache_lce_stat_mem_pkt_s(sets_p, ways_p);</pre>
<pre></pre>
<pre>  bp_lce_cmd_s lce_cmd_li;</pre>
<pre>  logic lce_cmd_v_li, lce_cmd_yumi_lo;</pre>
<pre>  bp_lce_cce_resp_s lce_resp;</pre>
<pre>  bp_lce_cmd_s lce_cmd_out;</pre>
<pre></pre>
<pre>  assign lce_resp_o = lce_resp;</pre>
<pre>  assign lce_cmd_o = lce_cmd_out;</pre>
<pre></pre>
<pre>  bp_be_dcache_lce_tag_mem_pkt_s tag_mem_pkt;</pre>
<pre>  bp_be_dcache_lce_stat_mem_pkt_s stat_mem_pkt;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">  assign data_mem_pkt_o = data_mem_pkt;</pre>
<pre>  assign tag_mem_pkt_o = tag_mem_pkt;</pre>
<pre>  assign stat_mem_pkt_o = stat_mem_pkt;</pre>
<pre></pre>
<pre>  logic [index_width_lp-1:0] lce_cmd_addr_index;</pre>
<pre>  logic [tag_width_lp-1:0] lce_cmd_addr_tag;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">  assign lce_cmd_addr_index = lce_cmd_li.msg.cmd.addr[block_offset_width_lp+:index_width_lp];</pre>
<pre>  assign lce_cmd_addr_tag = lce_cmd_li.msg.cmd.addr[block_offset_width_lp+index_width_lp+:tag_width_lp];</pre>
<pre></pre>
<pre>  // states</pre>
<pre>  typedef enum logic [2:0] {</pre>
<pre>    e_lce_cmd_state_uncached</pre>
<pre>    ,e_lce_cmd_state_sync</pre>
<pre>    ,e_lce_cmd_state_ready</pre>
<pre>    ,e_lce_cmd_state_tr</pre>
<pre>    ,e_lce_cmd_state_wb</pre>
<pre>    ,e_lce_cmd_state_wb_dirty</pre>
<pre>    ,e_lce_cmd_state_wb_not_dirty</pre>
<pre>  } lce_cmd_state_e;</pre>
<pre></pre>
<pre>  logic [cce_id_width_lp-1:0] sync_ack_count_r, sync_ack_count_n;</pre>
<pre></pre>
<pre>  logic invalidated_tag_r, invalidated_tag_n;</pre>
<pre></pre>
<pre>  // for transfer_cmd</pre>
<pre>  logic tr_data_buffered_r, tr_data_buffered_n;</pre>
<pre></pre>
<pre>  // for writeback_cmd</pre>
<pre>  logic wb_data_buffered_r, wb_data_buffered_n;</pre>
<pre>  logic wb_data_read_r, wb_data_read_n;</pre>
<pre>  logic wb_dirty_cleared_r, wb_dirty_cleared_n;</pre>
<pre></pre>
<pre></pre>
<pre>  //</pre>
<pre>  logic lce_tr_done;</pre>
<pre>  </pre>
<pre>  assign lce_tr_done = lce_cmd_v_o & lce_cmd_ready_i;</pre>
<pre>  assign lce_resp_done = lce_resp_yumi_i;</pre>
<pre></pre>
<pre>                           & (state_r != e_lce_cmd_state_uncached);</pre>
<pre></pre>
<pre>    </pre>
<pre>    sync_ack_count_n = sync_ack_count_r;</pre>
<pre>    tr_data_buffered_n = tr_data_buffered_r;</pre>
<pre></pre>
<pre>    wb_data_read_n = wb_data_read_r;</pre>
<pre>    wb_dirty_cleared_n = wb_dirty_cleared_r;</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre>    set_tag_wakeup_received_o = 1'b0;</pre>
<pre>    uncached_store_done_received_o = 1'b0;</pre>
<pre>    uncached_data_received_o = 1'b0;</pre>
<pre>    cce_data_received_o = 1'b0;</pre>
<pre></pre>
<pre></pre>
<pre>    lce_resp_v_o = 1'b0;</pre>
<pre></pre>
<pre>    lce_cmd_v_o = 1'b0;</pre>
<pre></pre>
<pre>    data_mem_pkt_v_o = 1'b0;</pre>
<pre>    tag_mem_pkt = '0;</pre>
<pre>    tag_mem_pkt_v_o = 1'b0;</pre>
<pre>    stat_mem_pkt = '0;</pre>
<pre>    stat_mem_pkt_v_o = 1'b0;</pre>
<pre>    </pre>
<pre></pre>
<pre>        state_n = (freeze_i)</pre>
<pre>                  ? e_lce_cmd_state_uncached</pre>
<pre>                  : (lce_mode_i == e_dcache_lce_mode_normal)</pre>
<pre>                    ? e_lce_cmd_state_sync</pre>
<pre>                    : e_lce_cmd_state_uncached;</pre>
<pre></pre>
<pre>          unique case (lce_cmd_li.msg_type)</pre>
<pre>            //  <uncached store done></pre>
<pre>              lce_cmd_yumi_lo = lce_cmd_v_li;</pre>
<pre>              uncached_store_done_received_o = lce_cmd_v_li;</pre>
<pre>            end</pre>
<pre>            end</pre>
<pre>        if (lce_cmd_v_li) begin</pre>
<pre>          unique case (lce_cmd_li.msg_type)</pre>
<pre></pre>
<pre>              lce_resp.dst_id = lce_cmd_li.msg.cmd.src_id;</pre>
<pre>              lce_resp.src_id = lce_id_i;</pre>
<pre>              lce_resp.msg_type = e_lce_cce_sync_ack;</pre>
<pre>              lce_resp_v_o = lce_cmd_v_li;</pre>
<pre>              lce_cmd_yumi_lo = lce_resp_yumi_i;</pre>
<pre>              sync_ack_count_n = lce_resp_yumi_i</pre>
<pre>                ? sync_ack_count_r + 1</pre>
<pre>                : sync_ack_count_r;</pre>
<pre>              state_n = ((sync_ack_count_r == cce_id_width_lp'(num_cce_p-1)) & lce_resp_yumi_i)</pre>
<pre>                ? e_lce_cmd_state_ready</pre>
<pre>                : e_lce_cmd_state_sync;</pre>
<pre>            end</pre>
<pre>              tag_mem_pkt.index = lce_cmd_addr_index;</pre>
<pre>              tag_mem_pkt.opcode = e_dcache_lce_tag_mem_set_clear;</pre>
<pre>              tag_mem_pkt_v_o = lce_cmd_v_li;</pre>
<pre></pre>
<pre>              stat_mem_pkt.opcode = e_dcache_lce_stat_mem_set_clear;</pre>
<pre>              stat_mem_pkt_v_o = lce_cmd_v_li;</pre>
<pre></pre>
<pre>            end</pre>
<pre>	       </pre>
<pre>        if (lce_cmd_v_li) begin</pre>
<pre>          unique case (lce_cmd_li.msg_type)</pre>
<pre>            // <transfer packet></pre>
<pre>              data_mem_pkt.index = lce_cmd_addr_index;</pre>
<pre>              data_mem_pkt.way_id = lce_cmd_li.way_id;</pre>
<pre>              data_mem_pkt.opcode = e_dcache_lce_data_mem_read;</pre>
<pre>              data_mem_pkt_v_o = lce_cmd_v_li;</pre>
<pre></pre>
<pre>                ? e_lce_cmd_state_tr</pre>
<pre>                : e_lce_cmd_state_ready;</pre>
<pre>            end</pre>
<pre style="background-color: #FF0000;">            e_lce_cmd_writeback: begin</pre>
<pre>              stat_mem_pkt.index = lce_cmd_addr_index;</pre>
<pre>              stat_mem_pkt.way_id = lce_cmd_li.way_id;</pre>
<pre>              stat_mem_pkt.opcode = e_dcache_lce_stat_mem_read;</pre>
<pre>              stat_mem_pkt_v_o = lce_cmd_v_li;</pre>
<pre></pre>
<pre>                ? e_lce_cmd_state_wb</pre>
<pre>                : e_lce_cmd_state_ready;</pre>
<pre>            end</pre>
<pre style="background-color: #FF0000;">            //  <set tag></pre>
<pre>            //  set the tag and coherency state of given index/way.</pre>
<pre>              tag_mem_pkt.index = lce_cmd_addr_index;</pre>
<pre>              tag_mem_pkt.way_id = lce_cmd_li.way_id;</pre>
<pre>              tag_mem_pkt.state = lce_cmd_li.msg.cmd.state;</pre>
<pre>              tag_mem_pkt.tag = lce_cmd_addr_tag;</pre>
<pre>              tag_mem_pkt.opcode = e_dcache_lce_tag_mem_set_tag;</pre>
<pre>              tag_mem_pkt_v_o = lce_cmd_v_li;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">              lce_cmd_yumi_lo = tag_mem_pkt_yumi_i;</pre>
<pre></pre>
<pre>            end</pre>
<pre>              tag_mem_pkt.index = lce_cmd_addr_index;</pre>
<pre>              tag_mem_pkt.way_id = lce_cmd_li.way_id;</pre>
<pre>              tag_mem_pkt.state = lce_cmd_li.msg.cmd.state;</pre>
<pre>              tag_mem_pkt.tag = lce_cmd_addr_tag;</pre>
<pre>              tag_mem_pkt.opcode = e_dcache_lce_tag_mem_set_tag;</pre>
<pre>              tag_mem_pkt_v_o = lce_cmd_v_li;</pre>
<pre></pre>
<pre></pre>
<pre>            end</pre>
<pre style="background-color: #FF0000;">            //  <invalidate tag></pre>
<pre style="background-color: #FF0000;">            //  invalidate tag. It does not update the LRU. It sends out</pre>
<pre>              tag_mem_pkt.index = lce_cmd_addr_index;</pre>
<pre>              tag_mem_pkt.way_id = lce_cmd_li.way_id;</pre>
<pre>              tag_mem_pkt.opcode = e_dcache_lce_tag_mem_invalidate;</pre>
<pre>              tag_mem_pkt_v_o = invalidated_tag_r</pre>
<pre>                ? 1'b0</pre>
<pre>                : lce_cmd_v_li;</pre>
<pre>              invalidated_tag_n = lce_resp_yumi_i</pre>
<pre>                ? 1'b0</pre>
<pre>                : (invalidated_tag_r</pre>
<pre>                  ? 1'b1</pre>
<pre>                  : tag_mem_pkt_yumi_i);</pre>
<pre></pre>
<pre>              lce_resp.msg_type = e_lce_cce_inv_ack;</pre>
<pre>              lce_resp.src_id = lce_id_i;</pre>
<pre>              lce_resp.addr = lce_cmd_li.msg.cmd.addr;</pre>
<pre>              lce_resp_v_o = invalidated_tag_r | tag_mem_pkt_yumi_i;</pre>
<pre>              lce_cmd_yumi_lo = lce_resp_yumi_i;</pre>
<pre>            end</pre>
<pre>              lce_cmd_yumi_lo = lce_cmd_v_li;</pre>
<pre>              uncached_store_done_received_o = lce_cmd_v_li;</pre>
<pre>            end</pre>
<pre>              data_mem_pkt.index = miss_addr_i[block_offset_width_lp+:index_width_lp];</pre>
<pre>              data_mem_pkt.way_id = lce_cmd_li.way_id;</pre>
<pre>              data_mem_pkt.data = lce_cmd_li.msg.dt_cmd.data;</pre>
<pre>              data_mem_pkt.opcode = e_dcache_lce_data_mem_write;</pre>
<pre>              data_mem_pkt_v_o = lce_cmd_v_li;</pre>
<pre></pre>
<pre>              tag_mem_pkt.way_id = lce_cmd_li.way_id;</pre>
<pre>              tag_mem_pkt.state = lce_cmd_li.msg.dt_cmd.state;</pre>
<pre>              tag_mem_pkt.tag = lce_cmd_li.msg.dt_cmd.addr[block_offset_width_lp+index_width_lp+:tag_width_lp];</pre>
<pre>              tag_mem_pkt.opcode = e_dcache_lce_tag_mem_set_tag;</pre>
<pre>              tag_mem_pkt_v_o = lce_cmd_v_li;</pre>
<pre></pre>
<pre></pre>
<pre>              set_tag_received_o  = tag_mem_pkt_yumi_i & data_mem_pkt_yumi_i;</pre>
<pre></pre>
<pre>              data_mem_pkt.index = miss_addr_i[block_offset_width_lp+:index_width_lp];</pre>
<pre>              data_mem_pkt.way_id = lce_cmd_li.way_id;</pre>
<pre>              data_mem_pkt.data = lce_cmd_li.msg.dt_cmd.data;</pre>
<pre>              data_mem_pkt.opcode = e_dcache_lce_data_mem_uncached;</pre>
<pre>              data_mem_pkt_v_o = lce_cmd_v_li;</pre>
<pre>              lce_cmd_yumi_lo = data_mem_pkt_yumi_i;</pre>
<pre></pre>
<pre>            end</pre>
<pre></pre>
<pre>        data_buf_n = tr_data_buffered_r</pre>
<pre>          ? data_buf_r</pre>
<pre>          : data_mem_data_i;</pre>
<pre>        tr_data_buffered_n = ~lce_tr_done;</pre>
<pre></pre>
<pre>        lce_cmd_out.msg_type = e_lce_cmd_data;</pre>
<pre>        lce_cmd_out.way_id = lce_cmd_li.msg.cmd.target_way_id;</pre>
<pre>        lce_cmd_out.msg.dt_cmd.addr = lce_cmd_li.msg.cmd.addr;</pre>
<pre>        lce_cmd_out.msg.dt_cmd.state = lce_cmd_li.msg.cmd.state;</pre>
<pre>        lce_cmd_out.msg.dt_cmd.data = tr_data_buffered_r</pre>
<pre>          ? data_buf_r</pre>
<pre>          : data_mem_data_i;</pre>
<pre>        lce_cmd_v_o = 1'b1;</pre>
<pre></pre>
<pre>        state_n = lce_tr_done</pre>
<pre>          ? e_lce_cmd_state_ready</pre>
<pre>          : e_lce_cmd_state_tr;</pre>
<pre>      end</pre>
<pre>        state_n = dirty_i[lce_cmd_li.way_id] </pre>
<pre>          ? e_lce_cmd_state_wb_dirty</pre>
<pre>          : e_lce_cmd_state_wb_not_dirty;</pre>
<pre>      end</pre>
<pre>        data_mem_pkt.index = lce_cmd_addr_index;</pre>
<pre>        data_mem_pkt.way_id = lce_cmd_li.way_id;</pre>
<pre>        data_mem_pkt.opcode = e_dcache_lce_data_mem_read;</pre>
<pre>        data_mem_pkt_v_o = ~wb_data_read_r;</pre>
<pre>        data_buf_n = wb_data_buffered_r</pre>
<pre>          ? data_buf_r</pre>
<pre>          : (wb_data_read_r</pre>
<pre>            ? data_mem_data_i</pre>
<pre>            : data_buf_r);</pre>
<pre>        wb_data_buffered_n = lce_resp_done</pre>
<pre>          ? 1'b0</pre>
<pre>          : (wb_data_buffered_r</pre>
<pre>            ? 1'b1</pre>
<pre>            : wb_data_read_r);</pre>
<pre>        wb_data_read_n = lce_resp_done</pre>
<pre>          ? 1'b0</pre>
<pre>          : (wb_data_read_r</pre>
<pre>            ? 1'b1</pre>
<pre>            : data_mem_pkt_yumi_i);</pre>
<pre></pre>
<pre>        stat_mem_pkt.way_id = lce_cmd_li.way_id;</pre>
<pre>        stat_mem_pkt.opcode = e_dcache_lce_stat_mem_clear_dirty;</pre>
<pre>        stat_mem_pkt_v_o = wb_dirty_cleared_r</pre>
<pre>          ? 1'b0</pre>
<pre>          : (wb_data_read_r | data_mem_pkt_yumi_i);</pre>
<pre>        wb_dirty_cleared_n = lce_resp_done</pre>
<pre>          ? 1'b0</pre>
<pre>          : (wb_dirty_cleared_r</pre>
<pre>            ? 1'b1</pre>
<pre>            : stat_mem_pkt_yumi_i);</pre>
<pre>        </pre>
<pre>          ? data_buf_r</pre>
<pre>          : data_mem_data_i;</pre>
<pre>        lce_resp.addr = lce_cmd_li.msg.cmd.addr;</pre>
<pre>        lce_resp.msg_type = e_lce_cce_resp_wb;</pre>
<pre>        lce_resp.src_id = lce_id_i;</pre>
<pre>        lce_resp.dst_id = lce_cmd_li.msg.cmd.src_id;</pre>
<pre>        lce_resp_v_o = wb_data_read_r & (wb_dirty_cleared_r | stat_mem_pkt_yumi_i);</pre>
<pre></pre>
<pre></pre>
<pre>          ? e_lce_cmd_state_ready</pre>
<pre>          : e_lce_cmd_state_wb_dirty;</pre>
<pre>      end</pre>
<pre>        lce_resp.data = '0;</pre>
<pre>        lce_resp.addr = lce_cmd_li.msg.cmd.addr;</pre>
<pre>        lce_resp.msg_type = e_lce_cce_resp_null_wb;</pre>
<pre>        lce_resp.src_id = lce_id_i;</pre>
<pre>        lce_resp.dst_id = lce_cmd_li.msg.cmd.src_id;</pre>
<pre>        lce_resp_v_o = 1'b1;</pre>
<pre></pre>
<pre></pre>
<pre>          ? e_lce_cmd_state_ready</pre>
<pre>          : e_lce_cmd_state_wb_not_dirty;</pre>
<pre>      end      </pre>
<pre>        state_n = e_lce_cmd_state_sync;</pre>
<pre>      end</pre>
<pre>    if (reset_i) begin</pre>
<pre>      state_r <= e_lce_cmd_state_uncached;</pre>
<pre>      sync_ack_count_r <= '0;</pre>
<pre>      tr_data_buffered_r <= 1'b0;</pre>
<pre>      wb_data_buffered_r <= 1'b0;</pre>
<pre>      wb_data_read_r <= 1'b0;</pre>
<pre>      wb_dirty_cleared_r <= 1'b0;</pre>
<pre>      invalidated_tag_r <= 1'b0;</pre>
<pre>    end</pre>
<pre>      state_r <= state_n;</pre>
<pre>      sync_ack_count_r <= sync_ack_count_n;</pre>
<pre>      tr_data_buffered_r <= tr_data_buffered_n;</pre>
<pre>      wb_data_buffered_r <= wb_data_buffered_n;</pre>
<pre>      wb_data_read_r <= wb_data_read_n;</pre>
<pre>      wb_dirty_cleared_r <= wb_dirty_cleared_n;</pre>
<pre>      data_buf_r <= data_buf_n;</pre>
<pre>      invalidated_tag_r <= invalidated_tag_n;</pre>
<pre>    end</pre>
<pre>   #(.width_p(lce_cmd_width_lp))</pre>
<pre>   rv_adapter</pre>
<pre style="background-color: #FF0000;">    (.clk_i(clk_i)</pre>
<pre>     ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>     ,.v_i(lce_cmd_v_i)</pre>
<pre>     ,.ready_o(lce_cmd_ready_o)</pre>
<pre></pre>
<pre>     ,.v_o(lce_cmd_v_li)</pre>
<pre>     ,.yumi_i(lce_cmd_yumi_lo)</pre>
<pre>     );</pre>
<h3>./bp_top/src/v/bp_mmio_enclave.v</h3>
<pre>module bp_mmio_enclave</pre>
<pre> import bp_cfg_link_pkg::*;</pre>
<pre style="background-color: #FF0000;"> import bp_cce_pkg::*;</pre>
<pre> import bsg_noc_pkg::*;</pre>
<pre>   `declare_bp_proc_params(cfg_p)</pre>
<pre>   )</pre>
<pre>   , input                                         reset_i</pre>
<pre></pre>
<pre>   , input [mem_noc_cid_width_p-1:0]               my_cid_i</pre>
<pre></pre>
<pre>   , output [mem_noc_ral_link_width_lp-1:0]        cmd_link_o</pre>
<pre></pre>
<pre>   , output [mem_noc_ral_link_width_lp-1:0]        resp_link_o</pre>
<pre></pre>
<pre>   , output [num_core_p-1:0]                       timer_irq_o</pre>
<pre>   , output [num_core_p-1:0]                       external_irq_o</pre>
<pre></pre>
<pre>   , output [num_core_p-1:0][cfg_addr_width_p-1:0] cfg_addr_o</pre>
<pre>   , output [num_core_p-1:0][cfg_data_width_p-1:0] cfg_data_o</pre>
<pre>   );</pre>
<pre style="background-color: #FF0000;"></pre>
<pre>logic mem_cmd_v_li, mem_cmd_yumi_lo;</pre>
<pre></pre>
<pre>logic mem_resp_v_lo, mem_resp_ready_li;</pre>
<pre></pre>
<pre></pre>
<pre>logic mipi_cmd_v;</pre>
<pre>logic mtimecmp_cmd_v;</pre>
<pre>logic mtime_cmd_v;</pre>
<pre>logic plic_cmd_v;</pre>
<pre>logic wr_not_rd;</pre>
<pre></pre>
<pre>  begin</pre>
<pre>    cfg_cmd_v           = 1'b0;</pre>
<pre>    mipi_cmd_v          = 1'b0;</pre>
<pre>    mtimecmp_cmd_v      = 1'b0;</pre>
<pre>    mtime_cmd_v         = 1'b0;</pre>
<pre>    plic_cmd_v          = 1'b0;</pre>
<pre></pre>
<pre></pre>
<pre>    casez (mem_cmd_li.addr)</pre>
<pre>      cfg_link_dev_base_addr_gp: cfg_cmd_v      = mem_cmd_v_li;</pre>
<pre>      mipi_reg_base_addr_gp    : mipi_cmd_v     = mem_cmd_v_li;</pre>
<pre>      mtimecmp_reg_base_addr_gp: mtimecmp_cmd_v = mem_cmd_v_li;</pre>
<pre>      mtime_reg_addr_gp        : mtime_cmd_v    = mem_cmd_v_li;</pre>
<pre>      plic_reg_base_addr_gp    : plic_cmd_v     = mem_cmd_v_li;</pre>
<pre>      default: begin end</pre>
<pre>logic [num_core_p-1:0] mtimecmp_v_li;</pre>
<pre>logic [num_core_p-1:0] mipi_v_li;</pre>
<pre>logic [num_core_p-1:0] plic_v_li;</pre>
<pre></pre>
<pre>localparam mipi_core_offset_lp = 2;</pre>
<pre>localparam mtimecmp_core_offset_lp = 3;</pre>
<pre>wire [lg_num_core_lp-1:0] mipi_cmd_core_enc = </pre>
<pre>  mem_cmd_li.addr[mipi_core_offset_lp+:lg_num_core_lp];</pre>
<pre>wire [lg_num_core_lp-1:0] mtimecmp_cmd_core_enc = </pre>
<pre>  mem_cmd_li.addr[mtimecmp_core_offset_lp+:lg_num_core_lp];  </pre>
<pre></pre>
<pre> #(.num_out_p(num_core_p))</pre>
<pre> mipi_cmd_decoder</pre>
<pre>  (.v_i(mipi_cmd_v)</pre>
<pre>   ,.i(mipi_cmd_core_enc)</pre>
<pre>   </pre>
<pre>   ,.o(mipi_v_li)</pre>
<pre>   );</pre>
<pre></pre>
<pre>bsg_decode_with_v</pre>
<pre> #(.num_out_p(num_core_p))</pre>
<pre> mtimecmp_cmd_decoder</pre>
<pre>  (.v_i(mtimecmp_cmd_v)</pre>
<pre>   ,.i(mtimecmp_cmd_core_enc)</pre>
<pre>   </pre>
<pre>   ,.o(mtimecmp_v_li)</pre>
<pre>   );</pre>
<pre></pre>
<pre style="background-color: #FF0000;">bsg_decode_with_v</pre>
<pre> #(.num_out_p(num_core_p))</pre>
<pre> plic_cmd_decoder</pre>
<pre style="background-color: #FF0000;">  (.v_i(plic_cmd_v)</pre>
<pre>   ,.i(mtimecmp_cmd_core_enc)</pre>
<pre></pre>
<pre>   ,.o(plic_v_li)</pre>
<pre>   );</pre>
<pre></pre>
<pre>logic [dword_width_p-1:0] mtime_n, mtime_r;</pre>
<pre>wire mtime_w_v_li = wr_not_rd & mtime_cmd_v;</pre>
<pre>assign mtime_n    = mtime_w_v_li </pre>
<pre>                    ? mem_cmd_li.data[0+:dword_width_p] </pre>
<pre>                    : mtime_r + dword_width_p'(1);</pre>
<pre>  bsg_dff_reset</pre>
<pre>   #(.width_p(dword_width_p))</pre>
<pre>   mtime_reg</pre>
<pre style="background-color: #FF0000;">    (.clk_i(clk_i) // TODO: Should be a RTC once CDC strategy is decided</pre>
<pre>     ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>     ,.data_i(mtime_n)</pre>
<pre>     ,.data_o(mtime_r)</pre>
<pre>     );</pre>
<pre></pre>
<pre>logic [num_core_p-1:0][dword_width_p-1:0] mtimecmp_n, mtimecmp_r;</pre>
<pre>logic [num_core_p-1:0]                    mipi_n, mipi_r;</pre>
<pre>logic [num_core_p-1:0]                    plic_n, plic_r;</pre>
<pre></pre>
<pre>// cfg link to tile</pre>
<pre>// TODO: cfg_link payload should be a struct</pre>
<pre>logic [num_core_p-1:0]      cfg_v_li;</pre>
<pre>wire [cfg_core_width_p-1:0] cfg_core_li      = mem_cmd_li.data[cfg_data_width_p+cfg_addr_width_p+:cfg_core_width_p];</pre>
<pre>wire [cfg_addr_width_p-1:0] cfg_addr_li      = mem_cmd_li.data[cfg_data_width_p+:cfg_addr_width_p];</pre>
<pre>wire [cfg_data_width_p-1:0] cfg_data_li      = mem_cmd_li.data[0+:cfg_data_width_p];</pre>
<pre>wire                        cfg_broadcast_li = cfg_cmd_v & (cfg_core_li == '1);</pre>
<pre></pre>
<pre style="background-color: #FF0000;">bsg_decode_with_v</pre>
<pre> #(.num_out_p(num_core_p))</pre>
<pre> cfg_link_decoder</pre>
<pre>  (.v_i(cfg_cmd_v)</pre>
<pre>   ,.i(cfg_core_li[0+:`BSG_SAFE_CLOG2(num_core_p)])</pre>
<pre>   ,.o(cfg_v_li)</pre>
<pre>   );</pre>
<pre></pre>
<pre>for (genvar i = 0; i < num_core_p; i++)</pre>
<pre>  begin : rof1</pre>
<pre>    assign mtimecmp_n[i] = mem_cmd_li.data[0+:dword_width_p];</pre>
<pre>    wire mtimecmp_w_v_li = wr_not_rd & mtimecmp_v_li[i];</pre>
<pre>    bsg_dff_reset_en</pre>
<pre>     #(.width_p(dword_width_p))</pre>
<pre>     mtimecmp_reg</pre>
<pre style="background-color: #FF0000;">      (.clk_i(clk_i)</pre>
<pre>       ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>       ,.data_i(mtimecmp_n[i])</pre>
<pre>       ,.data_o(mtimecmp_r[i])</pre>
<pre>       );</pre>
<pre></pre>
<pre>    wire mipi_w_v_li = wr_not_rd & mipi_v_li[i];</pre>
<pre>    bsg_dff_reset_en</pre>
<pre>     #(.width_p(1))</pre>
<pre>     mipi_reg</pre>
<pre style="background-color: #FF0000;">      (.clk_i(clk_i)</pre>
<pre>       ,.reset_i(reset_i)</pre>
<pre>       ,.en_i(mipi_w_v_li)</pre>
<pre></pre>
<pre>       ,.data_o(mipi_r[i])</pre>
<pre>       );</pre>
<pre></pre>
<pre>    wire plic_w_v_li = wr_not_rd & plic_v_li[i];</pre>
<pre>    bsg_dff_reset_en</pre>
<pre>     #(.width_p(1))</pre>
<pre>     plic_reg</pre>
<pre style="background-color: #FF0000;">      (.clk_i(clk_i)</pre>
<pre>       ,.reset_i(reset_i)</pre>
<pre>       ,.en_i(plic_w_v_li)</pre>
<pre></pre>
<pre>       ,.data_o(plic_r[i])</pre>
<pre>       );</pre>
<pre></pre>
<pre></pre>
<pre>    assign cfg_addr_o[i] = cfg_addr_li;</pre>
<pre>    assign cfg_data_o[i] = cfg_data_li;</pre>
<pre>  end // rof1</pre>
<pre>bsg_mux_one_hot</pre>
<pre> #(.width_p(1)</pre>
<pre>   ,.els_p(num_core_p) </pre>
<pre>   )</pre>
<pre style="background-color: #FF0000;">  (.data_i(mipi_r)</pre>
<pre>   ,.sel_one_hot_i(mipi_v_li)</pre>
<pre>   ,.data_o(mipi_lo)</pre>
<pre>   );</pre>
<pre>bsg_mux_one_hot</pre>
<pre> #(.width_p(dword_width_p)</pre>
<pre>   ,.els_p(num_core_p)</pre>
<pre>   )</pre>
<pre style="background-color: #FF0000;">  (.data_i(mtimecmp_r)</pre>
<pre>   ,.sel_one_hot_i(mtimecmp_v_li)</pre>
<pre>   ,.data_o(mtimecmp_lo)</pre>
<pre>   );</pre>
<pre>bsg_mux_one_hot</pre>
<pre> #(.width_p(1)</pre>
<pre>   ,.els_p(num_core_p)</pre>
<pre>   )</pre>
<pre style="background-color: #FF0000;">  (.data_i(plic_r)</pre>
<pre>   ,.sel_one_hot_i(plic_v_li)</pre>
<pre>   ,.data_o(plic_lo)</pre>
<pre>   );</pre>
<pre>                                    ? dword_width_p'(plic_lo)</pre>
<pre>                                    : mipi_cmd_v </pre>
<pre>                                      ? dword_width_p'(mipi_lo)</pre>
<pre>                                      : mtimecmp_cmd_v </pre>
<pre>                                        ? dword_width_p'(mtimecmp_lo)</pre>
<pre>                                        : mtime_r;</pre>
<pre></pre>
<pre>  '{msg_type       : mem_cmd_li.msg_type</pre>
<pre>    ,addr          : mem_cmd_li.addr</pre>
<pre>    ,payload       : mem_cmd_li.payload</pre>
<pre>    ,size          : mem_cmd_li.size</pre>
<pre>    ,data          : cce_block_width_p'(rdata_lo)</pre>
<pre>    };</pre>
<pre>assign mem_resp_v_lo = mem_cmd_yumi_lo;</pre>
<pre>bp_me_cce_to_wormhole_link_client</pre>
<pre> #(.cfg_p(cfg_p))</pre>
<pre> client_link</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>   ,.mem_cmd_v_o(mem_cmd_v_li)</pre>
<pre>   ,.mem_cmd_yumi_i(mem_cmd_yumi_lo)</pre>
<pre></pre>
<pre>   ,.mem_resp_v_i(mem_resp_v_lo)</pre>
<pre>   ,.mem_resp_ready_o(mem_resp_ready_li)</pre>
<pre></pre>
<pre>   ,.my_cid_i(my_cid_i)</pre>
<pre></pre>
<pre>   ,.cmd_link_o(cmd_link_o)</pre>
<pre></pre>
<pre>   ,.resp_link_o(resp_link_o)</pre>
<pre>   );</pre>
<h3>./bp_top/src/v/bp_tile_node.v</h3>
<pre>module bp_tile_node</pre>
<pre> import bp_common_pkg::*;</pre>
<pre> import bp_common_rv64_pkg::*;</pre>
<pre> import bp_common_aviary_pkg::*;</pre>
<pre> import bsg_wormhole_router_pkg::*;</pre>
<pre> import bp_me_pkg::*;</pre>
<pre> #(parameter bp_cfg_e cfg_p = e_bp_inv_cfg</pre>
<pre>   `declare_bp_proc_params(cfg_p)</pre>
<pre>   , localparam mem_noc_ral_link_width_lp = `bsg_ready_and_link_sif_width(mem_noc_flit_width_p)</pre>
<pre></pre>
<pre>   , localparam proc_cfg_width_lp = `bp_proc_cfg_width(num_core_p, num_cce_p, num_lce_p)</pre>
<pre>   , input                                       core_reset_i</pre>
<pre></pre>
<pre>   , input                                       coh_clk_i</pre>
<pre>   , input                                       coh_reset_i</pre>
<pre></pre>
<pre>   , input                                       mem_reset_i</pre>
<pre></pre>
<pre></pre>
<pre>   , input [mem_noc_cid_width_p-1:0]             my_cid_i</pre>
<pre>   , input [mem_noc_cord_width_p-1:0]            dram_cord_i</pre>
<pre>   , input [mem_noc_cord_width_p-1:0]            mmio_cord_i</pre>
<pre>   , input [mem_noc_cord_width_p-1:0]            host_cord_i</pre>
<pre></pre>
<pre>   , input [cfg_addr_width_p-1:0]                cfg_addr_i</pre>
<pre>   , input [cfg_data_width_p-1:0]                cfg_data_i</pre>
<pre></pre>
<pre>   , input                                       software_int_i</pre>
<pre>   , input                                       external_int_i</pre>
<pre></pre>
<pre>   , output [S:W][coh_noc_ral_link_width_lp-1:0] coh_lce_req_link_o</pre>
<pre></pre>
<pre>   , output [S:W][coh_noc_ral_link_width_lp-1:0] coh_lce_cmd_link_o</pre>
<pre></pre>
<pre>   , output [S:W][coh_noc_ral_link_width_lp-1:0] coh_lce_resp_link_o</pre>
<pre></pre>
<pre>   , output [S:W][mem_noc_ral_link_width_lp-1:0] mem_cmd_link_o</pre>
<pre></pre>
<pre>   , output [S:W][mem_noc_ral_link_width_lp-1:0] mem_resp_link_o</pre>
<pre>   );</pre>
<pre>`declare_bp_common_proc_cfg_s(num_core_p, num_cce_p, num_lce_p)</pre>
<pre>`declare_bp_lce_cce_if(num_cce_p, num_lce_p, paddr_width_p, lce_assoc_p, dword_width_p, cce_block_width_p)</pre>
<pre>`declare_bp_me_if(paddr_width_p, cce_block_width_p, num_lce_p, lce_assoc_p)</pre>
<pre></pre>
<pre style="background-color: #FF0000;">bp_proc_cfg_s proc_cfg_cast_i;</pre>
<pre>assign proc_cfg_cast_i = proc_cfg_i;</pre>
<pre></pre>
<pre>`declare_bsg_ready_and_link_sif_s(coh_noc_flit_width_p, bp_coh_ready_and_link_s);</pre>
<pre>`declare_bsg_ready_and_link_sif_s(mem_noc_flit_width_p, bp_mem_ready_and_link_s);</pre>
<pre></pre>
<pre>bp_coh_ready_and_link_s core_lce_cmd_link_li, core_lce_cmd_link_lo;</pre>
<pre>bp_coh_ready_and_link_s core_lce_resp_link_li, core_lce_resp_link_lo;</pre>
<pre></pre>
<pre>bp_mem_ready_and_link_s core_mem_cmd_link_li, core_mem_cmd_link_lo;</pre>
<pre>bp_mem_ready_and_link_s core_mem_resp_link_li, core_mem_resp_link_lo;</pre>
<pre></pre>
<pre>  bp_tile</pre>
<pre>   #(.cfg_p(cfg_p))</pre>
<pre>   tile</pre>
<pre>    (.clk_i(core_clk_i)</pre>
<pre>     ,.reset_i(core_reset_i)</pre>
<pre></pre>
<pre>     ,.proc_cfg_i(proc_cfg_i)</pre>
<pre></pre>
<pre>     // CCE-MEM IF</pre>
<pre>     ,.my_cord_i(my_cord_i)</pre>
<pre>     ,.my_cid_i('0)</pre>
<pre>     ,.dram_cord_i(dram_cord_i)</pre>
<pre>     ,.mmio_cord_i(mmio_cord_i)</pre>
<pre>     ,.host_cord_i(host_cord_i)</pre>
<pre></pre>
<pre>     ,.cfg_w_v_i(cfg_w_v_i)</pre>
<pre>     ,.cfg_addr_i(cfg_addr_i)</pre>
<pre>     ,.cfg_data_i(cfg_data_i)</pre>
<pre></pre>
<pre>     ,.timer_int_i(timer_int_i)</pre>
<pre>     ,.software_int_i(software_int_i)</pre>
<pre>     ,.external_int_i(external_int_i)</pre>
<pre></pre>
<pre>     ,.lce_req_link_i(core_lce_req_link_li)</pre>
<pre>     ,.lce_req_link_o(core_lce_req_link_lo)</pre>
<pre></pre>
<pre>     ,.lce_cmd_link_i(core_lce_cmd_link_li)</pre>
<pre>     ,.lce_cmd_link_o(core_lce_cmd_link_lo)</pre>
<pre></pre>
<pre>     ,.lce_resp_link_i(core_lce_resp_link_li)</pre>
<pre>     ,.lce_resp_link_o(core_lce_resp_link_lo)</pre>
<pre></pre>
<pre>     ,.cmd_link_i(core_mem_cmd_link_li)</pre>
<pre>     ,.resp_link_i(core_mem_resp_link_li)</pre>
<pre></pre>
<pre>     ,.cmd_link_o(core_mem_cmd_link_lo)</pre>
<pre>     ,.resp_link_o(core_mem_resp_link_lo)</pre>
<pre>     );</pre>
<pre></pre>
<pre>// Network-side coherence connections</pre>
<pre>bp_coh_ready_and_link_s coh_lce_req_link_li, coh_lce_req_link_lo;</pre>
<pre>bp_coh_ready_and_link_s coh_lce_cmd_link_li, coh_lce_cmd_link_lo;</pre>
<pre>bp_coh_ready_and_link_s coh_lce_resp_link_li, coh_lce_resp_link_lo;</pre>
<pre></pre>
<pre>// Network side membus connections</pre>
<pre>bp_mem_ready_and_link_s mem_cmd_link_li, mem_cmd_link_lo;</pre>
<pre>bp_mem_ready_and_link_s mem_resp_link_li, mem_resp_link_lo;</pre>
<pre></pre>
<pre>  if (async_coh_clk_p == 1)</pre>
<pre>    begin : coh_async</pre>
<pre>      logic core_lce_req_full_lo;</pre>
<pre>      assign core_lce_req_link_li.ready_and_rev = ~core_lce_req_full_lo;</pre>
<pre>      wire core_lce_req_enq_li = core_lce_req_link_lo.v & core_lce_req_link_li.ready_and_rev;</pre>
<pre>      wire coh_lce_req_deq_li = coh_lce_req_link_li.v & coh_lce_req_link_lo.ready_and_rev;</pre>
<pre>      bsg_async_fifo</pre>
<pre>       #(.lg_size_p(3)</pre>
<pre>         ,.width_p(coh_noc_flit_width_p)</pre>
<pre style="background-color: #FF0000;">         )</pre>
<pre>       lce_req_link_async_fifo_to_rtr</pre>
<pre>        (.w_clk_i(core_clk_i)</pre>
<pre style="background-color: #FF0000;">         ,.w_reset_i(core_reset_i)</pre>
<pre>         ,.w_enq_i(core_lce_req_enq_li)</pre>
<pre>         ,.w_data_i(core_lce_req_link_lo.data)</pre>
<pre>         ,.w_full_o(core_lce_req_full_lo)</pre>
<pre></pre>
<pre>         ,.r_clk_i(coh_clk_i)</pre>
<pre>         ,.r_reset_i(coh_reset_i)</pre>
<pre>         ,.r_deq_i(coh_lce_req_deq_li)</pre>
<pre>         ,.r_data_o(coh_lce_req_link_li.data)</pre>
<pre>         ,.r_valid_o(coh_lce_req_link_li.v)</pre>
<pre style="background-color: #FF0000;">         );</pre>
<pre>      assign core_lce_cmd_link_li.ready_and_rev = ~core_lce_cmd_full_lo;</pre>
<pre style="background-color: #FF0000;">      wire core_lce_cmd_enq_li = core_lce_cmd_link_lo.v & core_lce_cmd_link_li.ready_and_rev;</pre>
<pre style="background-color: #FF0000;">      wire coh_lce_cmd_deq_li = coh_lce_cmd_link_li.v & coh_lce_cmd_link_lo.ready_and_rev;</pre>
<pre style="background-color: #FF0000;">      bsg_async_fifo</pre>
<pre style="background-color: #FF0000;">       #(.lg_size_p(3)</pre>
<pre style="background-color: #FF0000;">         ,.width_p(coh_noc_flit_width_p)</pre>
<pre style="background-color: #FF0000;">         )</pre>
<pre style="background-color: #FF0000;">        (.w_clk_i(core_clk_i)</pre>
<pre style="background-color: #FF0000;">         ,.w_reset_i(core_reset_i)</pre>
<pre style="background-color: #FF0000;">         ,.w_enq_i(core_lce_cmd_enq_li)</pre>
<pre style="background-color: #FF0000;">         ,.w_data_i(core_lce_cmd_link_lo.data)</pre>
<pre style="background-color: #FF0000;">         ,.w_full_o(core_lce_cmd_full_lo)</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">         ,.r_reset_i(coh_reset_i)</pre>
<pre style="background-color: #FF0000;">         ,.r_deq_i(coh_lce_cmd_deq_li)</pre>
<pre style="background-color: #FF0000;">         ,.r_data_o(coh_lce_cmd_link_li.data)</pre>
<pre style="background-color: #FF0000;">         ,.r_valid_o(coh_lce_cmd_link_li.v)</pre>
<pre style="background-color: #FF0000;">         );</pre>
<pre style="background-color: #FF0000;">      assign core_lce_resp_link_li.ready_and_rev = ~core_lce_resp_full_lo;</pre>
<pre style="background-color: #FF0000;">      wire core_lce_resp_enq_li = core_lce_resp_link_lo.v & core_lce_resp_link_li.ready_and_rev;</pre>
<pre style="background-color: #FF0000;">      wire coh_lce_resp_deq_li = coh_lce_resp_link_li.v & coh_lce_resp_link_lo.ready_and_rev;</pre>
<pre style="background-color: #FF0000;">      bsg_async_fifo</pre>
<pre style="background-color: #FF0000;">       #(.lg_size_p(3)</pre>
<pre style="background-color: #FF0000;">         ,.width_p(coh_noc_flit_width_p)</pre>
<pre style="background-color: #FF0000;">         )</pre>
<pre style="background-color: #FF0000;">        (.w_clk_i(core_clk_i)</pre>
<pre style="background-color: #FF0000;">         ,.w_reset_i(core_reset_i)</pre>
<pre style="background-color: #FF0000;">         ,.w_enq_i(core_lce_resp_enq_li)</pre>
<pre style="background-color: #FF0000;">         ,.w_data_i(core_lce_resp_link_lo.data)</pre>
<pre style="background-color: #FF0000;">         ,.w_full_o(core_lce_resp_full_lo)</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">         ,.r_reset_i(coh_reset_i)</pre>
<pre style="background-color: #FF0000;">         ,.r_deq_i(coh_lce_resp_deq_li)</pre>
<pre style="background-color: #FF0000;">         ,.r_data_o(coh_lce_resp_link_li.data)</pre>
<pre style="background-color: #FF0000;">         ,.r_valid_o(coh_lce_resp_link_li.v)</pre>
<pre style="background-color: #FF0000;">         );</pre>
<pre style="background-color: #FF0000;">      assign coh_lce_req_link_li.ready_and_rev = ~coh_lce_req_full_lo;</pre>
<pre style="background-color: #FF0000;">      wire coh_lce_req_enq_li = coh_lce_req_link_lo.v & coh_lce_req_link_li.ready_and_rev;</pre>
<pre style="background-color: #FF0000;">      wire core_lce_req_deq_li = core_lce_req_link_li.v & core_lce_req_link_lo.ready_and_rev;</pre>
<pre style="background-color: #FF0000;">      bsg_async_fifo</pre>
<pre style="background-color: #FF0000;">       #(.lg_size_p(3)</pre>
<pre style="background-color: #FF0000;">         ,.width_p(coh_noc_flit_width_p)</pre>
<pre style="background-color: #FF0000;">         )</pre>
<pre style="background-color: #FF0000;">        (.w_clk_i(coh_clk_i)</pre>
<pre style="background-color: #FF0000;">         ,.w_reset_i(coh_reset_i)</pre>
<pre style="background-color: #FF0000;">         ,.w_enq_i(coh_lce_req_enq_li)</pre>
<pre style="background-color: #FF0000;">         ,.w_data_i(coh_lce_req_link_lo.data)</pre>
<pre style="background-color: #FF0000;">         ,.w_full_o(coh_lce_req_full_lo)</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">         ,.r_reset_i(core_reset_i)</pre>
<pre style="background-color: #FF0000;">         ,.r_deq_i(core_lce_req_deq_li)</pre>
<pre style="background-color: #FF0000;">         ,.r_data_o(core_lce_req_link_li.data)</pre>
<pre style="background-color: #FF0000;">         ,.r_valid_o(core_lce_req_link_li.v)</pre>
<pre style="background-color: #FF0000;">         );</pre>
<pre style="background-color: #FF0000;">      assign coh_lce_cmd_link_li.ready_and_rev = ~coh_lce_cmd_full_lo;</pre>
<pre style="background-color: #FF0000;">      wire coh_lce_cmd_enq_li = coh_lce_cmd_link_lo.v & coh_lce_cmd_link_li.ready_and_rev;</pre>
<pre style="background-color: #FF0000;">      wire core_lce_cmd_deq_li = core_lce_cmd_link_li.v & core_lce_cmd_link_lo.ready_and_rev;</pre>
<pre style="background-color: #FF0000;">      bsg_async_fifo</pre>
<pre style="background-color: #FF0000;">       #(.lg_size_p(3)</pre>
<pre style="background-color: #FF0000;">         ,.width_p(coh_noc_flit_width_p)</pre>
<pre style="background-color: #FF0000;">         )</pre>
<pre style="background-color: #FF0000;">        (.w_clk_i(coh_clk_i)</pre>
<pre style="background-color: #FF0000;">         ,.w_reset_i(coh_reset_i)</pre>
<pre style="background-color: #FF0000;">         ,.w_enq_i(coh_lce_cmd_enq_li)</pre>
<pre style="background-color: #FF0000;">         ,.w_data_i(coh_lce_cmd_link_lo.data)</pre>
<pre style="background-color: #FF0000;">         ,.w_full_o(coh_lce_cmd_full_lo)</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">         ,.r_reset_i(core_reset_i)</pre>
<pre style="background-color: #FF0000;">         ,.r_deq_i(core_lce_cmd_deq_li)</pre>
<pre style="background-color: #FF0000;">         ,.r_data_o(core_lce_cmd_link_li.data)</pre>
<pre style="background-color: #FF0000;">         ,.r_valid_o(core_lce_cmd_link_li.v)</pre>
<pre style="background-color: #FF0000;">         );</pre>
<pre style="background-color: #FF0000;">      assign coh_lce_resp_link_li.ready_and_rev = ~coh_lce_resp_full_lo;</pre>
<pre style="background-color: #FF0000;">      wire coh_lce_resp_enq_li = coh_lce_resp_link_lo.v & coh_lce_resp_link_li.ready_and_rev;</pre>
<pre style="background-color: #FF0000;">      wire core_lce_resp_deq_li = core_lce_resp_link_li.v & core_lce_resp_link_lo.ready_and_rev;</pre>
<pre style="background-color: #FF0000;">      bsg_async_fifo</pre>
<pre style="background-color: #FF0000;">       #(.lg_size_p(3)</pre>
<pre style="background-color: #FF0000;">         ,.width_p(coh_noc_flit_width_p)</pre>
<pre style="background-color: #FF0000;">         )</pre>
<pre style="background-color: #FF0000;">        (.w_clk_i(coh_clk_i)</pre>
<pre style="background-color: #FF0000;">         ,.w_reset_i(coh_reset_i)</pre>
<pre style="background-color: #FF0000;">         ,.w_enq_i(coh_lce_resp_enq_li)</pre>
<pre style="background-color: #FF0000;">         ,.w_data_i(coh_lce_resp_link_lo.data)</pre>
<pre style="background-color: #FF0000;">         ,.w_full_o(coh_lce_resp_full_lo)</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">         ,.r_reset_i(core_reset_i)</pre>
<pre style="background-color: #FF0000;">         ,.r_deq_i(core_lce_resp_deq_li)</pre>
<pre style="background-color: #FF0000;">         ,.r_data_o(core_lce_resp_link_li.data)</pre>
<pre style="background-color: #FF0000;">         ,.r_valid_o(core_lce_resp_link_li.v)</pre>
<pre style="background-color: #FF0000;">         );</pre>
<pre>      assign coh_lce_req_link_li  = core_lce_req_link_lo;</pre>
<pre>      assign coh_lce_cmd_link_li  = core_lce_cmd_link_lo;</pre>
<pre>      assign coh_lce_resp_link_li = core_lce_resp_link_lo;</pre>
<pre></pre>
<pre>      assign core_lce_cmd_link_li  = coh_lce_cmd_link_lo;</pre>
<pre>      assign core_lce_resp_link_li = coh_lce_resp_link_lo;</pre>
<pre>    end</pre>
<pre style="background-color: #FF0000;">    begin : mem_async</pre>
<pre style="background-color: #FF0000;">      logic core_mem_cmd_full_lo;</pre>
<pre style="background-color: #FF0000;">      assign core_mem_cmd_link_li.ready_and_rev = ~core_mem_cmd_full_lo;</pre>
<pre style="background-color: #FF0000;">      wire core_mem_cmd_enq_li = core_mem_cmd_link_lo.v & core_mem_cmd_link_li.ready_and_rev;</pre>
<pre style="background-color: #FF0000;">      wire mem_cmd_deq_li = mem_cmd_link_li.v & mem_cmd_link_lo.ready_and_rev;</pre>
<pre style="background-color: #FF0000;">      bsg_async_fifo</pre>
<pre style="background-color: #FF0000;">       #(.lg_size_p(3)</pre>
<pre style="background-color: #FF0000;">         ,.width_p(mem_noc_flit_width_p)</pre>
<pre style="background-color: #FF0000;">         )</pre>
<pre style="background-color: #FF0000;">        (.w_clk_i(core_clk_i)</pre>
<pre style="background-color: #FF0000;">         ,.w_reset_i(core_reset_i)</pre>
<pre style="background-color: #FF0000;">         ,.w_enq_i(core_mem_cmd_enq_li)</pre>
<pre style="background-color: #FF0000;">         ,.w_data_i(core_mem_cmd_link_lo.data)</pre>
<pre style="background-color: #FF0000;">         ,.w_full_o(core_mem_cmd_full_lo)</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">         ,.r_reset_i(mem_reset_i)</pre>
<pre>         ,.r_deq_i(mem_cmd_deq_li)</pre>
<pre>         ,.r_data_o(mem_cmd_link_li.data)</pre>
<pre style="background-color: #FF0000;">         ,.r_valid_o(mem_cmd_link_li.v)</pre>
<pre style="background-color: #FF0000;">         );</pre>
<pre style="background-color: #FF0000;">      logic core_mem_resp_full_lo;</pre>
<pre style="background-color: #FF0000;">      assign core_mem_resp_link_li.ready_and_rev = ~core_mem_resp_full_lo;</pre>
<pre style="background-color: #FF0000;">      wire core_mem_resp_enq_li = core_mem_resp_link_lo.v & core_mem_resp_link_li.ready_and_rev;</pre>
<pre style="background-color: #FF0000;">      wire mem_resp_deq_li = mem_resp_link_li.v & mem_resp_link_lo.ready_and_rev;</pre>
<pre>      bsg_async_fifo</pre>
<pre style="background-color: #FF0000;">       #(.lg_size_p(3)</pre>
<pre style="background-color: #FF0000;">         ,.width_p(mem_noc_flit_width_p)</pre>
<pre style="background-color: #FF0000;">         )</pre>
<pre style="background-color: #FF0000;">        (.w_clk_i(core_clk_i)</pre>
<pre>         ,.w_reset_i(core_reset_i)</pre>
<pre style="background-color: #FF0000;">         ,.w_enq_i(core_mem_resp_enq_li)</pre>
<pre style="background-color: #FF0000;">         ,.w_data_i(core_mem_resp_link_lo.data)</pre>
<pre style="background-color: #FF0000;">         ,.w_full_o(core_mem_resp_full_lo)</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">         ,.r_reset_i(mem_reset_i)</pre>
<pre style="background-color: #FF0000;">         ,.r_deq_i(mem_resp_deq_li)</pre>
<pre style="background-color: #FF0000;">         ,.r_data_o(mem_resp_link_li.data)</pre>
<pre style="background-color: #FF0000;">         ,.r_valid_o(mem_resp_link_li.v)</pre>
<pre style="background-color: #FF0000;">         );</pre>
<pre style="background-color: #FF0000;">      assign mem_cmd_link_li.ready_and_rev = ~mem_cmd_full_lo;</pre>
<pre style="background-color: #FF0000;">      wire mem_cmd_enq_li = mem_cmd_link_lo.v & mem_cmd_link_li.ready_and_rev;</pre>
<pre style="background-color: #FF0000;">      wire core_mem_cmd_deq_li = core_mem_cmd_link_li.v & core_mem_cmd_link_lo.ready_and_rev;</pre>
<pre style="background-color: #FF0000;">      bsg_async_fifo</pre>
<pre style="background-color: #FF0000;">       #(.lg_size_p(3)</pre>
<pre style="background-color: #FF0000;">         ,.width_p(mem_noc_flit_width_p)</pre>
<pre style="background-color: #FF0000;">         )</pre>
<pre style="background-color: #FF0000;">        (.w_clk_i(mem_clk_i)</pre>
<pre style="background-color: #FF0000;">         ,.w_reset_i(mem_reset_i)</pre>
<pre style="background-color: #FF0000;">         ,.w_enq_i(mem_cmd_enq_li)</pre>
<pre style="background-color: #FF0000;">         ,.w_data_i(mem_cmd_link_lo.data)</pre>
<pre style="background-color: #FF0000;">         ,.w_full_o(mem_cmd_full_lo)</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">         ,.r_reset_i(core_reset_i)</pre>
<pre style="background-color: #FF0000;">         ,.r_deq_i(core_mem_cmd_deq_li)</pre>
<pre style="background-color: #FF0000;">         ,.r_data_o(core_mem_cmd_link_li.data)</pre>
<pre style="background-color: #FF0000;">         ,.r_valid_o(core_mem_cmd_link_li.v)</pre>
<pre style="background-color: #FF0000;">         );</pre>
<pre style="background-color: #FF0000;">      assign mem_resp_link_li.ready_and_rev = ~mem_resp_full_lo;</pre>
<pre style="background-color: #FF0000;">      wire mem_resp_enq_li = mem_resp_link_lo.v & mem_resp_link_li.ready_and_rev;</pre>
<pre style="background-color: #FF0000;">      wire core_mem_resp_deq_li = core_mem_resp_link_li.v & core_mem_resp_link_lo.ready_and_rev;</pre>
<pre style="background-color: #FF0000;">      bsg_async_fifo</pre>
<pre style="background-color: #FF0000;">       #(.lg_size_p(3)</pre>
<pre style="background-color: #FF0000;">         ,.width_p(mem_noc_flit_width_p)</pre>
<pre style="background-color: #FF0000;">         )</pre>
<pre style="background-color: #FF0000;">        (.w_clk_i(mem_clk_i)</pre>
<pre style="background-color: #FF0000;">         ,.w_reset_i(mem_reset_i)</pre>
<pre style="background-color: #FF0000;">         ,.w_enq_i(mem_resp_enq_li)</pre>
<pre style="background-color: #FF0000;">         ,.w_data_i(mem_resp_link_lo.data)</pre>
<pre style="background-color: #FF0000;">         ,.w_full_o(mem_resp_full_lo)</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">         ,.r_reset_i(core_reset_i)</pre>
<pre style="background-color: #FF0000;">         ,.r_deq_i(core_mem_resp_deq_li)</pre>
<pre style="background-color: #FF0000;">         ,.r_data_o(core_mem_resp_link_li.data)</pre>
<pre style="background-color: #FF0000;">         ,.r_valid_o(core_mem_resp_link_li.v)</pre>
<pre style="background-color: #FF0000;">         );</pre>
<pre>      assign mem_cmd_link_li  = core_mem_cmd_link_lo;</pre>
<pre>      assign mem_resp_link_li = core_mem_resp_link_lo;</pre>
<pre></pre>
<pre>      assign core_mem_resp_link_li = mem_resp_link_lo;</pre>
<pre>    end</pre>
<pre>  bp_me_lce_id_to_cord</pre>
<pre>   #(.cfg_p(cfg_p))</pre>
<pre>   router_cord</pre>
<pre style="background-color: #FF0000;">    (.lce_id_i(proc_cfg_cast_i.icache_id)</pre>
<pre>     ,.lce_cord_o(lce_cord_li)</pre>
<pre>     ,.lce_cid_o()</pre>
<pre>     );</pre>
<pre>   #(.flit_width_p(coh_noc_flit_width_p)</pre>
<pre>     ,.dims_p(coh_noc_dims_p)</pre>
<pre>     ,.cord_markers_pos_p(coh_noc_cord_markers_pos_p)</pre>
<pre>     ,.len_width_p(coh_noc_len_width_p)</pre>
<pre>     ,.reverse_order_p(1)</pre>
<pre>     ,.routing_matrix_p(StrictYX)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">    (.clk_i(coh_clk_i)</pre>
<pre>     ,.reset_i(coh_reset_i)</pre>
<pre></pre>
<pre>     ,.link_o({coh_lce_req_link_o, coh_lce_req_link_lo})</pre>
<pre></pre>
<pre>     );</pre>
<pre>   #(.flit_width_p(coh_noc_flit_width_p)</pre>
<pre>     ,.dims_p(coh_noc_dims_p)</pre>
<pre>     ,.cord_markers_pos_p(coh_noc_cord_markers_pos_p)</pre>
<pre>     ,.len_width_p(coh_noc_len_width_p)</pre>
<pre>     ,.reverse_order_p(1)</pre>
<pre>     ,.routing_matrix_p(StrictYX)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">    (.clk_i(coh_clk_i)</pre>
<pre>     ,.reset_i(coh_reset_i)</pre>
<pre></pre>
<pre>     ,.link_o({coh_lce_cmd_link_o, coh_lce_cmd_link_lo})</pre>
<pre></pre>
<pre>     );</pre>
<pre>   #(.flit_width_p(coh_noc_flit_width_p)</pre>
<pre>     ,.dims_p(coh_noc_dims_p)</pre>
<pre>     ,.cord_markers_pos_p(coh_noc_cord_markers_pos_p)</pre>
<pre>     ,.len_width_p(coh_noc_len_width_p)</pre>
<pre>     ,.reverse_order_p(1)</pre>
<pre>     ,.routing_matrix_p(StrictYX)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">    (.clk_i(coh_clk_i)</pre>
<pre>     ,.reset_i(coh_reset_i)</pre>
<pre></pre>
<pre>     ,.link_o({coh_lce_resp_link_o, coh_lce_resp_link_lo})</pre>
<pre></pre>
<pre>     );</pre>
<pre>   #(.flit_width_p(mem_noc_flit_width_p)</pre>
<pre>     ,.dims_p(mem_noc_dims_p)</pre>
<pre>     ,.cord_markers_pos_p(mem_noc_cord_markers_pos_p)</pre>
<pre>     ,.len_width_p(mem_noc_len_width_p)</pre>
<pre>     ,.reverse_order_p(1)</pre>
<pre>     ,.routing_matrix_p(StrictYX)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">   (.clk_i(mem_clk_i)</pre>
<pre>    ,.reset_i(mem_reset_i)</pre>
<pre>    ,.my_cord_i(my_cord_i)</pre>
<pre>    ,.link_i({mem_cmd_link_i, mem_cmd_link_li})</pre>
<pre>    ,.link_o({mem_cmd_link_o, mem_cmd_link_lo})</pre>
<pre>    );</pre>
<pre>   #(.flit_width_p(mem_noc_flit_width_p)</pre>
<pre>     ,.dims_p(mem_noc_dims_p)</pre>
<pre>     ,.cord_markers_pos_p(mem_noc_cord_markers_pos_p)</pre>
<pre>     ,.len_width_p(mem_noc_len_width_p)</pre>
<pre>     ,.reverse_order_p(1)</pre>
<pre>     ,.routing_matrix_p(StrictYX)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">    (.clk_i(mem_clk_i)</pre>
<pre>     ,.reset_i(mem_reset_i)</pre>
<pre>     ,.my_cord_i(my_cord_i)</pre>
<pre>     ,.link_i({mem_resp_link_i, mem_resp_link_li})</pre>
<pre>     ,.link_o({mem_resp_link_o, mem_resp_link_lo})</pre>
<pre>     );</pre>
<h3>./bp_common/src/include/bp_common_rv64_pkg.vh</h3>
<pre>package bp_common_rv64_pkg;</pre>
<pre>  localparam rv64_rf_els_gp         = 32;</pre>
<pre>  localparam rv64_instr_width_gp    = 32;</pre>
<pre>  localparam rv64_eaddr_width_gp    = 64;</pre>
<pre>  localparam rv64_byte_width_gp     = 8;</pre>
<pre>  localparam rv64_hword_width_gp    = 16;</pre>
<pre>  localparam rv64_word_width_gp     = 32;</pre>
<pre>  localparam rv64_dword_width_gp    = 64;</pre>
<pre>  localparam rv64_reg_data_width_gp = 64;</pre>
<pre>  localparam rv64_reg_addr_width_gp = 5;</pre>
<pre>  localparam rv64_shamt_width_gp    = 6;</pre>
<pre>  localparam rv64_shamtw_width_gp   = 5;</pre>
<pre>  localparam rv64_opcode_width_gp   = 7;</pre>
<pre>  localparam rv64_funct3_width_gp   = 3;</pre>
<pre>  localparam rv64_funct7_width_gp   = 7;</pre>
<pre>  localparam rv64_csr_addr_width_gp = 12;</pre>
<pre>  localparam rv64_imm20_width_gp    = 20;</pre>
<pre>  localparam rv64_imm12_width_gp    = 12;</pre>
<pre>  localparam rv64_imm11to5_width_gp = 7;</pre>
<pre>  localparam rv64_imm4to0_width_gp  = 5;</pre>
<pre>  localparam rv64_priv_width_gp     = 2;</pre>
<pre></pre>
<pre>  typedef struct packed</pre>
<pre>  {</pre>
<pre>    logic [rv64_funct7_width_gp-1:0]   funct7;</pre>
<pre>    logic [rv64_reg_addr_width_gp-1:0] rs2_addr;</pre>
<pre>    logic [rv64_reg_addr_width_gp-1:0] rs1_addr;</pre>
<pre>    logic [rv64_funct3_width_gp-1:0]   funct3;</pre>
<pre>    logic [rv64_reg_addr_width_gp-1:0] rd_addr;</pre>
<pre>  }  rv64_instr_rtype_s;</pre>
<pre>  typedef struct packed</pre>
<pre>  {</pre>
<pre>    logic [rv64_imm12_width_gp-1:0]    imm12;</pre>
<pre>    logic [rv64_reg_addr_width_gp-1:0] rs1;</pre>
<pre>    logic [rv64_funct3_width_gp-1:0]   funct3;</pre>
<pre>    logic [rv64_reg_addr_width_gp-1:0] rd_addr;</pre>
<pre style="background-color: #FF0000;">  }  rv64_instr_itype_s;</pre>
<pre></pre>
<pre>  typedef struct packed</pre>
<pre style="background-color: #FF0000;">  {</pre>
<pre>    logic [rv64_imm11to5_width_gp-1:0] imm11to5;</pre>
<pre>    logic [rv64_reg_addr_width_gp-1:0] rs2;</pre>
<pre>    logic [rv64_reg_addr_width_gp-1:0] rs1;</pre>
<pre>    logic [rv64_funct3_width_gp-1:0]   funct3;</pre>
<pre>    logic [rv64_imm4to0_width_gp-1:0]  imm4to0;</pre>
<pre>  }  rv64_instr_stype_s;</pre>
<pre>  typedef struct packed </pre>
<pre>    logic [rv64_imm20_width_gp-1:0]    imm20;</pre>
<pre>    logic [rv64_reg_addr_width_gp-1:0] rd_addr;</pre>
<pre style="background-color: #FF0000;">  }  rv64_instr_utype_s;</pre>
<pre>  typedef struct packed</pre>
<pre>    union packed</pre>
<pre>      rv64_instr_rtype_s rtype;</pre>
<pre>      rv64_instr_itype_s itype;</pre>
<pre>      rv64_instr_stype_s stype;</pre>
<pre>      rv64_instr_utype_s utype;</pre>
<pre>    }  fields;</pre>
<pre>    logic [rv64_opcode_width_gp-1:0]   opcode;</pre>
<pre>  }  rv64_instr_s;</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./external/basejump_stl/bsg_noc/bsg_noc_pkg.v</h3>
<pre>// direction type</pre>
<pre>  // https://www.veripool.org/issues/1442-Verilator-Enum-values-without-explicit-widths-are-considered-unsized</pre>
<h3>./external/basejump_stl/bsg_noc/bsg_wormhole_router_pkg.v</h3>
<pre>package bsg_wormhole_router_pkg;</pre>
<pre>  localparam  bit [1:0][2:0][2:0] StrictX</pre>
<pre style="background-color: #FF0000;">                             = {   // EWP (input)</pre>
<pre style="background-color: #FF0000;">                                {  3'b011 // E</pre>
<pre style="background-color: #FF0000;">                                  ,3'b101 // W</pre>
<pre style="background-color: #FF0000;">                                  ,3'b111 // P (output)</pre>
<pre style="background-color: #FF0000;">                                {  3'b011 // E</pre>
<pre style="background-color: #FF0000;">                                  ,3'b101 // W</pre>
<pre style="background-color: #FF0000;">                                  ,3'b111 // P (input)</pre>
<pre>  localparam  bit [1:0][2:0][2:0] X_AllowLoopBack  // for testing only; you should never build a machine like this </pre>
<pre style="background-color: #FF0000;">                             = {   // EWP (input)    // it will deadlock</pre>
<pre style="background-color: #FF0000;">                                {  3'b100 // E</pre>
<pre style="background-color: #FF0000;">                                  ,3'b010 // W</pre>
<pre style="background-color: #FF0000;">                                  ,3'b000 // P (output)</pre>
<pre style="background-color: #FF0000;">                                {  3'b111 // E</pre>
<pre style="background-color: #FF0000;">                                  ,3'b111 // W</pre>
<pre style="background-color: #FF0000;">                                  ,3'b111 // P (input)</pre>
<pre>  localparam bit [1:0][4:0][4:0] StrictXY</pre>
<pre style="background-color: #FF0000;">                            = {</pre>
<pre style="background-color: #FF0000;">                               {//  SNEWP (input)</pre>
<pre style="background-color: #FF0000;">                                 5'b01111  // S</pre>
<pre style="background-color: #FF0000;">                                ,5'b10111  // N</pre>
<pre style="background-color: #FF0000;">                                ,5'b00011  // E</pre>
<pre style="background-color: #FF0000;">                                ,5'b00101  // W</pre>
<pre style="background-color: #FF0000;">                                ,5'b11111  // P (output)</pre>
<pre style="background-color: #FF0000;">                               {//  SNEWP (output)</pre>
<pre style="background-color: #FF0000;">                                 5'b01001  // S</pre>
<pre style="background-color: #FF0000;">                                ,5'b10001  // N</pre>
<pre style="background-color: #FF0000;">                                ,5'b11011  // E</pre>
<pre style="background-color: #FF0000;">                                ,5'b11101  // W</pre>
<pre style="background-color: #FF0000;">                                ,5'b11111  // P (input)</pre>
<pre>  localparam bit [1:0][4:0][4:0] StrictYX</pre>
<pre style="background-color: #FF0000;">                            = {</pre>
<pre style="background-color: #FF0000;">                               {//  SNEWP (input)</pre>
<pre style="background-color: #FF0000;">                                 5'b01001  // S</pre>
<pre style="background-color: #FF0000;">                                ,5'b10001  // N</pre>
<pre style="background-color: #FF0000;">                                ,5'b11011  // E</pre>
<pre style="background-color: #FF0000;">                                ,5'b11101  // W</pre>
<pre style="background-color: #FF0000;">                                ,5'b11111  // P (output)</pre>
<pre style="background-color: #FF0000;">                               {//  SNEWP (output)</pre>
<pre style="background-color: #FF0000;">                                 5'b01111  // S</pre>
<pre style="background-color: #FF0000;">                                ,5'b10111  // N</pre>
<pre style="background-color: #FF0000;">                                ,5'b00011  // E</pre>
<pre style="background-color: #FF0000;">                                ,5'b00101  // W</pre>
<pre style="background-color: #FF0000;">                                ,5'b11111  // P (input)</pre>
<pre> localparam bit [1:0][4:0][4:0] XY_Allow_S</pre>
<pre style="background-color: #FF0000;">                            = {</pre>
<pre style="background-color: #FF0000;">                               {//  SNEWP (input)</pre>
<pre style="background-color: #FF0000;">                                 5'b00000  // S</pre>
<pre style="background-color: #FF0000;">                                ,5'b00000  // N</pre>
<pre style="background-color: #FF0000;">                                ,5'b10000  // E</pre>
<pre style="background-color: #FF0000;">                                ,5'b10000  // W</pre>
<pre style="background-color: #FF0000;">                                ,5'b00000  // P (output)</pre>
<pre style="background-color: #FF0000;">                               {//  SNEWP (output)</pre>
<pre style="background-color: #FF0000;">                                 5'b00110  // S</pre>
<pre style="background-color: #FF0000;">                                ,5'b00000  // N</pre>
<pre style="background-color: #FF0000;">                                ,5'b00000  // E</pre>
<pre style="background-color: #FF0000;">                                ,5'b00000  // W</pre>
<pre style="background-color: #FF0000;">                                ,5'b00000  // P (input)</pre>
<pre> localparam bit [1:0][4:0][4:0]  XY_Allow_N</pre>
<pre style="background-color: #FF0000;">                            = {</pre>
<pre style="background-color: #FF0000;">                               {//  SNEWP (input)</pre>
<pre style="background-color: #FF0000;">                                 5'b00000  // S</pre>
<pre style="background-color: #FF0000;">                                ,5'b00000  // N</pre>
<pre style="background-color: #FF0000;">                                ,5'b01000  // E</pre>
<pre style="background-color: #FF0000;">                                ,5'b01000  // W</pre>
<pre style="background-color: #FF0000;">                                ,5'b00000  // P (output)</pre>
<pre style="background-color: #FF0000;">                               {//  SNEWP (output)</pre>
<pre style="background-color: #FF0000;">                                 5'b00000  // S</pre>
<pre style="background-color: #FF0000;">                                ,5'b00110  // N</pre>
<pre style="background-color: #FF0000;">                                ,5'b00000  // E</pre>
<pre style="background-color: #FF0000;">                                ,5'b00000  // W</pre>
<pre style="background-color: #FF0000;">                                ,5'b00000  // P (input)</pre>
<pre> localparam bit</pre>
<pre>   [1:0][4:0][4:0] YX_Allow_W = {</pre>
<pre style="background-color: #FF0000;">                               {//  SNEWP (input)</pre>
<pre style="background-color: #FF0000;">                                 5'b00010  // S</pre>
<pre style="background-color: #FF0000;">                                ,5'b00010  // N</pre>
<pre style="background-color: #FF0000;">                                ,5'b00000  // E</pre>
<pre style="background-color: #FF0000;">                                ,5'b00000  // W</pre>
<pre style="background-color: #FF0000;">                                ,5'b00000  // P (output)</pre>
<pre style="background-color: #FF0000;">                               {//  SNEWP (output)</pre>
<pre style="background-color: #FF0000;">                                 5'b00000  // S</pre>
<pre style="background-color: #FF0000;">                                ,5'b00000  // N</pre>
<pre style="background-color: #FF0000;">                                ,5'b00000  // E</pre>
<pre style="background-color: #FF0000;">                                ,5'b11000  // W</pre>
<pre style="background-color: #FF0000;">                                ,5'b00000  // P (input)</pre>
<pre> localparam bit</pre>
<pre>   [1:0][4:0][4:0] YX_Allow_E = {</pre>
<pre style="background-color: #FF0000;">                               {//  SNEWP (input)</pre>
<pre style="background-color: #FF0000;">                                 5'b00100  // S</pre>
<pre style="background-color: #FF0000;">                                ,5'b00100  // N</pre>
<pre style="background-color: #FF0000;">                                ,5'b00000  // E</pre>
<pre style="background-color: #FF0000;">                                ,5'b00000  // W</pre>
<pre style="background-color: #FF0000;">                                ,5'b00000  // P (output)</pre>
<pre style="background-color: #FF0000;">                               {//  SNEWP (output)</pre>
<pre style="background-color: #FF0000;">                                 5'b00000  // S</pre>
<pre style="background-color: #FF0000;">                                ,5'b00000  // N</pre>
<pre style="background-color: #FF0000;">                                ,5'b11000  // E</pre>
<pre style="background-color: #FF0000;">                                ,5'b00000  // W</pre>
<pre style="background-color: #FF0000;">                                ,5'b00000  // P (input)</pre>
<h3>./bp_common/src/include/bp_common_pkg.vh</h3>
<pre>package bp_common_pkg;</pre>
<pre>   *   or a page fault exception will occur during translation.</pre>
<pre>   * Currently, we only support a very limited number of parameter configurations.</pre>
<pre>   * Thought: We could have a `define surrounding core instantiations of each parameter and then</pre>
<pre>  localparam bp_eaddr_width_gp = 64;</pre>
<pre>  localparam bp_instr_width_gp = 32;</pre>
<pre>  parameter bp_sv39_page_table_depth_gp = 3;</pre>
<pre>  parameter bp_sv39_pte_width_gp = 64;</pre>
<pre>  parameter bp_sv39_vaddr_width_gp = 39;</pre>
<pre>  parameter bp_sv39_paddr_width_gp = 56;</pre>
<pre>  parameter bp_sv39_ppn_width_gp = 44;</pre>
<pre>  parameter bp_page_offset_width_gp = `BSG_SAFE_CLOG2(bp_page_size_in_bytes_gp);</pre>
<pre></pre>
<pre>  parameter bp_data_cmd_num_flit_gp = 4;</pre>
<pre> </pre>
<pre> </pre>
<pre>  localparam cfg_link_dev_base_addr_gp = 32'h01??_????;</pre>
<pre>  localparam clint_dev_base_addr_gp    = 32'h02??_????;</pre>
<pre>  localparam host_dev_base_addr_gp     = 32'h03??_????;</pre>
<pre>  localparam plic_dev_base_addr_gp     = 32'h0c??_????;</pre>
<pre>  </pre>
<pre>  localparam mtimecmp_reg_base_addr_gp = 32'h0200_4???;</pre>
<pre>  localparam mtime_reg_addr_gp         = 32'h0200_bff8;</pre>
<pre>  localparam plic_reg_base_addr_gp     = 32'h0c00_0???;</pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<h3>./bp_fe/src/include/bp_fe_icache_pkg.vh</h3>
<pre>package bp_fe_icache_pkg;</pre>
<pre style="background-color: #FF0000;">endpackage : bp_fe_icache_pkg</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<h3>./bp_be/src/include/bp_be_pkg.vh</h3>
<pre>package bp_be_pkg;</pre>
<pre>  import bp_common_rv64_pkg::*;</pre>
<pre>  `include "bp_common_fe_be_if.vh"</pre>
<pre>  `include "bp_be_ctl_defines.vh"</pre>
<pre>  `include "bp_be_mem_defines.vh"</pre>
<pre>  `include "bp_be_internal_if_defines.vh"</pre>
<pre></pre>
<pre>endpackage : bp_be_pkg</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./bp_be/src/include/bp_be_dcache/bp_be_dcache_pkg.vh</h3>
<pre>package bp_be_dcache_pkg;</pre>
<pre>  typedef enum logic [3:0] {</pre>
<pre>    e_dcache_opcode_lbu  = 4'b0100  // load byte unsigned</pre>
<pre>    ,e_dcache_opcode_lhu = 4'b0101  // load half unsigned</pre>
<pre>    ,e_dcache_opcode_lwu = 4'b0110  // load word unsigned</pre>
<pre>    ,e_dcache_opcode_lb  = 4'b0000  // load byte</pre>
<pre>    ,e_dcache_opcode_lh  = 4'b0001  // load half</pre>
<pre>    ,e_dcache_opcode_lw  = 4'b0010  // load word</pre>
<pre>    ,e_dcache_opcode_ld  = 4'b0011  // load double</pre>
<pre>    ,e_dcache_opcode_sb  = 4'b1000  // store byte</pre>
<pre>    ,e_dcache_opcode_sh  = 4'b1001  // store half</pre>
<pre>    ,e_dcache_opcode_sw  = 4'b1010  // store word</pre>
<pre>    ,e_dcache_opcode_sd  = 4'b1011  // store double</pre>
<pre>    ,e_dcache_opcode_lrw = 4'b0111  // load reserved word</pre>
<pre>    ,e_dcache_opcode_scw = 4'b1100  // store conditional word</pre>
<pre>    ,e_dcache_opcode_lrd = 4'b1101  // load reserved double</pre>
<pre>    ,e_dcache_opcode_scd = 4'b1110  // store conditional double</pre>
<pre>  } bp_be_dcache_opcode_e;</pre>
<pre>  typedef enum logic [1:0] {</pre>
<pre>    e_dcache_lce_data_mem_write,</pre>
<pre>    e_dcache_lce_data_mem_read,</pre>
<pre>    e_dcache_lce_data_mem_uncached</pre>
<pre>  } bp_be_dcache_lce_data_mem_opcode_e;</pre>
<pre>  typedef enum logic [1:0] {</pre>
<pre>    e_dcache_lce_tag_mem_set_clear,</pre>
<pre>    e_dcache_lce_tag_mem_invalidate,</pre>
<pre>    e_dcache_lce_tag_mem_set_tag</pre>
<pre>  } bp_be_dcache_lce_tag_mem_opcode_e;</pre>
<pre>  typedef enum logic [1:0] {</pre>
<pre>    e_dcache_lce_stat_mem_set_clear,</pre>
<pre>    e_dcache_lce_stat_mem_read,</pre>
<pre>    e_dcache_lce_stat_mem_clear_dirty</pre>
<pre>  } bp_be_dcache_lce_stat_mem_opcode_e;</pre>
<pre>  typedef enum logic {</pre>
<pre>    e_dcache_lce_mode_uncached</pre>
<pre>    ,e_dcache_lce_mode_normal</pre>
<pre>  } bp_be_dcache_lce_mode_e;</pre>
<h3>./bp_top/src/include/bp_cfg_link_pkg.vh</h3>
<pre>package bp_cfg_link_pkg;</pre>
<pre>  localparam bp_cfg_base_addr_gp          = 'h0100_0000;</pre>
<pre>  localparam bp_cfg_reg_clk_osc_gp        = 'h0000;</pre>
<pre>  localparam bp_cfg_reg_reset_gp          = 'h0001;</pre>
<pre>  localparam bp_cfg_reg_freeze_gp         = 'h0002;</pre>
<pre>  localparam bp_cfg_reg_icache_mode_gp    = 'h0022;</pre>
<pre>  localparam bp_cfg_reg_start_pc_lo_gp    = 'h0040;</pre>
<pre>  localparam bp_cfg_reg_start_pc_hi_gp    = 'h0041;</pre>
<pre>  localparam bp_cfg_reg_dcache_mode_gp    = 'h0042;</pre>
<pre>  localparam bp_cfg_reg_cce_mode_gp       = 'h0060;</pre>
<pre>  localparam bp_cfg_reg_num_lce_gp        = 'h0061;</pre>
<pre>  localparam bp_cfg_mem_base_cce_ucode_gp = 'h8000;</pre>
<h3>./bp_me/src/include/v/bp_me_pkg.vh</h3>
<pre>package bp_me_pkg;</pre>
<pre style="background-color: #FF0000;">endpackage : bp_me_pkg</pre>
<h3>./bp_common/src/include/bp_common_aviary_pkg.vh</h3>
<pre>package bp_common_aviary_pkg;</pre>
<pre>  localparam lg_max_cfgs = `BSG_SAFE_CLOG2(max_cfgs);</pre>
<pre></pre>
<pre>    '{default: "inv"};</pre>
<pre></pre>
<pre>    '{num_core: 1</pre>
<pre>      ,num_cce: 1</pre>
<pre>      ,num_lce: 1</pre>
<pre></pre>
<pre>      ,paddr_width: 40</pre>
<pre>      ,asid_width : 1</pre>
<pre>      </pre>
<pre>      ,btb_tag_width            : 10</pre>
<pre>      ,btb_idx_width            : 6</pre>
<pre>      ,bht_idx_width            : 9</pre>
<pre>      ,ras_idx_width            : 2</pre>
<pre></pre>
<pre>      ,itlb_els             : 8</pre>
<pre>      ,dtlb_els             : 8</pre>
<pre>      </pre>
<pre>      ,lce_assoc            : 8</pre>
<pre>      ,cce_block_width      : 512</pre>
<pre>      ,num_cce_instr_ram_els: 256</pre>
<pre></pre>
<pre>      ,fe_queue_fifo_els: 8</pre>
<pre>      ,fe_cmd_fifo_els  : 2</pre>
<pre></pre>
<pre>      ,async_coh_clk       : 0</pre>
<pre>      ,coh_noc_flit_width  : 62</pre>
<pre>      ,coh_noc_cid_width   : 2</pre>
<pre>      ,coh_noc_len_width   : 5</pre>
<pre>      ,coh_noc_y_cord_width: 0</pre>
<pre>      ,coh_noc_x_cord_width: 1</pre>
<pre>      ,coh_noc_y_dim       : 1</pre>
<pre>      ,coh_noc_x_dim       : 1</pre>
<pre></pre>
<pre>      ,cfg_core_width: 8</pre>
<pre>      ,cfg_addr_width: 16</pre>
<pre>      ,cfg_data_width: 32</pre>
<pre></pre>
<pre>      ,mem_noc_max_credits   : 4</pre>
<pre>      ,mem_noc_flit_width    : 30</pre>
<pre>      ,mem_noc_reserved_width: 2</pre>
<pre>      ,mem_noc_cid_width     : 2</pre>
<pre>      ,mem_noc_len_width     : 5</pre>
<pre>      ,mem_noc_y_cord_width  : 0</pre>
<pre>      ,mem_noc_x_cord_width  : 8</pre>
<pre>      ,mem_noc_y_dim         : 1</pre>
<pre>      ,mem_noc_x_dim         : 1</pre>
<pre>      };</pre>
<pre></pre>
<pre>  localparam bp_proc_param_s bp_single_core_cfg_p = </pre>
<pre>    '{num_core: 1</pre>
<pre>      ,num_cce: 1</pre>
<pre>      ,num_lce: 2</pre>
<pre></pre>
<pre>      ,vaddr_width: 39</pre>
<pre>      ,paddr_width: 40</pre>
<pre>      ,asid_width : 1</pre>
<pre>      </pre>
<pre>      ,branch_metadata_fwd_width: 28</pre>
<pre>      ,btb_tag_width            : 10</pre>
<pre>      ,btb_idx_width            : 6</pre>
<pre>      ,bht_idx_width            : 9</pre>
<pre>      ,ras_idx_width            : 2</pre>
<pre>      </pre>
<pre>      ,dtlb_els             : 8</pre>
<pre>      </pre>
<pre>      ,lce_assoc            : 8</pre>
<pre>      ,cce_block_width      : 512</pre>
<pre>      ,num_cce_instr_ram_els: 256</pre>
<pre></pre>
<pre>      ,fe_cmd_fifo_els  : 2</pre>
<pre></pre>
<pre>      ,coh_noc_flit_width  : 62</pre>
<pre>      ,coh_noc_cid_width   : 2</pre>
<pre>      ,coh_noc_len_width   : 5</pre>
<pre>      ,coh_noc_y_cord_width: 1</pre>
<pre>      ,coh_noc_x_cord_width: 1</pre>
<pre>      ,coh_noc_y_dim       : 1</pre>
<pre>      ,coh_noc_x_dim       : 1</pre>
<pre></pre>
<pre>      ,cfg_addr_width: 16</pre>
<pre>      ,cfg_data_width: 32</pre>
<pre></pre>
<pre>      ,mem_noc_max_credits   : 4</pre>
<pre>      ,mem_noc_flit_width    : 30</pre>
<pre>      ,mem_noc_reserved_width: 2</pre>
<pre>      ,mem_noc_cid_width     : 5</pre>
<pre>      ,mem_noc_len_width     : 5</pre>
<pre>      ,mem_noc_y_cord_width  : 1</pre>
<pre>      ,mem_noc_x_cord_width  : 8</pre>
<pre>      ,mem_noc_y_dim         : 1</pre>
<pre>      ,mem_noc_x_dim         : 1</pre>
<pre>      };</pre>
<pre>    '{num_core: 2</pre>
<pre>      ,num_cce: 2</pre>
<pre>      ,num_lce: 4</pre>
<pre>      </pre>
<pre>      ,paddr_width: 40</pre>
<pre>      ,asid_width : 1</pre>
<pre>      </pre>
<pre>      ,btb_tag_width            : 10</pre>
<pre>      ,btb_idx_width            : 6</pre>
<pre>      ,bht_idx_width            : 9</pre>
<pre>      ,ras_idx_width            : 2</pre>
<pre>      </pre>
<pre>      ,dtlb_els             : 8</pre>
<pre>      </pre>
<pre>      ,lce_assoc            : 8</pre>
<pre>      ,cce_block_width      : 512</pre>
<pre>      ,num_cce_instr_ram_els: 256</pre>
<pre></pre>
<pre>      ,fe_cmd_fifo_els  : 2</pre>
<pre></pre>
<pre>      ,coh_noc_flit_width  : 62</pre>
<pre>      ,coh_noc_cid_width   : 2</pre>
<pre>      ,coh_noc_len_width   : 5</pre>
<pre>      ,coh_noc_y_cord_width: 1</pre>
<pre>      ,coh_noc_x_cord_width: 2</pre>
<pre>      ,coh_noc_y_dim       : 1</pre>
<pre>      ,coh_noc_x_dim       : 2</pre>
<pre></pre>
<pre>      ,cfg_addr_width: 16</pre>
<pre>      ,cfg_data_width: 32</pre>
<pre></pre>
<pre>      ,mem_noc_max_credits   : 4</pre>
<pre>      ,mem_noc_flit_width    : 30</pre>
<pre>      ,mem_noc_reserved_width: 2</pre>
<pre>      ,mem_noc_cid_width     : 2</pre>
<pre>      ,mem_noc_len_width     : 5</pre>
<pre>      ,mem_noc_y_cord_width  : 1</pre>
<pre>      ,mem_noc_x_cord_width  : 7</pre>
<pre>      ,mem_noc_y_dim         : 1</pre>
<pre>      ,mem_noc_x_dim         : 2</pre>
<pre>      };</pre>
<pre>    '{num_core: 4</pre>
<pre>      ,num_cce: 4</pre>
<pre>      ,num_lce: 8</pre>
<pre>      </pre>
<pre>      ,paddr_width: 40</pre>
<pre>      ,asid_width : 1</pre>
<pre>      </pre>
<pre>      ,btb_tag_width            : 10</pre>
<pre>      ,btb_idx_width            : 6</pre>
<pre>      ,bht_idx_width            : 9</pre>
<pre>      ,ras_idx_width            : 2</pre>
<pre>      </pre>
<pre>      ,dtlb_els             : 8</pre>
<pre>      </pre>
<pre>      ,lce_assoc            : 8</pre>
<pre>      ,cce_block_width      : 512</pre>
<pre>      ,num_cce_instr_ram_els: 256</pre>
<pre></pre>
<pre>      ,fe_cmd_fifo_els  : 2</pre>
<pre></pre>
<pre>      ,coh_noc_flit_width  : 62</pre>
<pre>      ,coh_noc_cid_width   : 2</pre>
<pre>      ,coh_noc_len_width   : 5</pre>
<pre>      ,coh_noc_y_cord_width: 1</pre>
<pre>      ,coh_noc_x_cord_width: 1</pre>
<pre>      ,coh_noc_y_dim       : 2</pre>
<pre>      ,coh_noc_x_dim       : 2</pre>
<pre></pre>
<pre>      ,cfg_addr_width: 16</pre>
<pre>      ,cfg_data_width: 32</pre>
<pre></pre>
<pre>      ,mem_noc_max_credits   : 4</pre>
<pre>      ,mem_noc_flit_width    : 30</pre>
<pre>      ,mem_noc_reserved_width: 2</pre>
<pre>      ,mem_noc_cid_width     : 2</pre>
<pre>      ,mem_noc_len_width     : 5</pre>
<pre>      ,mem_noc_y_cord_width  : 2</pre>
<pre>      ,mem_noc_x_cord_width  : 6</pre>
<pre>      ,mem_noc_y_dim         : 2</pre>
<pre>      ,mem_noc_x_dim         : 2</pre>
<pre>      };</pre>
<pre>    '{num_core: 8</pre>
<pre>      ,num_cce: 8</pre>
<pre>      ,num_lce: 16</pre>
<pre>      </pre>
<pre>      ,paddr_width: 40</pre>
<pre>      ,asid_width : 1</pre>
<pre>      </pre>
<pre>      ,btb_tag_width            : 10</pre>
<pre>      ,btb_idx_width            : 6</pre>
<pre>      ,bht_idx_width            : 9</pre>
<pre>      ,ras_idx_width            : 2</pre>
<pre>      </pre>
<pre>      ,dtlb_els             : 8</pre>
<pre>      </pre>
<pre>      ,lce_assoc            : 8</pre>
<pre>      ,cce_block_width      : 512</pre>
<pre>      ,num_cce_instr_ram_els: 256</pre>
<pre></pre>
<pre>      ,fe_cmd_fifo_els  : 2</pre>
<pre></pre>
<pre>      ,coh_noc_flit_width  : 62</pre>
<pre>      ,coh_noc_cid_width   : 2</pre>
<pre>      ,coh_noc_len_width   : 5</pre>
<pre>      ,coh_noc_y_cord_width: 0</pre>
<pre>      ,coh_noc_x_cord_width: 4</pre>
<pre>      ,coh_noc_y_dim       : 0</pre>
<pre>      ,coh_noc_x_dim       : 4</pre>
<pre></pre>
<pre>      ,cfg_addr_width: 16</pre>
<pre>      ,cfg_data_width: 32</pre>
<pre></pre>
<pre>      ,mem_noc_max_credits   : 4</pre>
<pre>      ,mem_noc_flit_width    : 30</pre>
<pre>      ,mem_noc_reserved_width: 2</pre>
<pre>      ,mem_noc_cid_width     : 2</pre>
<pre>      ,mem_noc_len_width     : 5</pre>
<pre>      ,mem_noc_y_cord_width  : 0</pre>
<pre>      ,mem_noc_x_cord_width  : 8</pre>
<pre>      ,mem_noc_y_dim         : 1</pre>
<pre>      ,mem_noc_x_dim         : 8</pre>
<pre>      };</pre>
<pre>    '{num_core: 16</pre>
<pre>      ,num_cce: 16</pre>
<pre>      ,num_lce: 32</pre>
<pre></pre>
<pre>      ,paddr_width: 40</pre>
<pre>      ,asid_width : 1</pre>
<pre></pre>
<pre>      ,btb_tag_width            : 10</pre>
<pre>      ,btb_idx_width            : 6</pre>
<pre>      ,bht_idx_width            : 9</pre>
<pre>      ,ras_idx_width            : 2</pre>
<pre></pre>
<pre>      ,dtlb_els             : 8</pre>
<pre>      </pre>
<pre>      ,lce_assoc            : 8</pre>
<pre>      ,cce_block_width      : 512</pre>
<pre>      ,num_cce_instr_ram_els: 256</pre>
<pre></pre>
<pre>      ,fe_cmd_fifo_els  : 2</pre>
<pre></pre>
<pre>      ,coh_noc_flit_width  : 62</pre>
<pre>      ,coh_noc_cid_width   : 2</pre>
<pre>      ,coh_noc_len_width   : 5</pre>
<pre>      ,coh_noc_y_cord_width: 0</pre>
<pre>      ,coh_noc_x_cord_width: 4</pre>
<pre>      ,coh_noc_y_dim       : 0</pre>
<pre>      ,coh_noc_x_dim       : 16</pre>
<pre></pre>
<pre>      ,cfg_addr_width: 16</pre>
<pre>      ,cfg_data_width: 32</pre>
<pre></pre>
<pre>      ,mem_noc_max_credits   : 4</pre>
<pre>      ,mem_noc_flit_width    : 30</pre>
<pre>      ,mem_noc_reserved_width: 2</pre>
<pre>      ,mem_noc_cid_width     : 2</pre>
<pre>      ,mem_noc_len_width     : 5</pre>
<pre>      ,mem_noc_y_cord_width  : 0</pre>
<pre>      ,mem_noc_x_cord_width  : 9</pre>
<pre>      ,mem_noc_y_dim         : 4</pre>
<pre>      ,mem_noc_x_dim         : 4</pre>
<pre>      };</pre>
<pre>  {</pre>
<pre>    ,e_bp_oct_core_cfg      = 5</pre>
<pre>    ,e_bp_quad_core_cfg     = 4</pre>
<pre>    ,e_bp_dual_core_cfg     = 3</pre>
<pre>    ,e_bp_single_core_cfg   = 2</pre>
<pre>    ,e_bp_half_core_cfg     = 1</pre>
<pre>    ,e_bp_inv_cfg           = 0</pre>
<pre>  } bp_cfg_e;</pre>
<pre></pre>
<pre>  {</pre>
<pre style="background-color: #FF0000;">    bp_sexta_core_cfg_p</pre>
<pre style="background-color: #FF0000;">    ,bp_oct_core_cfg_p</pre>
<pre style="background-color: #FF0000;">    ,bp_quad_core_cfg_p</pre>
<pre style="background-color: #FF0000;">    ,bp_dual_core_cfg_p</pre>
<pre style="background-color: #FF0000;">    ,bp_single_core_cfg_p</pre>
<pre style="background-color: #FF0000;">    ,bp_half_core_cfg_p</pre>
<pre style="background-color: #FF0000;">    ,bp_inv_cfg_p</pre>
<pre style="background-color: #FF0000;">  };</pre>
<h3>./bp_fe/src/include/bp_fe_pkg.vh</h3>
<pre>package bp_fe_pkg;</pre>
<pre>  `include "bsg_defines.v"</pre>
<pre>  `include "bp_fe_defines.vh"</pre>
<pre>  `include "bp_fe_icache.vh"</pre>
<pre>  `include "bp_fe_mem_defines.vh"</pre>
<pre></pre>
<pre style="background-color: #FF0000;">endpackage : bp_fe_pkg</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<h3>./bp_me/src/include/v/bp_cce_pkg.v</h3>
<pre>package bp_cce_pkg;</pre>
<pre>  typedef enum bit</pre>
<pre>    e_cce_mode_uncached = 1'b0</pre>
<pre>    ,e_cce_mode_normal  = 1'b1</pre>
<pre>  } bp_cce_mode_e;</pre>
<pre></pre>
<pre>  `define bp_cce_mode_bits $bits(bp_cce_mode_e)</pre>
<pre></pre>
<pre>  // Miss Status Handling Register Struct</pre>
<pre>  `define declare_bp_cce_mshr_s(num_lce_mp, lce_assoc_mp, paddr_width_mp) \</pre>
<pre style="background-color: #FF0000;">    logic [paddr_width_mp-1:0]                    paddr;                  \</pre>
<pre>    logic [`BSG_SAFE_CLOG2(lce_assoc_mp)-1:0]     way_id;                 \</pre>
<pre>    logic [paddr_width_mp-1:0]                    lru_paddr;              \</pre>
<pre>    logic [`BSG_SAFE_CLOG2(lce_assoc_mp)-1:0]     lru_way_id;             \</pre>
<pre>    logic [`BSG_SAFE_CLOG2(num_lce_mp)-1:0]       tr_lce_id;              \</pre>
<pre>    logic [`BSG_SAFE_CLOG2(lce_assoc_mp)-1:0]     tr_way_id;              \</pre>
<pre>    bp_coh_states_e                               next_coh_state;         \</pre>
<pre>    logic [`bp_cce_inst_num_flags-1:0]            flags;                  \</pre>
<pre>    bp_lce_cce_uc_req_size_e                      uc_req_size;            \</pre>
<pre>  } bp_cce_mshr_s</pre>
<pre></pre>
<pre>  `define bp_cce_mshr_width(num_lce_mp, lce_assoc_mp, paddr_width_mp) \</pre>
<pre></pre>
<pre>  // MSHR width for BP is:</pre>
<pre>  // 2*LOG(num_lce) + (9 + 78 + 3 + 15 + 2) = 2*LOG(num_lce) + 107</pre>
<pre></pre>
<pre>endpackage : bp_cce_pkg</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./external/basejump_stl/bsg_async/bsg_async_fifo.v</h3>
<pre>module bsg_async_fifo #(parameter   lg_size_p = "inv"</pre>
<pre>                        , parameter   width_p = "inv"</pre>
<pre>                        , parameter   control_width_p = 0)</pre>
<pre>    input    w_clk_i</pre>
<pre>    , input  w_reset_i</pre>
<pre>    , input  w_enq_i</pre>
<pre>    , input  [width_p-1:0] w_data_i</pre>
<pre>    , output w_full_o</pre>
<pre>    , input  r_clk_i</pre>
<pre>    , input  r_reset_i</pre>
<pre>    , input  r_deq_i</pre>
<pre>    , output [width_p-1:0] r_data_o</pre>
<pre>    , output r_valid_o</pre>
<pre>   localparam size_lp = 1 << lg_size_p;</pre>
<pre>   logic [lg_size_p:0] r_ptr_gray_r;</pre>
<pre>   logic [lg_size_p:0] w_ptr_gray_r;</pre>
<pre>   logic [lg_size_p:0] w_ptr_gray_r_rsync, r_ptr_gray_r_wsync, r_ptr_binary_r, w_ptr_binary_r;</pre>
<pre>   wire               r_valid_o_tmp; // remove inout warning from Lint</pre>
<pre>   assign r_valid_o = r_valid_o_tmp;</pre>
<pre style="background-color: #FF0000;">   bsg_mem_1r1w #(.width_p(width_p-control_width_p)</pre>
<pre style="background-color: #FF0000;">                  ,.els_p(size_lp)</pre>
<pre style="background-color: #FF0000;">		  ,.read_write_same_addr_p(0)</pre>
<pre style="background-color: #FF0000;">                  ) MSYNC_1r1w</pre>
<pre style="background-color: #FF0000;">     (.w_clk_i    (w_clk_i  )</pre>
<pre style="background-color: #FF0000;">      ,.w_reset_i (w_reset_i)</pre>
<pre style="background-color: #FF0000;">      ,.w_v_i   (w_enq_i                                  )</pre>
<pre style="background-color: #FF0000;">      ,.w_addr_i(w_ptr_binary_r[0+:lg_size_p]             )</pre>
<pre style="background-color: #FF0000;">      ,.w_data_i(w_data_i[0+:(width_p - control_width_p)] )</pre>
<pre style="background-color: #FF0000;">      ,.r_v_i   (r_valid_o_tmp                            )</pre>
<pre style="background-color: #FF0000;">      ,.r_addr_i(r_ptr_binary_r[0+:lg_size_p]             )</pre>
<pre style="background-color: #FF0000;">      ,.r_data_o(r_data_o[0+:(width_p - control_width_p)] )</pre>
<pre style="background-color: #FF0000;">   if (control_width_p > 0)</pre>
<pre style="background-color: #FF0000;">     begin : ctrl</pre>
<pre style="background-color: #FF0000;">        bsg_mem_1r1w #(.width_p(control_width_p)</pre>
<pre style="background-color: #FF0000;">                       ,.els_p(size_lp)</pre>
<pre style="background-color: #FF0000;">		       ,.read_write_same_addr_p(0)</pre>
<pre style="background-color: #FF0000;">                       ) MSYNC_1r1w</pre>
<pre style="background-color: #FF0000;">          (.w_clk_i   (w_clk_i  )</pre>
<pre style="background-color: #FF0000;">           ,.w_reset_i(w_reset_i)</pre>
<pre style="background-color: #FF0000;">           ,.w_v_i    (w_enq_i                           )</pre>
<pre style="background-color: #FF0000;">           ,.w_addr_i (w_ptr_binary_r[0+:lg_size_p]      )</pre>
<pre style="background-color: #FF0000;">           ,.w_data_i (w_data_i[(width_p-1)-:control_width_p])</pre>
<pre style="background-color: #FF0000;">           ,.r_v_i    (r_valid_o_tmp                     )</pre>
<pre style="background-color: #FF0000;">           ,.r_addr_i (r_ptr_binary_r[0+:lg_size_p]      )</pre>
<pre style="background-color: #FF0000;">           ,.r_data_o (r_data_o[(width_p-1)-:control_width_p])</pre>
<pre style="background-color: #FF0000;">   bsg_async_ptr_gray #(.lg_size_p(lg_size_p+1)) bapg_wr</pre>
<pre style="background-color: #FF0000;">   (.w_clk_i(w_clk_i)</pre>
<pre style="background-color: #FF0000;">    ,.w_reset_i(w_reset_i)</pre>
<pre style="background-color: #FF0000;">    ,.w_inc_i(w_enq_i)</pre>
<pre style="background-color: #FF0000;">    ,.r_clk_i(r_clk_i)</pre>
<pre style="background-color: #FF0000;">    ,.w_ptr_binary_r_o(w_ptr_binary_r)</pre>
<pre style="background-color: #FF0000;">    ,.w_ptr_gray_r_o(w_ptr_gray_r)</pre>
<pre style="background-color: #FF0000;">    ,.w_ptr_gray_r_rsync_o(w_ptr_gray_r_rsync)</pre>
<pre style="background-color: #FF0000;">   bsg_async_ptr_gray #(.lg_size_p(lg_size_p+1)) bapg_rd</pre>
<pre style="background-color: #FF0000;">   (.w_clk_i(r_clk_i)</pre>
<pre style="background-color: #FF0000;">    ,.w_reset_i(r_reset_i)</pre>
<pre style="background-color: #FF0000;">    ,.w_inc_i(r_deq_i)</pre>
<pre style="background-color: #FF0000;">    ,.r_clk_i(w_clk_i)</pre>
<pre style="background-color: #FF0000;">    ,.w_ptr_binary_r_o(r_ptr_binary_r)</pre>
<pre style="background-color: #FF0000;">    ,.w_ptr_gray_r_o(r_ptr_gray_r)  // after launch flop</pre>
<pre style="background-color: #FF0000;">    ,.w_ptr_gray_r_rsync_o(r_ptr_gray_r_wsync) // after sync flops</pre>
<pre>   assign r_valid_o_tmp = (r_ptr_gray_r != w_ptr_gray_r_rsync);</pre>
<pre>   assign w_full_o  = (w_ptr_gray_r == { ~r_ptr_gray_r_wsync[lg_size_p-:2]</pre>
<pre>                                         , r_ptr_gray_r_wsync[0+:lg_size_p-1] });</pre>
<pre>   always @(negedge w_clk_i)</pre>
<pre>     assert(!(w_full_o===1 && w_enq_i===1))   else $error("enqueing data on bsg_async_fifo when full");</pre>
<pre>   always @(negedge r_clk_i)</pre>
<pre>     assert(!(r_valid_o_tmp===0 && r_deq_i===1)) else $error("dequeing data on bsg_async_fifo when empty");</pre>
<h3>./external/basejump_stl/bsg_async/bsg_launch_sync_sync.v</h3>
<pre> `define rp_group(x)</pre>
<pre>  (input iclk_i                                                         \</pre>
<pre>   , input iclk_reset_i                                                 \</pre>
<pre>   , input oclk_i                                                       \</pre>
<pre>   , input  [bits-1:0] iclk_data_i                                      \</pre>
<pre>   , output [bits-1:0] iclk_data_o                                      \</pre>
<pre>   , output [bits-1:0] oclk_data_o                                      \</pre>
<pre>   );                                                                   \</pre>
<pre>                                                                        \</pre>
<pre>   always_ff @(EDGE iclk_i)                                             \</pre>
<pre>        `rp_group(blss_launch_1)                                        \</pre>
<pre>        else                                                            \</pre>
<pre>          bsg_SYNC_LNCH_r <= iclk_data_i;                               \</pre>
<pre>                                                                        \</pre>
<pre>                                                                        \</pre>
<pre>   assign oclk_data_o = bsg_SYNC_2_r;                                   \</pre>
<pre>   always_ff @(posedge oclk_i)                                          \</pre>
<pre>        `rp_group(blss_1)                                               \</pre>
<pre>                                                                        \</pre>
<pre>        `rp_group(blss_2)                                               \</pre>
<pre>endmodule</pre>
<pre>  (input iclk_i                                                         \</pre>
<pre>   , input iclk_reset_i                                                 \</pre>
<pre>   , input oclk_i                                                       \</pre>
<pre>   , input  [bits-1:0] iclk_data_i                                      \</pre>
<pre>   , output [bits-1:0] iclk_data_o                                      \</pre>
<pre>   , output [bits-1:0] oclk_data_o                                      \</pre>
<pre>   );                                                                   \</pre>
<pre>                                                                        \</pre>
<pre>   always_ff @(EDGE iclk_i or posedge iclk_reset_i)                     \</pre>
<pre>        `rp_group(blss_launch_1)                                        \</pre>
<pre>        else                                                            \</pre>
<pre>          bsg_SYNC_LNCH_r <= iclk_data_i;                               \</pre>
<pre>                                                                        \</pre>
<pre>                                                                        \</pre>
<pre>   assign oclk_data_o = bsg_SYNC_2_r;                                   \</pre>
<pre>   always_ff @(posedge oclk_i or posedge iclk_reset_i)                  \</pre>
<pre>        `rp_group(blss_1)                                               \</pre>
<pre>        else                                                            \</pre>
<pre>          bsg_SYNC_1_r <= bsg_SYNC_LNCH_r;                              \</pre>
<pre>                                                                        \</pre>
<pre>        `rp_group(blss_2)                                               \</pre>
<pre>        else                                                            \</pre>
<pre>          bsg_SYNC_2_r <= bsg_SYNC_1_r;                                 \</pre>
<pre>endmodule</pre>
<pre>                                        (.iclk_i                                     \</pre>
<pre>                                         ,.iclk_reset_i                              \</pre>
<pre>                                         ,.oclk_i                                    \</pre>
<pre>                                         ,.iclk_data_i(iclk_data_i[width_p-1-:num])  \</pre>
<pre>                                         ,.iclk_data_o(iclk_data_o[width_p-1-:num])  \</pre>
<pre>                                         ,.oclk_data_o(oclk_data_o[width_p-1-:num])  \</pre>
<pre>                                         ); end</pre>
<pre>										 </pre>
<pre style="background-color: #FF0000;">                                        (.iclk_i                                     \</pre>
<pre style="background-color: #FF0000;">                                         ,.iclk_reset_i                              \</pre>
<pre style="background-color: #FF0000;">                                         ,.oclk_i                                    \</pre>
<pre style="background-color: #FF0000;">                                         ,.iclk_data_i(iclk_data_i[width_p-1-:num])  \</pre>
<pre style="background-color: #FF0000;">                                         ,.iclk_data_o(iclk_data_o[width_p-1-:num])  \</pre>
<pre style="background-color: #FF0000;">                                         ,.oclk_data_o(oclk_data_o[width_p-1-:num])  \</pre>
<pre style="background-color: #FF0000;">                                         ); end</pre>
<pre style="background-color: #FF0000;"></pre>
<pre>module bsg_launch_sync_sync #(parameter width_p="inv"</pre>
<pre style="background-color: #FF0000;">                              , parameter use_negedge_for_launch_p = 0</pre>
<pre>                              , parameter use_async_reset_p = 0)</pre>
<pre>   (input iclk_i</pre>
<pre>    , input iclk_reset_i</pre>
<pre style="background-color: #FF0000;">    );</pre>
<pre style="background-color: #FF0000;">// synopsys translate_off</pre>
<pre style="background-color: #FF0000;">/*   initial</pre>
<pre style="background-color: #FF0000;">        for (i = 0; i < (width_p/`blss_max_block); i = i + 1)</pre>
<pre style="background-color: #FF0000;">          begin : maxb</pre>
<pre style="background-color: #FF0000;">             bsg_launch_sync_sync_negedge_8_unit blss</pre>
<pre style="background-color: #FF0000;">                 (.iclk_i</pre>
<pre style="background-color: #FF0000;">                  ,.iclk_reset_i</pre>
<pre style="background-color: #FF0000;">                  ,.oclk_i</pre>
<pre style="background-color: #FF0000;">                  ,.iclk_data_i(iclk_data_i[i*`blss_max_block+:`blss_max_block])</pre>
<pre style="background-color: #FF0000;">                  ,.iclk_data_o(iclk_data_o[i*`blss_max_block+:`blss_max_block])</pre>
<pre style="background-color: #FF0000;">                  ,.oclk_data_o(oclk_data_o[i*`blss_max_block+:`blss_max_block])</pre>
<pre style="background-color: #FF0000;">                  );</pre>
<pre style="background-color: #FF0000;">        for (i = 0; i < (width_p/`blss_max_block); i = i + 1)</pre>
<pre style="background-color: #FF0000;">          begin : maxb</pre>
<pre style="background-color: #FF0000;">             bsg_launch_sync_sync_posedge_8_unit blss</pre>
<pre style="background-color: #FF0000;">                 (.iclk_i</pre>
<pre style="background-color: #FF0000;">                  ,.iclk_reset_i</pre>
<pre style="background-color: #FF0000;">                  ,.oclk_i</pre>
<pre style="background-color: #FF0000;">                  ,.iclk_data_i(iclk_data_i[i*`blss_max_block+:`blss_max_block])</pre>
<pre style="background-color: #FF0000;">                  ,.iclk_data_o(iclk_data_o[i*`blss_max_block+:`blss_max_block])</pre>
<pre style="background-color: #FF0000;">                  ,.oclk_data_o(oclk_data_o[i*`blss_max_block+:`blss_max_block])</pre>
<pre style="background-color: #FF0000;">                  );</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">     begin: n</pre>
<pre style="background-color: #FF0000;">        for (i = 0; i < (width_p/`blss_max_block); i = i + 1)</pre>
<pre style="background-color: #FF0000;">          begin : maxb</pre>
<pre style="background-color: #FF0000;">             bsg_launch_sync_sync_async_reset_negedge_8_unit blss</pre>
<pre style="background-color: #FF0000;">                 (.iclk_i</pre>
<pre style="background-color: #FF0000;">                  ,.iclk_reset_i</pre>
<pre style="background-color: #FF0000;">                  ,.oclk_i</pre>
<pre style="background-color: #FF0000;">                  ,.iclk_data_i(iclk_data_i[i*`blss_max_block+:`blss_max_block])</pre>
<pre style="background-color: #FF0000;">                  ,.iclk_data_o(iclk_data_o[i*`blss_max_block+:`blss_max_block])</pre>
<pre style="background-color: #FF0000;">                  ,.oclk_data_o(oclk_data_o[i*`blss_max_block+:`blss_max_block])</pre>
<pre style="background-color: #FF0000;">                  );</pre>
<pre style="background-color: #FF0000;">        for (i = 0; i < (width_p/`blss_max_block); i = i + 1)</pre>
<pre style="background-color: #FF0000;">          begin : maxb</pre>
<pre style="background-color: #FF0000;">             bsg_launch_sync_sync_async_reset_posedge_8_unit blss</pre>
<pre style="background-color: #FF0000;">                 (.iclk_i</pre>
<pre style="background-color: #FF0000;">                  ,.iclk_reset_i</pre>
<pre style="background-color: #FF0000;">                  ,.oclk_i</pre>
<pre style="background-color: #FF0000;">                  ,.iclk_data_i(iclk_data_i[i*`blss_max_block+:`blss_max_block])</pre>
<pre style="background-color: #FF0000;">                  ,.iclk_data_o(iclk_data_o[i*`blss_max_block+:`blss_max_block])</pre>
<pre style="background-color: #FF0000;">                  ,.oclk_data_o(oclk_data_o[i*`blss_max_block+:`blss_max_block])</pre>
<pre style="background-color: #FF0000;">                  );</pre>
<h3>./external/basejump_stl/bsg_mem/bsg_cam_1r1w.v</h3>
<pre>module bsg_cam_1r1w</pre>
<pre>  #(parameter els_p               = "inv"</pre>
<pre>    ,parameter width_p            = "inv"</pre>
<pre>    ,parameter multiple_entries_p = "inv"</pre>
<pre>	,parameter find_empty_entry_p = "inv"</pre>
<pre>  )</pre>
<pre>   , input                        reset_i</pre>
<pre>   , input                        en_i</pre>
<pre></pre>
<pre>   , input                        w_set_not_clear_i</pre>
<pre>   , input [lg_els_lp-1:0]        w_addr_i</pre>
<pre>   , input [width_p-1:0]          w_data_i</pre>
<pre>   </pre>
<pre>   , input [width_p-1:0]          r_data_i</pre>
<pre>   </pre>
<pre>   , output logic [lg_els_lp-1:0] r_addr_o</pre>
<pre>   </pre>
<pre>   , output logic [lg_els_lp-1:0] empty_addr_o</pre>
<pre>  );</pre>
<pre>  logic [els_p-1:0]   match_array, empty_array;</pre>
<pre>  logic [els_p-1:0]   valid;</pre>
<pre>  logic               matched, empty_found;</pre>
<pre>  </pre>
<pre>  assign empty_v_o = en_i & empty_found;</pre>
<pre>   </pre>
<pre>    if (reset_i) begin: fi</pre>
<pre>      valid <= '0;</pre>
<pre>    end </pre>
<pre>      //w_set_not_clear_i=1 sets the valid bit and</pre>
<pre>      mem[w_addr_i]   <= w_data_i;</pre>
<pre>    end</pre>
<pre style="background-color: #FF0000;">  for (i = 0; i < els_p; i++) begin: rof</pre>
<pre>    assign  match_array[i] = ~reset_i & en_i & (mem[i] == r_data_i) & valid[i];</pre>
<pre>	assign  empty_array[i] = ~reset_i & en_i & ~valid[i];</pre>
<pre>  end</pre>
<pre style="background-color: #FF0000;">    if(multiple_entries_p) begin: fi3</pre>
<pre style="background-color: #FF0000;">      //If multiple_entries_p is 1, the match_array is sent to the</pre>
<pre style="background-color: #FF0000;">        #(.width_p (els_p)</pre>
<pre style="background-color: #FF0000;">          ,.lo_to_hi_p (1)</pre>
<pre style="background-color: #FF0000;">        ) pe</pre>
<pre style="background-color: #FF0000;">        (.i (match_array)</pre>
<pre style="background-color: #FF0000;">         ,.addr_o (r_addr_o)</pre>
<pre style="background-color: #FF0000;">         ,.v_o (matched)</pre>
<pre style="background-color: #FF0000;">        );</pre>
<pre style="background-color: #FF0000;">      //If multiple_entries_p is 0, the match_array is sent to the</pre>
<pre>        #(.width_p (els_p)</pre>
<pre>          ,.lo_to_hi_p (1)</pre>
<pre>        ) ohe</pre>
<pre style="background-color: #FF0000;">        (.i (match_array)</pre>
<pre>         ,.addr_o (r_addr_o)</pre>
<pre>         ,.v_o (matched)</pre>
<pre>        );</pre>
<pre style="background-color: #FF0000;">    if(find_empty_entry_p) begin: fi5</pre>
<pre>	// If find_empty_entry_p is 1, finds the first empty entry in the cam,</pre>
<pre>        #(.width_p(els_p)</pre>
<pre>          ,.lo_to_hi_p(1)</pre>
<pre>        ) epe</pre>
<pre style="background-color: #FF0000;">        (.i(empty_array)</pre>
<pre>         ,.addr_o(empty_addr_o)</pre>
<pre>         ,.v_o(empty_found)</pre>
<pre>        );</pre>
<pre style="background-color: #FF0000;">	// Otherwise, sets empty_v_o and empty_addr_o to zero</pre>
<pre>	  assign empty_addr_o = '0;</pre>
<pre>	end</pre>
<pre>    if (~multiple_entries_p & ~reset_i & en_i & r_v_i) begin: fi_debug1</pre>
<pre>      assert($countones(match_array) <= 1)</pre>
<pre>        else $error("Multiple similar entries are found in match_array\</pre>
<pre>                    %x while multiple_entries_p parameter is %d\n", match_array,</pre>
<pre>                    multiple_entries_p);       </pre>
<pre>    end</pre>
<pre>	  assert(w_addr_i < els_p)</pre>
<pre>        else $error("Invalid address %x of size %x\n", w_addr_i, els_p);</pre>
<pre>	end</pre>
<h3>./external/basejump_stl/bsg_async/bsg_async_ptr_gray.v</h3>
<pre>module bsg_async_ptr_gray #(parameter lg_size_p = -1</pre>
<pre>                            ,parameter use_negedge_for_launch_p=0</pre>
<pre>                            ,parameter use_async_reset_p = 0)</pre>
<pre>    input w_clk_i</pre>
<pre>    , input w_reset_i</pre>
<pre>    , input w_inc_i               // increment pointer</pre>
<pre>    , input r_clk_i</pre>
<pre>    , output [lg_size_p-1:0] w_ptr_binary_r_o     // ptr value; binary</pre>
<pre>    , output [lg_size_p-1:0] w_ptr_gray_r_o       // same; gray coded; value before synchronizers</pre>
<pre>    , output [lg_size_p-1:0] w_ptr_gray_r_rsync_o // value after  synchronizers</pre>
<pre>   logic [lg_size_p-1:0] w_ptr_r,      w_ptr_n;</pre>
<pre>   logic [lg_size_p-1:0] w_ptr_p1_r,   w_ptr_p1_n, w_ptr_p2;</pre>
<pre>   logic [lg_size_p-1:0] w_ptr_gray_n, w_ptr_gray_r, w_ptr_gray_r_rsync;</pre>
<pre>   assign w_ptr_p2     = w_ptr_p1_r + 1'b1;</pre>
<pre>   assign w_ptr_n      = w_inc_i ? w_ptr_p1_r : w_ptr_r;</pre>
<pre>   assign w_ptr_p1_n   = w_inc_i ? w_ptr_p2   : w_ptr_p1_r;</pre>
<pre>   assign w_ptr_gray_n = w_inc_i ? ((w_ptr_p1_r >> 1) ^ w_ptr_p1_r) : w_ptr_gray_r;</pre>
<pre style="background-color: #FF0000;">   if (use_async_reset_p == 0) begin: sync</pre>
<pre style="background-color: #FF0000;">   if (use_negedge_for_launch_p)</pre>
<pre style="background-color: #FF0000;">     begin</pre>
<pre style="background-color: #FF0000;">        always @(negedge w_clk_i)</pre>
<pre style="background-color: #FF0000;">          if (w_reset_i)</pre>
<pre style="background-color: #FF0000;">            begin</pre>
<pre style="background-color: #FF0000;">               w_ptr_r    <= 0;</pre>
<pre style="background-color: #FF0000;">               w_ptr_p1_r <= 1;</pre>
<pre style="background-color: #FF0000;">            begin</pre>
<pre style="background-color: #FF0000;">               w_ptr_r    <= w_ptr_n;</pre>
<pre style="background-color: #FF0000;">               w_ptr_p1_r <= w_ptr_p1_n;</pre>
<pre style="background-color: #FF0000;">     begin</pre>
<pre style="background-color: #FF0000;">        always @(posedge w_clk_i)</pre>
<pre style="background-color: #FF0000;">          if (w_reset_i)</pre>
<pre style="background-color: #FF0000;">            begin</pre>
<pre style="background-color: #FF0000;">               w_ptr_r    <= 0;</pre>
<pre style="background-color: #FF0000;">               w_ptr_p1_r <= 1;</pre>
<pre style="background-color: #FF0000;">            begin</pre>
<pre style="background-color: #FF0000;">               w_ptr_r    <= w_ptr_n;</pre>
<pre style="background-color: #FF0000;">               w_ptr_p1_r <= w_ptr_p1_n;</pre>
<pre style="background-color: #FF0000;">   else begin: async</pre>
<pre style="background-color: #FF0000;">   if (use_negedge_for_launch_p)</pre>
<pre style="background-color: #FF0000;">     begin : BSG_NO_CLOCK_GATE_1</pre>
<pre style="background-color: #FF0000;">	logic  [lg_size_p-1:0] async_reset_w_ptr_r;</pre>
<pre style="background-color: #FF0000;">	logic  [lg_size_p-1:0] async_reset_w_ptr_p1_r;</pre>
<pre style="background-color: #FF0000;">	assign w_ptr_r    = async_reset_w_ptr_r;</pre>
<pre style="background-color: #FF0000;">	assign w_ptr_p1_r = async_reset_w_ptr_p1_r;</pre>
<pre style="background-color: #FF0000;">        always @(negedge w_clk_i or posedge w_reset_i)</pre>
<pre style="background-color: #FF0000;">          if (w_reset_i)</pre>
<pre style="background-color: #FF0000;">            begin</pre>
<pre style="background-color: #FF0000;">               async_reset_w_ptr_r    <= 0;</pre>
<pre style="background-color: #FF0000;">               async_reset_w_ptr_p1_r <= 1;</pre>
<pre style="background-color: #FF0000;">            begin</pre>
<pre style="background-color: #FF0000;">               async_reset_w_ptr_r    <= w_ptr_n;</pre>
<pre style="background-color: #FF0000;">               async_reset_w_ptr_p1_r <= w_ptr_p1_n;</pre>
<pre style="background-color: #FF0000;">     begin : BSG_NO_CLOCK_GATE_2</pre>
<pre style="background-color: #FF0000;">	logic  [lg_size_p-1:0] async_reset_w_ptr_r;</pre>
<pre style="background-color: #FF0000;">	logic  [lg_size_p-1:0] async_reset_w_ptr_p1_r;</pre>
<pre style="background-color: #FF0000;">	assign w_ptr_r    = async_reset_w_ptr_r;</pre>
<pre style="background-color: #FF0000;">	assign w_ptr_p1_r = async_reset_w_ptr_p1_r;</pre>
<pre style="background-color: #FF0000;">        always @(posedge w_clk_i or posedge w_reset_i)</pre>
<pre style="background-color: #FF0000;">          if (w_reset_i)</pre>
<pre style="background-color: #FF0000;">            begin</pre>
<pre style="background-color: #FF0000;">               async_reset_w_ptr_r    <= 0;</pre>
<pre style="background-color: #FF0000;">               async_reset_w_ptr_p1_r <= 1;</pre>
<pre style="background-color: #FF0000;">            begin</pre>
<pre style="background-color: #FF0000;">               async_reset_w_ptr_r    <= w_ptr_n;</pre>
<pre style="background-color: #FF0000;">               async_reset_w_ptr_p1_r <= w_ptr_p1_n;</pre>
<pre>   assign w_ptr_binary_r_o = w_ptr_r;</pre>
<pre style="background-color: #FF0000;">   bsg_launch_sync_sync #(.width_p(lg_size_p)</pre>
<pre style="background-color: #FF0000;">                          ,.use_negedge_for_launch_p(use_negedge_for_launch_p)</pre>
<pre style="background-color: #FF0000;">                          ,.use_async_reset_p(use_async_reset_p)) ptr_sync</pre>
<pre style="background-color: #FF0000;">      .iclk_i(w_clk_i)</pre>
<pre style="background-color: #FF0000;">      ,.iclk_reset_i(w_reset_i)</pre>
<pre style="background-color: #FF0000;">      ,.oclk_i(r_clk_i)</pre>
<pre style="background-color: #FF0000;">      ,.iclk_data_i(w_ptr_gray_n)</pre>
<pre style="background-color: #FF0000;">      ,.iclk_data_o(w_ptr_gray_r)</pre>
<pre style="background-color: #FF0000;">      ,.oclk_data_o(w_ptr_gray_r_rsync)</pre>
<pre>   assign w_ptr_gray_r_o       = w_ptr_gray_r;</pre>
<pre>   assign w_ptr_gray_r_rsync_o = w_ptr_gray_r_rsync;</pre>
<h3>./external/basejump_stl/bsg_dataflow/bsg_fifo_1r1w_large.v</h3>
<pre>module bsg_fifo_1r1w_large #(parameter width_p           = -1</pre>
<pre>                             , parameter els_p           = -1</pre>
<pre>   (input                  clk_i</pre>
<pre>    , input                reset_i</pre>
<pre>    , input [width_p-1:0]  data_i</pre>
<pre>    , input                v_i</pre>
<pre>    , output               ready_o</pre>
<pre>    , output               v_o</pre>
<pre>    , output [width_p-1:0] data_o</pre>
<pre>    , input                yumi_i</pre>
<pre>   initial assert ((els_p & 1) == 0) else</pre>
<pre>     $error("odd number of elements for two port fifo not handled.");</pre>
<pre>   wire [width_p*2-1:0] data_sipo;</pre>
<pre>   wire [1:0]          valid_sipo;</pre>
<pre>   wire [1:0]          yumi_cnt_sipo;</pre>
<pre>   bsg_serial_in_parallel_out #(.width_p(width_p)</pre>
<pre>                                ,.els_p(3)</pre>
<pre>                                ,.out_els_p(2)</pre>
<pre style="background-color: #FF0000;">                                ) sipo</pre>
<pre>   (.clk_i      (clk_i)</pre>
<pre>    ,.reset_i   (reset_i)</pre>
<pre>    ,.valid_i   (v_i)</pre>
<pre>    ,.data_i    (data_i)</pre>
<pre>    ,.ready_o   (ready_o)</pre>
<pre>    ,.valid_o   (valid_sipo)</pre>
<pre>    ,.data_o    (data_sipo)</pre>
<pre>    ,.yumi_cnt_i(yumi_cnt_sipo)</pre>
<pre>   wire [2*width_p-1:0] big_data_lo;</pre>
<pre>   wire                 big_valid, big_full_lo, big_empty_lo;</pre>
<pre>   logic                big_enq, big_deq,   big_deq_r;</pre>
<pre>   always_ff @(posedge clk_i)</pre>
<pre>     big_deq_r <= big_deq;</pre>
<pre>   bsg_fifo_1rw_large #(.width_p(width_p*2)</pre>
<pre>                        ,.els_p (els_p >> 1)</pre>
<pre style="background-color: #FF0000;">                        ) big1p</pre>
<pre>     (.clk_i         (clk_i       )</pre>
<pre>      ,.reset_i      (reset_i     )</pre>
<pre>      ,.data_i       (data_sipo )</pre>
<pre>      ,.v_i          (big_valid)</pre>
<pre>      ,.enq_not_deq_i(big_enq)</pre>
<pre>      ,.full_o   (big_full_lo )</pre>
<pre>      ,.empty_o  (big_empty_lo)</pre>
<pre>      ,.data_o   (big_data_lo )</pre>
<pre>   wire [2*width_p-1:0] little_data_rot;</pre>
<pre>   wire [1:0]           little_valid, little_ready;</pre>
<pre>   wire [1:0]           little_ready_rot, little_valid_rot;</pre>
<pre>   wire [1:0]           valid_int;</pre>
<pre>   wire bypass_mode    = ~big_deq_r & little_ready[0] & big_empty_lo;</pre>
<pre>   wire can_spill     = ~big_full_lo & ~bypass_mode;</pre>
<pre>   wire emergency     = (&little_ready_rot) & ~big_empty_lo & ~big_deq_r;</pre>
<pre>   wire will_spill    = can_spill & (&valid_sipo) & ~emergency;</pre>
<pre>   assign big_deq     = ~will_spill & ~big_empty_lo</pre>
<pre>                        & (big_deq_r</pre>
<pre>                           ? (~|valid_int)         // small fifos are empty</pre>
<pre>                           : (&little_ready_rot)); // both fifos > 1 el free, no enq pending</pre>
<pre>   assign big_valid = will_spill | big_deq;</pre>
<pre>   assign big_enq   = will_spill;</pre>
<pre>   wire [2*width_p-1:0] little_data  = big_deq_r ? big_data_lo : data_sipo;</pre>
<pre>   wire [1:0] bypass_vector = valid_sipo & { bypass_mode, bypass_mode };</pre>
<pre>   assign               little_valid = big_deq_r ? 2'b11       : bypass_vector;</pre>
<pre>   wire [1:0]           cnt;</pre>
<pre>   bsg_thermometer_count #(.width_p(2)) thermo(.i(little_ready & bypass_vector)</pre>
<pre>                                               ,.o(cnt));</pre>
<pre>   assign yumi_cnt_sipo = will_spill</pre>
<pre>                          ? 2'b10</pre>
<pre>                          : cnt;</pre>
<pre>   bsg_round_robin_2_to_2 #(.width_p(width_p))</pre>
<pre style="background-color: #FF0000;">     rr222</pre>
<pre>       (.clk_i(clk_i)</pre>
<pre>        ,.reset_i(reset_i)</pre>
<pre>        ,.data_i(little_data)</pre>
<pre>        ,.v_i    (little_valid)</pre>
<pre>        ,.ready_o(little_ready)</pre>
<pre>        ,.data_o(little_data_rot)</pre>
<pre>        ,.v_o   (little_valid_rot)</pre>
<pre>        ,.ready_i(little_ready_rot)</pre>
<pre>   wire [1:0][width_p-1:0] data_int;</pre>
<pre>   wire [1:0]           yumi_int;</pre>
<pre style="background-color: #FF0000;">   genvar               i;</pre>
<pre>   for (i = 0; i < 2; i++)</pre>
<pre>     begin : twofer</pre>
<pre>        bsg_two_fifo #(.width_p(width_p)) little</pre>
<pre>            (.clk_i   (clk_i)</pre>
<pre>             ,.reset_i(reset_i)</pre>
<pre>             ,.ready_o(little_ready_rot[i]                 )</pre>
<pre>             ,.data_i (little_data_rot [i*width_p+:width_p])</pre>
<pre>             ,.v_i    (little_valid_rot[i]                 )</pre>
<pre>             ,.v_o    (valid_int [i])</pre>
<pre>             ,.data_o (data_int  [i])</pre>
<pre>             ,.yumi_i (yumi_int  [i])</pre>
<pre>  bsg_round_robin_n_to_1 #(.width_p(width_p)</pre>
<pre>                            ,.num_in_p(2)</pre>
<pre>			    ,.strict_p(1)</pre>
<pre style="background-color: #FF0000;">                            ) round_robin_n_to_1</pre>
<pre>     (.clk_i   (clk_i     )</pre>
<pre>      ,.reset_i(reset_i   )</pre>
<pre>      ,.data_i (data_int )</pre>
<pre>      ,.v_i(valid_int)</pre>
<pre>      ,.yumi_o (yumi_int )</pre>
<pre>      ,.data_o (data_o    )</pre>
<pre>      ,.v_o(v_o       )</pre>
<pre>      ,.tag_o  ()</pre>
<pre>      ,.yumi_i (yumi_i    )</pre>
<pre>   wire [31:0] num_elements_debug</pre>
<pre>               = 2*big1p.num_elements_debug</pre>
<pre>               + valid_int[0] + valid_int[1]</pre>
<pre>               + sipo.valid_r[0] + sipo.valid_r[1]</pre>
<pre>               + !little_ready_rot[0] + !little_ready_rot[1];</pre>
<h3>./external/basejump_stl/bsg_dataflow/bsg_serial_in_parallel_out.v</h3>
<pre>module bsg_serial_in_parallel_out #(parameter   width_p   = -1</pre>
<pre>                                    , parameter els_p     = -1</pre>
<pre>                                    , parameter out_els_p = els_p)</pre>
<pre>   (input                 clk_i</pre>
<pre>    , input               reset_i</pre>
<pre>    , input               valid_i</pre>
<pre>    , input [width_p-1:0] data_i</pre>
<pre>    , output              ready_o</pre>
<pre>    , output logic [out_els_p-1:0]                valid_o</pre>
<pre>    , output logic [out_els_p-1:0][width_p-1:0]   data_o</pre>
<pre>    , input  [$clog2(out_els_p+1)-1:0]        yumi_cnt_i</pre>
<pre>   localparam double_els_lp = els_p * 2;</pre>
<pre>   logic [els_p-1:0][width_p-1:0] data_r, data_nn;</pre>
<pre>   logic [2*els_p-1:0  ][width_p-1:0] data_n;</pre>
<pre>   logic [els_p-1:0] 		  valid_r, valid_nn;</pre>
<pre>   logic [double_els_lp-1:0] 	  valid_n;</pre>
<pre>   logic [$clog2(els_p+1)-1:0]    num_els_r, num_els_n;</pre>
<pre>   always_ff @(posedge clk_i)</pre>
<pre>     begin</pre>
<pre>        if (reset_i)</pre>
<pre>          begin</pre>
<pre>             num_els_r <= 0;</pre>
<pre>             valid_r   <= 0;</pre>
<pre>          begin</pre>
<pre>             num_els_r <= num_els_n;</pre>
<pre>             valid_r   <= valid_nn;</pre>
<pre>  always_ff @(posedge clk_i) begin</pre>
<pre>     data_r <= data_nn;</pre>
<pre>  assign ready_o = ~valid_r[els_p-1];</pre>
<pre>  assign num_els_n = (num_els_r + (valid_i & ready_o)) - yumi_cnt_i;</pre>
<pre>  always_comb begin</pre>
<pre>    data_n  = data_r;</pre>
<pre>    valid_n = (double_els_lp) ' (valid_r);</pre>
<pre>	  data_n[els_p+:els_p] = 0;</pre>
<pre>    data_n [num_els_r] = data_i;</pre>
<pre>    valid_n[num_els_r] = valid_i & ready_o;</pre>
<pre>    valid_o = valid_n[out_els_p-1:0];</pre>
<pre>    data_o  = data_n [out_els_p-1:0];</pre>
<pre>	  for (integer i = 0; i < els_p; i++) begin</pre>
<pre>	    data_nn[i] = data_n[yumi_cnt_i+i];</pre>
<pre>	  valid_nn = valid_n[yumi_cnt_i+:els_p];</pre>
<h3>./external/basejump_stl/bsg_dataflow/bsg_channel_tunnel.v</h3>
<pre>module bsg_channel_tunnel #(parameter width_p        = 1</pre>
<pre>                            , num_in_p               = "inv"</pre>
<pre>                            , remote_credits_p       = "inv"</pre>
<pre>                            , use_pseudo_large_fifo_p = 0</pre>
<pre>                            , lg_credit_decimation_p = `BSG_MIN(lg_remote_credits_lp,4)</pre>
<pre>                            , tag_width_lp           = $clog2(num_in_p+1)</pre>
<pre>                            , tagged_width_lp        = tag_width_lp + width_p</pre>
<pre></pre>
<pre>    ,input reset_i</pre>
<pre></pre>
<pre>    ,input  multi_v_i</pre>
<pre>    ,output multi_yumi_o</pre>
<pre></pre>
<pre>    , output multi_v_o</pre>
<pre>    , input  multi_yumi_i</pre>
<pre></pre>
<pre>    , input  [num_in_p-1:0] v_i</pre>
<pre>    , output [num_in_p-1:0] yumi_o</pre>
<pre></pre>
<pre>    , output [num_in_p-1:0]             v_o</pre>
<pre>    , input  [num_in_p-1:0]              yumi_i</pre>
<pre>    );</pre>
<pre style="background-color: #FF0000;">     assert(lg_credit_decimation_p <= lg_remote_credits_lp)</pre>
<pre>       else</pre>
<pre style="background-color: #FF0000;">         begin</pre>
<pre>            $error("%m bad params; insufficient remote credits 2^%d to allow for decimation factor 2^%d"</pre>
<pre>                   ,lg_remote_credits_lp,lg_credit_decimation_p);</pre>
<pre>            $finish;</pre>
<pre>         end</pre>
<pre style="background-color: #FF0000;">     assert(width_p >= num_in_p*lg_remote_credits_lp)</pre>
<pre>       else</pre>
<pre style="background-color: #FF0000;">         begin</pre>
<pre>            $error("%m bad params; channel width (%d) must be at least wide enough to route back credits (%d)"</pre>
<pre>                   ,width_p</pre>
<pre>                   ,num_in_p*lg_remote_credits_lp);</pre>
<pre>            $finish;</pre>
<pre>         end</pre>
<pre>   wire                                          credit_local_return_v_oi;</pre>
<pre></pre>
<pre>   wire                                          credit_remote_return_yumi_io;</pre>
<pre></pre>
<pre>                            ,.num_in_p              (num_in_p)</pre>
<pre>                            ,.remote_credits_p      (remote_credits_p)</pre>
<pre>                            ,.lg_credit_decimation_p(lg_credit_decimation_p)</pre>
<pre>                            ) bcto</pre>
<pre style="background-color: #FF0000;">     (.clk_i</pre>
<pre>      ,.reset_i</pre>
<pre></pre>
<pre>      ,.v_i</pre>
<pre>      ,.yumi_o</pre>
<pre></pre>
<pre>      ,.v_o(multi_v_o)</pre>
<pre>      ,.yumi_i (multi_yumi_i )</pre>
<pre></pre>
<pre>      ,.credit_local_return_v_i    (credit_local_return_v_oi    )</pre>
<pre>      ,.credit_remote_return_data_i(credit_remote_return_data_oi)</pre>
<pre>      ,.credit_remote_return_yumi_o(credit_remote_return_yumi_io)</pre>
<pre>      );</pre>
<pre>                           ,.num_in_p              (num_in_p )</pre>
<pre>                           ,.remote_credits_p      (remote_credits_p)</pre>
<pre>                           ,.use_pseudo_large_fifo_p(use_pseudo_large_fifo_p)</pre>
<pre>                           ,.lg_credit_decimation_p(lg_credit_decimation_p)</pre>
<pre>                           ) bcti</pre>
<pre style="background-color: #FF0000;">     (.clk_i</pre>
<pre>      ,.reset_i</pre>
<pre></pre>
<pre>      ,.v_i    (multi_v_i)</pre>
<pre>      ,.yumi_o (multi_yumi_o )</pre>
<pre></pre>
<pre>      ,.v_o</pre>
<pre>      ,.yumi_i</pre>
<pre></pre>
<pre>      ,.credit_local_return_v_o    (credit_local_return_v_oi    )</pre>
<pre>      ,.credit_remote_return_data_o(credit_remote_return_data_oi)</pre>
<pre>      ,.credit_remote_return_yumi_i(credit_remote_return_yumi_io)</pre>
<pre>      );</pre>
<h3>./external/basejump_stl/bsg_dataflow/bsg_channel_tunnel_out.v</h3>
<pre>module bsg_channel_tunnel_out #(</pre>
<pre>                                parameter  width_p = -1</pre>
<pre>                                , num_in_p = "inv"</pre>
<pre>                                , remote_credits_p = "inv"</pre>
<pre>                                , lg_credit_decimation_p = 4</pre>
<pre>                                , tag_width_lp        = $clog2(num_in_p+1)</pre>
<pre>                                , tagged_width_lp     = tag_width_lp+width_p</pre>
<pre>                                , lg_remote_credits_lp = $clog2(remote_credits_p+1)</pre>
<pre>   (input  clk_i</pre>
<pre>    , input  reset_i</pre>
<pre>    , input  [num_in_p-1:0][width_p-1:0] data_i</pre>
<pre>    , input  [num_in_p-1:0] v_i</pre>
<pre>    , output [num_in_p-1:0] yumi_o</pre>
<pre>    , output [tagged_width_lp-1:0] data_o</pre>
<pre>    , output v_o</pre>
<pre>    , input  yumi_i</pre>
<pre>    , input [num_in_p-1:0][lg_remote_credits_lp-1:0] credit_local_return_data_i</pre>
<pre>    , input credit_local_return_v_i</pre>
<pre>    , input [num_in_p-1:0][lg_remote_credits_lp-1:0] credit_remote_return_data_i</pre>
<pre>    , output credit_remote_return_yumi_o</pre>
<pre style="background-color: #FF0000;">   initial</pre>
<pre>     begin</pre>
<pre>        assert(remote_credits_p >= (1 << lg_credit_decimation_p))</pre>
<pre>          else $error("%m remote_credits_p is smaller than credit decimation factor!");</pre>
<pre style="background-color: #FF0000;">   genvar i;</pre>
<pre>   logic [num_in_p-1:0][lg_remote_credits_lp-1:0] local_credits;</pre>
<pre>   logic [num_in_p-1:0]                          local_credits_avail, remote_credits_avail;</pre>
<pre style="background-color: #FF0000;">   initial</pre>
<pre>      assert (width_p >= num_in_p*lg_remote_credits_lp)</pre>
<pre>        else $error("%m not enough room in packet to transmit all credit counters");</pre>
<pre style="background-color: #FF0000;">   for (i = 0; i < num_in_p; i=i+1)</pre>
<pre style="background-color: #FF0000;">     begin: rof</pre>
<pre style="background-color: #FF0000;">        bsg_counter_up_down_variable #(.max_val_p  (remote_credits_p)</pre>
<pre style="background-color: #FF0000;">                                       ,.init_val_p(remote_credits_p)</pre>
<pre style="background-color: #FF0000;">                                       ,.max_step_p(remote_credits_p)</pre>
<pre style="background-color: #FF0000;">                                       ) bcudv</pre>
<pre style="background-color: #FF0000;">        (.clk_i</pre>
<pre style="background-color: #FF0000;">         ,.reset_i</pre>
<pre style="background-color: #FF0000;">         ,.up_i    ( credit_local_return_v_i</pre>
<pre style="background-color: #FF0000;">                     ? credit_local_return_data_i[i]</pre>
<pre style="background-color: #FF0000;">                     : (lg_remote_credits_lp ' (0))</pre>
<pre style="background-color: #FF0000;">         ,.down_i  ( lg_remote_credits_lp '  (yumi_o  [i]) )</pre>
<pre style="background-color: #FF0000;">         ,.count_o (local_credits [i])</pre>
<pre style="background-color: #FF0000;">        assign local_credits_avail [i] = |(local_credits[i]);</pre>
<pre style="background-color: #FF0000;">        assign remote_credits_avail[i]</pre>
<pre style="background-color: #FF0000;">               = | (credit_remote_return_data_i[i][lg_remote_credits_lp-1:lg_credit_decimation_p]);</pre>
<pre>   wire credit_v_li = | remote_credits_avail;</pre>
<pre>   bsg_round_robin_n_to_1 #(.width_p  (width_p   )</pre>
<pre>                            ,.num_in_p(num_in_p+1)</pre>
<pre>                            ,.strict_p(0)</pre>
<pre style="background-color: #FF0000;">   rr</pre>
<pre>     (.clk_i</pre>
<pre>      ,.reset_i</pre>
<pre>      ,.data_i ({  width_p ' (credit_remote_return_data_i),  data_i  })</pre>
<pre>      ,.v_i    ({  credit_v_li,              v_i & local_credits_avail })</pre>
<pre>      ,.yumi_o ({  credit_remote_return_yumi_o,  yumi_o                        })</pre>
<pre>      ,.data_o (data_o[0+:width_p] )</pre>
<pre>      ,.tag_o  (data_o[width_p+:tag_width_lp])</pre>
<pre>      ,.v_o    (v_o)</pre>
<pre>      ,.yumi_i (yumi_i )</pre>
<h3>./external/basejump_stl/bsg_dataflow/bsg_channel_tunnel_in.v</h3>
<pre>module bsg_channel_tunnel_in #(parameter width_p = -1</pre>
<pre>                               , num_in_p = "inv"</pre>
<pre>                               , remote_credits_p = "inv"</pre>
<pre>                               , use_pseudo_large_fifo_p = 0</pre>
<pre>                               , lg_credit_decimation_p = 4</pre>
<pre>                               , tag_width_lp           = $clog2(num_in_p+1)</pre>
<pre>                               , tagged_width_lp        = tag_width_lp+width_p</pre>
<pre>                               , lg_remote_credits_lp   = $clog2(remote_credits_p+1)</pre>
<pre>   (input  clk_i</pre>
<pre>    , input  reset_i</pre>
<pre>    , input  [tagged_width_lp-1:0] data_i</pre>
<pre>    , input  v_i</pre>
<pre>    , output yumi_o</pre>
<pre>    , output [num_in_p-1:0][width_p-1:0] data_o</pre>
<pre>    , output [num_in_p-1:0]             v_o</pre>
<pre>    , input  [num_in_p-1:0]              yumi_i</pre>
<pre>    , output [num_in_p-1:0][lg_remote_credits_lp-1:0] credit_local_return_data_o</pre>
<pre>    , output credit_local_return_v_o</pre>
<pre>    , output [num_in_p-1:0][lg_remote_credits_lp-1:0] credit_remote_return_data_o</pre>
<pre>    , input credit_remote_return_yumi_i</pre>
<pre>   logic credit_v_lo;</pre>
<pre>   logic [width_p-1:0] credit_data_lo;</pre>
<pre>   bsg_1_to_n_tagged_fifo #(.width_p            (width_p)</pre>
<pre>                            ,.num_out_p          (num_in_p+1      )</pre>
<pre>                            ,.els_p             (remote_credits_p)</pre>
<pre>                            ,.unbuffered_mask_p (1 << num_in_p   )</pre>
<pre>                            ,.use_pseudo_large_fifo_p(use_pseudo_large_fifo_p)</pre>
<pre style="background-color: #FF0000;">   b1_ntf</pre>
<pre>     (.clk_i</pre>
<pre>      ,.reset_i</pre>
<pre>      ,.v_i   (v_i)</pre>
<pre>      ,.tag_i (data_i[width_p+:tag_width_lp])</pre>
<pre>      ,.data_i(data_i[0+:width_p])</pre>
<pre>      ,.yumi_o</pre>
<pre>      ,.v_o     ( {credit_v_lo, v_o}  )</pre>
<pre>      ,.data_o  ( {credit_data_lo , data_o  } )</pre>
<pre>      ,.yumi_i  ( { 1'b0, yumi_i }            )</pre>
<pre>   assign credit_local_return_data_o = credit_data_lo[0+:num_in_p*lg_remote_credits_lp];</pre>
<pre>   assign credit_local_return_v_o    = credit_v_lo;</pre>
<pre>   wire [num_in_p-1:0] sent = v_o & yumi_i;</pre>
<pre style="background-color: #FF0000;">   genvar              i;</pre>
<pre style="background-color: #FF0000;">   for (i = 0; i < num_in_p; i=i+1)</pre>
<pre style="background-color: #FF0000;">     begin: rof</pre>
<pre style="background-color: #FF0000;">        bsg_counter_clear_up #(.max_val_p  (remote_credits_p)</pre>
<pre style="background-color: #FF0000;">                               ,.init_val_p(0)</pre>
<pre style="background-color: #FF0000;">                               ) ctr</pre>
<pre style="background-color: #FF0000;">            (.clk_i</pre>
<pre style="background-color: #FF0000;">             ,.reset_i</pre>
<pre style="background-color: #FF0000;">             ,.clear_i (credit_remote_return_yumi_i   )</pre>
<pre style="background-color: #FF0000;">             ,.up_i    (sent[i]                       )</pre>
<pre style="background-color: #FF0000;">             ,.count_o (credit_remote_return_data_o[i])</pre>
<h3>./external/basejump_stl/bsg_dataflow/bsg_fifo_1rw_large.v</h3>
<pre>module bsg_fifo_1rw_large #(parameter width_p         = -1</pre>
<pre>                          , parameter els_p           = -1</pre>
<pre>			  , parameter verbose_p       = 0</pre>
<pre>   (input                  clk_i</pre>
<pre>    , input                reset_i</pre>
<pre>    , input [width_p-1:0]  data_i</pre>
<pre>    , input                v_i</pre>
<pre>    , input                enq_not_deq_i</pre>
<pre>    , output full_o</pre>
<pre>    , output empty_o</pre>
<pre>    , output [width_p-1:0] data_o</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre>   wire mem_re = ~enq_not_deq_i & v_i;</pre>
<pre></pre>
<pre>     if (reset_i)</pre>
<pre>       last_op_is_read_r <= 1;</pre>
<pre>     else</pre>
<pre>         last_op_is_read_r <= mem_re;</pre>
<pre></pre>
<pre>   wire fifo_full  = (rd_ptr == wr_ptr) & ~last_op_is_read_r;</pre>
<pre></pre>
<pre>   assign empty_o = fifo_empty;</pre>
<pre></pre>
<pre>     assert (reset_i</pre>
<pre>             | ((fifo_full & mem_we) !== 1)</pre>
<pre>             ) else $error("enque on full fifo");</pre>
<pre></pre>
<pre>     assert (reset_i</pre>
<pre>             | ((fifo_empty & mem_re) !== 1)</pre>
<pre>             ) else $error("deque on empty fifo %x %x", fifo_empty, mem_re, v_i, enq_not_deq_i);</pre>
<pre></pre>
<pre>     if (verbose_p)</pre>
<pre>       if (v_i)</pre>
<pre>         begin</pre>
<pre>            if (enq_not_deq_i)</pre>
<pre>              $display("### %m enq %x onto fifo (r=%x w=%x)",data_i,rd_ptr,wr_ptr);</pre>
<pre>            else</pre>
<pre>         end</pre>
<pre>                                     ? 0</pre>
<pre>                                     : (fifo_full</pre>
<pre>                                        ? els_p</pre>
<pre>                                        : (wr_ptr > rd_ptr</pre>
<pre>                                           ? (wr_ptr - rd_ptr)</pre>
<pre>                                           : (els_p - (rd_ptr - wr_ptr)))));</pre>
<pre></pre>
<pre>                      ,.max_add_p(1)</pre>
<pre>                      ) rd_circ_ptr</pre>
<pre style="background-color: #FF0000;">     (.clk      (clk_i)</pre>
<pre>      , .reset_i(reset_i)</pre>
<pre>      , .add_i  (mem_re)</pre>
<pre>      , .o      (rd_ptr )</pre>
<pre>      );</pre>
<pre>                      ,.max_add_p(1)</pre>
<pre>                      ) wr_circ_ptr</pre>
<pre style="background-color: #FF0000;">     (.clk      (clk_i  )</pre>
<pre>      , .reset_i(reset_i)</pre>
<pre>      , .add_i  (mem_we)</pre>
<pre>      , .o      (wr_ptr )</pre>
<pre>      );</pre>
<pre>                      ,.els_p(els_p)</pre>
<pre>                      )</pre>
<pre>             ,.reset_i</pre>
<pre>             ,.data_i (data_i                   )</pre>
<pre>             ,.addr_i (mem_we ? wr_ptr : rd_ptr )</pre>
<pre>             ,.v_i    (v_i                      )</pre>
<pre>             ,.w_i    (mem_we                   )</pre>
<pre>             ,.data_o (data_o                   )</pre>
<pre>             );</pre>
<h3>./external/basejump_stl/bsg_dataflow/bsg_1_to_n_tagged.v</h3>
<pre>module bsg_1_to_n_tagged #(</pre>
<pre>                           ,parameter tag_width_lp = `BSG_SAFE_CLOG2(num_out_p)</pre>
<pre>                           )</pre>
<pre>    , input  reset_i</pre>
<pre></pre>
<pre>    , input [tag_width_lp-1:0]  tag_i</pre>
<pre>    , output                   yumi_o</pre>
<pre></pre>
<pre>    , input  [num_out_p-1:0]   ready_i</pre>
<pre></pre>
<pre>  wire unused1 = reset_i;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">     begin : one</pre>
<pre style="background-color: #FF0000;">        assign v_o = v_i;</pre>
<pre style="background-color: #FF0000;">        assign yumi_o  = ready_i & v_i;</pre>
<pre style="background-color: #FF0000;">     end</pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre>          (.i(tag_i)</pre>
<pre>           ,.v_i(v_i)</pre>
<pre>           ,.o(v_o)</pre>
<pre>           );</pre>
<pre>     end</pre>
<h3>./external/basejump_stl/bsg_dataflow/bsg_1_to_n_tagged_fifo.v</h3>
<pre>module bsg_1_to_n_tagged_fifo   #(parameter width_p                   = "inv"</pre>
<pre>                                  ,parameter num_out_p                = -1</pre>
<pre>                                  ,parameter els_p                    = "inv" // these are elements per channel</pre>
<pre>                                  ,parameter unbuffered_mask_p        = 0</pre>
<pre>                                  ,parameter tag_width_lp        = `BSG_SAFE_CLOG2(num_out_p)</pre>
<pre>                                  )</pre>
<pre>    , input  reset_i</pre>
<pre></pre>
<pre>    , input [tag_width_lp-1:0] tag_i</pre>
<pre>    , input [     width_p-1:0] data_i</pre>
<pre>    , output                   yumi_o</pre>
<pre></pre>
<pre>    , input  [num_out_p-1:0]               yumi_i</pre>
<pre>    , output [num_out_p-1:0] [width_p-1:0] data_o</pre>
<pre></pre>
<pre>   wire [num_out_p-1:0]               ready_li;</pre>
<pre></pre>
<pre>                       ) _1_to_n</pre>
<pre style="background-color: #FF0000;">     (.clk_i</pre>
<pre>      ,.reset_i</pre>
<pre></pre>
<pre>      ,.tag_i</pre>
<pre>      ,.yumi_o</pre>
<pre></pre>
<pre>      ,.ready_i(ready_li)</pre>
<pre>      );</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">     begin: rof</pre>
<pre style="background-color: #FF0000;">        if (unbuffered_mask_p[i])</pre>
<pre style="background-color: #FF0000;">          begin: unbuf</pre>
<pre style="background-color: #FF0000;">             assign v_o     [i] = valid_lo[i];</pre>
<pre style="background-color: #FF0000;">             assign data_o  [i] = data_i;</pre>
<pre style="background-color: #FF0000;">             assign ready_li[i] = 1'b1;</pre>
<pre style="background-color: #FF0000;">          end</pre>
<pre style="background-color: #FF0000;">          begin : psdlrg</pre>
<pre style="background-color: #FF0000;">             bsg_fifo_1r1w_pseudo_large #(.width_p(width_p)</pre>
<pre style="background-color: #FF0000;">                                          ,.els_p(els_p)</pre>
<pre style="background-color: #FF0000;">                                          ) fifo</pre>
<pre style="background-color: #FF0000;">               (.clk_i</pre>
<pre style="background-color: #FF0000;">                ,.reset_i</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">                ,.data_i</pre>
<pre style="background-color: #FF0000;">                ,.ready_o(ready_li[i])</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">                ,.data_o(data_o[i])</pre>
<pre style="background-color: #FF0000;">                ,.yumi_i(yumi_i[i])</pre>
<pre style="background-color: #FF0000;">                );</pre>
<pre style="background-color: #FF0000;">             bsg_fifo_1r1w_small #(.width_p(width_p)</pre>
<pre style="background-color: #FF0000;">                                   ,.els_p (els_p  )</pre>
<pre style="background-color: #FF0000;">                                   ) fifo</pre>
<pre style="background-color: #FF0000;">               (.clk_i</pre>
<pre style="background-color: #FF0000;">                ,.reset_i</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">                ,.data_i   (data_i     )</pre>
<pre style="background-color: #FF0000;">                ,.ready_o  (ready_li[i])</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">                ,.data_o   (data_o[i])</pre>
<pre style="background-color: #FF0000;">                ,.yumi_i   (yumi_i[i])</pre>
<pre style="background-color: #FF0000;">                );</pre>
<h3>./external/basejump_stl/bsg_dataflow/bsg_flow_counter.v</h3>
<pre>module bsg_flow_counter #(parameter els_p              = -1</pre>
<pre>                        , parameter count_free_p       = 0</pre>
<pre>                        , parameter ready_THEN_valid_p = 0</pre>
<pre>                          `BSG_WIDTH(els_p)</pre>
<pre>                         )                           </pre>
<pre>    , input                     reset_i</pre>
<pre></pre>
<pre>    , input                     ready_i</pre>
<pre>    , input                     yumi_i</pre>
<pre></pre>
<pre>    );</pre>
<pre></pre>
<pre style="background-color: #FF0000;">  assign enque = v_i;</pre>
<pre style="background-color: #FF0000;">end else begin: gen_blk_protocol_select</pre>
<pre>  assign enque = v_i & ready_i;</pre>
<pre>end</pre>
<pre style="background-color: #FF0000;">  if (count_free_p) begin: gen_blk_0</pre>
<pre style="background-color: #FF0000;">    // An up-down counter is used for counting free slots.</pre>
<pre style="background-color: #FF0000;">                         , .init_val_p(els_p) </pre>
<pre style="background-color: #FF0000;">                         , .max_step_p(1)</pre>
<pre style="background-color: #FF0000;">                         ) counter</pre>
<pre style="background-color: #FF0000;">    </pre>
<pre style="background-color: #FF0000;">        , .reset_i(reset_i)</pre>
<pre style="background-color: #FF0000;">    </pre>
<pre style="background-color: #FF0000;">        , .down_i(enque)</pre>
<pre style="background-color: #FF0000;">    </pre>
<pre style="background-color: #FF0000;">        );</pre>
<pre style="background-color: #FF0000;">    bsg_counter_up_down #( .max_val_p(els_p)  </pre>
<pre>                         , .init_val_p(0) </pre>
<pre>                         , .max_step_p(1)</pre>
<pre>                         ) counter</pre>
<pre style="background-color: #FF0000;">    </pre>
<pre>        , .reset_i(reset_i)</pre>
<pre>    </pre>
<pre>        , .down_i(yumi_i)</pre>
<pre>    </pre>
<pre>        );</pre>
<h3>./external/basejump_stl/bsg_dataflow/bsg_round_robin_2_to_2.v</h3>
<pre>module bsg_round_robin_2_to_2 #(parameter width_p = -1</pre>
<pre>   (input clk_i</pre>
<pre>    , input reset_i</pre>
<pre>    , input [width_p*2-1:0] data_i</pre>
<pre>    , input [1:0] v_i</pre>
<pre>    , output [1:0] ready_o</pre>
<pre>    , output [width_p*2-1:0] data_o</pre>
<pre>    , output [1:0] v_o</pre>
<pre>    , input [1:0] ready_i</pre>
<pre>   logic head_r;</pre>
<pre>   always_ff @(posedge clk_i)</pre>
<pre>     if (reset_i)</pre>
<pre>       head_r <= 0;</pre>
<pre>       head_r <= ^ {head_r, v_i & ready_o};</pre>
<pre>   assign data_o  = head_r ? { data_i[0+:width_p], data_i[width_p+:width_p] } : data_i;</pre>
<pre>   assign v_o = head_r ? { v_i[0], v_i[1] } : v_i;</pre>
<pre>   assign ready_o = head_r ? { ready_i[0], ready_i[1] } : ready_i;</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_adder_ripple_carry.v</h3>
<pre>module bsg_adder_ripple_carry #(parameter width_p = "inv")</pre>
<pre>    input [width_p-1:0] a_i</pre>
<pre>    , input [width_p-1:0] b_i</pre>
<pre>    , output logic [width_p-1:0] s_o</pre>
<pre>    , output logic c_o</pre>
<pre>  assign {c_o, s_o} = a_i + b_i;</pre>
<h3>./external/basejump_stl/bsg_dataflow/bsg_one_fifo.v</h3>
<pre>module bsg_one_fifo #(parameter width_p="inv"</pre>
<pre>   (input clk_i</pre>
<pre>    , input reset_i</pre>
<pre>    , output              ready_o // early</pre>
<pre>    , input [width_p-1:0] data_i  // late</pre>
<pre>    , input               v_i     // late</pre>
<pre>    , output              v_o     // early</pre>
<pre>    , output[width_p-1:0] data_o  // early</pre>
<pre>    , input               yumi_i  // late</pre>
<pre>  logic             full_r;</pre>
<pre>  assign ready_o = ~full_r;</pre>
<pre>  assign v_o     =  full_r;</pre>
<pre>  bsg_dff_reset #(.width_p(1)) dff_full</pre>
<pre>  (.clk_i</pre>
<pre>   ,.reset_i</pre>
<pre>   ,.data_i(full_r ? ~yumi_i: v_i)</pre>
<pre>   ,.data_o(full_r)</pre>
<pre>  bsg_dff_en #(.width_p(width_p), .harden_p(0)) dff</pre>
<pre>  (.clk_i</pre>
<pre>   ,.data_i</pre>
<pre>   ,.en_i(v_i & ready_o)</pre>
<pre>   ,.data_o</pre>
<h3>./external/basejump_stl/bsg_dataflow/bsg_fifo_1r1w_pseudo_large.v</h3>
<pre>module bsg_fifo_1r1w_pseudo_large #(parameter width_p = -1</pre>
<pre>                                      , parameter els_p = -1</pre>
<pre>                                      , parameter early_yumi_p = 1</pre>
<pre>                                      , parameter verbose_p = 0</pre>
<pre>   (input   clk_i</pre>
<pre>    , input reset_i</pre>
<pre>    , input [width_p-1:0] data_i</pre>
<pre>    , input v_i</pre>
<pre>    , output ready_o</pre>
<pre>    , output v_o</pre>
<pre>    , output [width_p-1:0] data_o</pre>
<pre>    , input  yumi_i</pre>
<pre>   wire big_full_lo, big_empty_lo;</pre>
<pre>   wire [width_p-1:0] big_data_lo;</pre>
<pre>   logic               big_enq, big_deq, big_deq_r;</pre>
<pre>   wire               little_ready_lo, little_will_have_space;</pre>
<pre>   logic              little_valid, big_valid;</pre>
<pre style="background-color: #FF0000;">   if (early_yumi_p)</pre>
<pre style="background-color: #FF0000;">     assign little_will_have_space = little_ready_lo | yumi_i;</pre>
<pre style="background-color: #FF0000;">     assign little_will_have_space = little_ready_lo;</pre>
<pre>   always_ff @(posedge clk_i)</pre>
<pre>     if (reset_i)</pre>
<pre>       big_deq_r <= 1'b0;</pre>
<pre>       big_deq_r <= big_deq;</pre>
<pre>   wire ready_o_int = ~big_full_lo;</pre>
<pre>   assign ready_o   = ready_o_int;</pre>
<pre>   wire bypass_mode = v_i & ~ big_enq;</pre>
<pre>   wire [31:0] num_elements_debug = big1p.num_elements_debug + big_deq_r + little2p.num_elements_debug;</pre>
<pre>   logic big_enq_r;</pre>
<pre>   always_ff @(posedge clk_i)</pre>
<pre>     if (reset_i)</pre>
<pre>       big_enq_r <= 0;</pre>
<pre>       big_enq_r <= big_enq_r | big_enq;</pre>
<pre>   always_ff @(negedge clk_i)</pre>
<pre>     if (verbose_p & (reset_i === 0) & (~big_enq_r & big_enq))</pre>
<pre>       $display("## %L: overflowing into big fifo for the first time (%m)");</pre>
<pre>   always_comb</pre>
<pre>     begin</pre>
<pre>        if (big_deq_r)</pre>
<pre>          begin</pre>
<pre>             little_valid = 1'b1;</pre>
<pre>             big_enq      = v_i;</pre>
<pre>             big_deq      = (~big_empty_lo & ~big_enq & ~v_o);</pre>
<pre>          begin</pre>
<pre>             if (big_empty_lo)</pre>
<pre>               begin</pre>
<pre>                  little_valid = v_i  & little_will_have_space;</pre>
<pre>                  big_enq      = v_i  & ~little_will_have_space;</pre>
<pre>                  big_deq      = 1'b0; // big FIFO is empty, can't deque</pre>
<pre>               begin</pre>
<pre>                  little_valid = 1'b0;</pre>
<pre>                  big_enq = v_i  & ~big_full_lo;</pre>
<pre>                  big_deq = ~big_enq & little_will_have_space;</pre>
<pre>        big_valid    = big_enq | big_deq;</pre>
<pre>   wire [width_p-1:0] little_data = big_deq_r ? big_data_lo : data_i;</pre>
<pre style="background-color: #FF0000;">   bsg_fifo_1rw_large #(.width_p(width_p)</pre>
<pre style="background-color: #FF0000;">                        ,.els_p(els_p)</pre>
<pre style="background-color: #FF0000;">                        ,.verbose_p(verbose_p)</pre>
<pre style="background-color: #FF0000;">                        ) big1p</pre>
<pre style="background-color: #FF0000;">     (.clk_i         (clk_i       )</pre>
<pre style="background-color: #FF0000;">      ,.reset_i      (reset_i     )</pre>
<pre style="background-color: #FF0000;">      ,.data_i       (data_i      )</pre>
<pre style="background-color: #FF0000;">      ,.v_i          (big_valid)</pre>
<pre style="background-color: #FF0000;">      ,.enq_not_deq_i(big_enq)</pre>
<pre style="background-color: #FF0000;">      ,.full_o   (big_full_lo )</pre>
<pre style="background-color: #FF0000;">      ,.empty_o  (big_empty_lo)</pre>
<pre style="background-color: #FF0000;">      ,.data_o   (big_data_lo )</pre>
<pre style="background-color: #FF0000;">   bsg_two_fifo #(.width_p(width_p)</pre>
<pre style="background-color: #FF0000;">                  ,. verbose_p(verbose_p)</pre>
<pre style="background-color: #FF0000;">                  ,. allow_enq_deq_on_full_p(early_yumi_p)) little2p</pre>
<pre style="background-color: #FF0000;">     (.clk_i   (clk_i)</pre>
<pre style="background-color: #FF0000;">      ,.reset_i(reset_i)</pre>
<pre style="background-color: #FF0000;">      ,.ready_o(little_ready_lo)</pre>
<pre style="background-color: #FF0000;">      ,.data_i (little_data)</pre>
<pre style="background-color: #FF0000;">      ,.v_i    (little_valid)</pre>
<pre style="background-color: #FF0000;">      ,.v_o    (v_o)</pre>
<pre style="background-color: #FF0000;">      ,.data_o (data_o)</pre>
<pre style="background-color: #FF0000;">      ,.yumi_i (yumi_i)</pre>
<h3>./external/basejump_stl/bsg_dataflow/bsg_fifo_1r1w_small.v</h3>
<pre>module bsg_fifo_1r1w_small #( parameter width_p      = -1</pre>
<pre>                            , parameter els_p        = -1</pre>
<pre>                            , parameter ready_THEN_valid_p = 0</pre>
<pre>    ( input                clk_i</pre>
<pre>    , input                reset_i</pre>
<pre>    , input                v_i</pre>
<pre>    , output               ready_o</pre>
<pre>    , input [width_p-1:0]  data_i</pre>
<pre>    , output               v_o</pre>
<pre>    , output [width_p-1:0] data_o</pre>
<pre>    , input                yumi_i</pre>
<pre>   wire deque = yumi_i;</pre>
<pre>   wire v_o_tmp;</pre>
<pre>   assign v_o = v_o_tmp;</pre>
<pre>   wire enque;</pre>
<pre>   logic ready_lo;</pre>
<pre>   if (ready_THEN_valid_p)</pre>
<pre>     begin: rtv</pre>
<pre>        assign enque = v_i;</pre>
<pre>     begin: rav</pre>
<pre>        assign enque = v_i & ready_lo;</pre>
<pre></pre>
<pre>   logic                    full, empty;</pre>
<pre></pre>
<pre>                      ) ft</pre>
<pre style="background-color: #FF0000;">     (.clk_i</pre>
<pre>      ,.reset_i</pre>
<pre>      ,.enq_i   (enque)</pre>
<pre>      ,.deq_i   (deque)</pre>
<pre>      ,.wptr_r_o(wptr_r)</pre>
<pre>      ,.rptr_r_o(rptr_r)</pre>
<pre>      ,.full_o  (full)</pre>
<pre>      ,.empty_o (empty)</pre>
<pre>      );</pre>
<pre>                  ,.els_p  (els_p  )</pre>
<pre>		  // MBT: this should be zero</pre>
<pre>                  ) mem_1r1w</pre>
<pre style="background-color: #FF0000;">     (.w_clk_i   (clk_i  )</pre>
<pre>      ,.w_reset_i(reset_i)</pre>
<pre>      ,.w_v_i    (enque  )</pre>
<pre>      ,.w_addr_i (wptr_r )</pre>
<pre>      ,.w_data_i (data_i )</pre>
<pre>      ,.r_v_i    (v_o_tmp)</pre>
<pre>      ,.r_addr_i (rptr_r )</pre>
<pre>      ,.r_data_o (data_o )</pre>
<pre>      );</pre>
<pre>   assign ready_o = ready_lo;</pre>
<pre>   assign v_o_tmp = ~empty;</pre>
<pre></pre>
<pre>     begin</pre>
<pre>        if (ready_THEN_valid_p & full  & v_i    & ~reset_i)</pre>
<pre>          $display("%m error: enque full fifo at time %t", $time);</pre>
<pre>        if (empty & yumi_i & ~reset_i)</pre>
<pre>          $display("%m error: deque empty fifo at time %t", $time);</pre>
<pre>     end</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_counter_set_down.v</h3>
<pre>module bsg_counter_set_down #(parameter width_p="inv", parameter init_val_p='0, parameter set_and_down_exclusive_p=0)</pre>
<pre>  (input clk_i</pre>
<pre>   , input reset_i</pre>
<pre>   , input set_i</pre>
<pre>   , input [width_p-1:0] val_i</pre>
<pre>   , input down_i</pre>
<pre>   , output [width_p-1:0] count_r_o</pre>
<pre>  logic [width_p-1:0] ctr_r, ctr_n;</pre>
<pre>  always_ff @(posedge clk_i)	    </pre>
<pre>    if (reset_i)</pre>
<pre>      ctr_r <= width_p ' (init_val_p);</pre>
<pre>      ctr_r <= ctr_n;</pre>
<pre>  if (set_and_down_exclusive_p)</pre>
<pre>    begin: excl</pre>
<pre>       always_comb </pre>
<pre>	 begin</pre>
<pre>	    ctr_n = ctr_r;</pre>
<pre>	    if (set_i)</pre>
<pre>              ctr_n = val_i;</pre>
<pre>              if (down_i)</pre>
<pre>		ctr_n = ctr_n - 1;     </pre>
<pre style="background-color: #FF0000;">    begin : non_excl </pre>
<pre style="background-color: #FF0000;">      always_comb</pre>
<pre style="background-color: #FF0000;">    	begin</pre>
<pre style="background-color: #FF0000;">          ctr_n = ctr_r;</pre>
<pre style="background-color: #FF0000;">          if (set_i)</pre>
<pre style="background-color: #FF0000;">            ctr_n = val_i;</pre>
<pre style="background-color: #FF0000;">          if (down_i)</pre>
<pre style="background-color: #FF0000;">            ctr_n = ctr_n - 1;</pre>
<pre>  assign count_r_o = ctr_r;</pre>
<pre>  always_ff @(negedge clk_i)</pre>
<pre>    begin</pre>
<pre>      if (!reset_i && down_i && (ctr_n == '1))</pre>
<pre>        $display("%m error: counter underflow at time %t", $time);</pre>
<pre>      if (~reset_i & set_and_down_exclusive_p & set_i & down_i)</pre>
<pre>	      $display("%m error: set and down non-exclusive at time %t", $time);</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_counter_clear_up.v</h3>
<pre>module bsg_counter_clear_up #(parameter max_val_p     = -1</pre>
<pre>                             ,parameter ptr_width_lp =</pre>
<pre>                             `BSG_SAFE_CLOG2(max_val_p+1)</pre>
<pre>			     ,parameter disable_overflow_warning_p = 0</pre>
<pre>                             )</pre>
<pre>    , input reset_i</pre>
<pre></pre>
<pre>    , input up_i</pre>
<pre>    // fixme: count_o should be renamed to count_r_o since some modules</pre>
<pre>    );</pre>
<pre>     begin</pre>
<pre>        if (reset_i)</pre>
<pre>          count_o <= init_val_p;</pre>
<pre>        else</pre>
<pre>     end</pre>
<pre>     begin</pre>
<pre>       if ((count_o==ptr_width_lp '(max_val_p)) && up_i && (reset_i===0) && !disable_overflow_warning_p)</pre>
<pre>         $display("%m error: counter overflow at time %t", $time);</pre>
<pre>     end</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_cycle_counter.v</h3>
<pre>module bsg_cycle_counter #(parameter width_p=32</pre>
<pre>                           , init_val_p = 0)</pre>
<pre>   (input clk_i</pre>
<pre>    , input reset_i</pre>
<pre>    , output logic [width_p-1:0] ctr_r_o);</pre>
<pre>   always @(posedge clk_i)</pre>
<pre>     if (reset_i)</pre>
<pre>       ctr_r_o <= init_val_p;</pre>
<pre>       ctr_r_o <= ctr_r_o+1;</pre>
<h3>./external/basejump_stl/bsg_dataflow/bsg_two_fifo.v</h3>
<pre>module bsg_two_fifo #(parameter width_p="inv"</pre>
<pre>                      , parameter verbose_p=0</pre>
<pre>                      , parameter allow_enq_deq_on_full_p=0</pre>
<pre>                      , parameter ready_THEN_valid_p=allow_enq_deq_on_full_p</pre>
<pre>   (input clk_i</pre>
<pre>    , input reset_i</pre>
<pre>    , output              ready_o // early</pre>
<pre>    , input [width_p-1:0] data_i  // late</pre>
<pre>    , input               v_i     // late</pre>
<pre>    , output              v_o     // early</pre>
<pre>    , output[width_p-1:0] data_o  // early</pre>
<pre>    , input               yumi_i  // late</pre>
<pre>   wire deq_i = yumi_i;</pre>
<pre>   wire enq_i;</pre>
<pre>   logic                  head_r,  tail_r;</pre>
<pre>   logic                  empty_r, full_r;</pre>
<pre>   bsg_mem_1r1w #(.width_p(width_p)</pre>
<pre>                  ,.els_p(2)</pre>
<pre>		  ,.read_write_same_addr_p(allow_enq_deq_on_full_p)</pre>
<pre style="background-color: #FF0000;">                  ) mem_1r1w</pre>
<pre>     (.w_clk_i   (clk_i  )</pre>
<pre>      ,.w_reset_i(reset_i)</pre>
<pre>      ,.w_v_i    (enq_i  )</pre>
<pre>      ,.w_addr_i (tail_r )</pre>
<pre>      ,.w_data_i (data_i )</pre>
<pre>      ,.r_v_i    (~empty_r)</pre>
<pre>      ,.r_addr_i (head_r )</pre>
<pre>      ,.r_data_o (data_o )</pre>
<pre>   assign v_o       = ~empty_r;</pre>
<pre>   assign ready_o   = ~full_r;</pre>
<pre>   if (ready_THEN_valid_p)</pre>
<pre style="background-color: #FF0000;">     assign enq_i = v_i;</pre>
<pre>     assign enq_i = v_i & ~full_r;</pre>
<pre>   always_ff @(posedge clk_i)</pre>
<pre>     begin</pre>
<pre>        if (reset_i)</pre>
<pre>          begin</pre>
<pre>             tail_r  <= 1'b0;</pre>
<pre>             head_r  <= 1'b0;</pre>
<pre>             empty_r <= 1'b1;</pre>
<pre>             full_r  <= 1'b0;</pre>
<pre>          begin</pre>
<pre>             if (enq_i)</pre>
<pre>               tail_r         <= ~tail_r;</pre>
<pre>             if (deq_i)</pre>
<pre>               head_r         <= ~head_r;</pre>
<pre>             empty_r             <= (   empty_r & ~enq_i)</pre>
<pre>                                    | (~full_r  &  deq_i & ~enq_i);</pre>
<pre>             if (allow_enq_deq_on_full_p)</pre>
<pre>               full_r              <= (  ~empty_r &  enq_i & ~deq_i)</pre>
<pre>                                      | ( full_r  & ~(deq_i^enq_i));</pre>
<pre>               full_r              <= (  ~empty_r &  enq_i & ~deq_i)</pre>
<pre>                                      | ( full_r  & ~deq_i);</pre>
<pre>   always_ff @(posedge clk_i)</pre>
<pre>     begin</pre>
<pre>        if (~reset_i)</pre>
<pre>          begin</pre>
<pre>             assert ({empty_r, deq_i} !== 2'b11)</pre>
<pre>               else $error("invalid deque on empty fifo ", empty_r, deq_i);</pre>
<pre>             if (allow_enq_deq_on_full_p)</pre>
<pre>               begin</pre>
<pre>                  assert ({full_r,enq_i,deq_i}   !== 3'b110)</pre>
<pre>                    else $error("invalid enque on full fifo ", full_r, enq_i);</pre>
<pre>               assert ({full_r,enq_i}   !== 2'b11)</pre>
<pre>                 else $error("invalid enque on full fifo ", full_r, enq_i);</pre>
<pre>             assert ({full_r,empty_r} !== 2'b11)</pre>
<pre>               else $error ("fifo full and empty at same time ", full_r, empty_r);</pre>
<pre>   always_ff @(posedge clk_i)</pre>
<pre>     if (verbose_p)</pre>
<pre>       begin</pre>
<pre>          if (v_i)</pre>
<pre>            $display("### %m enq %x onto fifo",data_i);</pre>
<pre>          if (deq_i)</pre>
<pre>            $display("### %m deq %x from fifo",data_o);</pre>
<pre>   wire [31:0] num_elements_debug = full_r + (empty_r==0);</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_concentrate_static.v</h3>
<pre>module bsg_concentrate_static #(parameter pattern_els_p="inv", width_lp=$bits(pattern_els_p), set_els_lp=`BSG_COUNTONES_SYNTH(pattern_els_p))</pre>
<pre> ,output [set_els_lp-1:0] o</pre>
<pre>);</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">     assign o[0]=i[0];</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">     begin : rof</pre>
<pre style="background-color: #FF0000;">       if (pattern_els_p[j])</pre>
<pre style="background-color: #FF0000;">         assign o[`BSG_COUNTONES_SYNTH(pattern_els_p[j-1:0])] = i[j];</pre>
<pre style="background-color: #FF0000;">     end</pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./external/basejump_stl/bsg_mem/bsg_mem_1r1w.v</h3>
<pre>module bsg_mem_1r1w #(parameter width_p=-1</pre>
<pre>                      , parameter els_p=-1</pre>
<pre>                      , parameter addr_width_lp=`BSG_SAFE_CLOG2(els_p)</pre>
<pre>                      , parameter harden_p=0</pre>
<pre>                      )</pre>
<pre>    , input w_reset_i</pre>
<pre></pre>
<pre>    , input [addr_width_lp-1:0] w_addr_i</pre>
<pre>    , input [width_p-1:0]       w_data_i</pre>
<pre></pre>
<pre>    , input [addr_width_lp-1:0]  r_addr_i</pre>
<pre></pre>
<pre>    );</pre>
<pre>     #(.width_p(width_p)</pre>
<pre>       ,.els_p(els_p)</pre>
<pre>       ,.read_write_same_addr_p(read_write_same_addr_p)</pre>
<pre>       ,.harden_p(harden_p)</pre>
<pre>       ) synth</pre>
<pre style="background-color: #FF0000;">       (.*);</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">     begin</pre>
<pre>	if (read_write_same_addr_p || (width_p*els_p >= 64))</pre>
<pre>          $display("## %L: instantiating width_p=%d, els_p=%d, read_write_same_addr_p=%d, harden_p=%d (%m)"</pre>
<pre>                   ,width_p,els_p,read_write_same_addr_p,harden_p);</pre>
<pre>     end</pre>
<pre>     if (w_v_i===1'b1)</pre>
<pre>       begin</pre>
<pre>          assert ((w_reset_i === 'X) || (w_reset_i === 1'b1) || (w_addr_i < els_p))</pre>
<pre>            else $error("Invalid address %x to %m of size %x (w_reset_i=%b, w_v_i=%b)\n", w_addr_i, els_p, w_reset_i, w_v_i);</pre>
<pre></pre>
<pre>            else $error("%m: Attempt to read and write same address %x (w_v_i = %b, w_reset_i = %b)",w_addr_i,w_v_i,w_reset_i);</pre>
<pre>       end</pre>
<h3>./external/basejump_stl/bsg_mem/bsg_mem_1r1w_sync.v</h3>
<pre>module bsg_mem_1r1w_sync #(parameter width_p=-1</pre>
<pre>                           , parameter els_p=-1</pre>
<pre>                           , parameter addr_width_lp=`BSG_SAFE_CLOG2(els_p)</pre>
<pre>                           , parameter harden_p=0</pre>
<pre>                           , parameter disable_collision_warning_p=1</pre>
<pre>                           , parameter enable_clock_gating_p=0</pre>
<pre>                           )</pre>
<pre>    , input reset_i</pre>
<pre></pre>
<pre>    , input [addr_width_lp-1:0] w_addr_i</pre>
<pre>    , input [width_p-1:0]       w_data_i</pre>
<pre></pre>
<pre>    , input [addr_width_lp-1:0]  r_addr_i</pre>
<pre></pre>
<pre>    );</pre>
<pre></pre>
<pre>     begin</pre>
<pre style="background-color: #FF0000;">       bsg_clkgate_optional icg</pre>
<pre style="background-color: #FF0000;">         (.clk_i( clk_i )</pre>
<pre style="background-color: #FF0000;">         ,.en_i( w_v_i | r_v_i )</pre>
<pre style="background-color: #FF0000;">         ,.bypass_i( 1'b0 )</pre>
<pre style="background-color: #FF0000;">         ,.gated_clock_o( clk_lo )</pre>
<pre style="background-color: #FF0000;">         );</pre>
<pre>       assign clk_lo = clk_i;</pre>
<pre>     end</pre>
<pre>     #(.width_p(width_p)</pre>
<pre>       ,.els_p(els_p)</pre>
<pre>       ,.read_write_same_addr_p(read_write_same_addr_p)</pre>
<pre>       ,.harden_p(harden_p)</pre>
<pre>       ) synth</pre>
<pre style="background-color: #FF0000;">       (.clk_i( clk_lo )</pre>
<pre>       ,.reset_i</pre>
<pre>       ,.w_v_i</pre>
<pre>       ,.w_addr_i</pre>
<pre>       ,.w_data_i</pre>
<pre>       ,.r_v_i</pre>
<pre>       ,.r_addr_i</pre>
<pre>       ,.r_data_o</pre>
<pre>       );</pre>
<pre style="background-color: #FF0000;">     begin</pre>
<pre>        $display("## %L: instantiating width_p=%d, els_p=%d, read_write_same_addr_p=%d, harden_p=%d (%m)",width_p,els_p,read_write_same_addr_p,harden_p);</pre>
<pre>     end</pre>
<pre>     if (w_v_i)</pre>
<pre>       begin</pre>
<pre>          assert ((reset_i === 'X) || (reset_i === 1'b1) || (w_addr_i < els_p))</pre>
<pre>            else $error("Invalid address %x to %m of size %x\n", w_addr_i, els_p);</pre>
<pre></pre>
<pre>            else</pre>
<pre style="background-color: #FF0000;">              begin</pre>
<pre>                 $error("X'ing matched read address %x (%m)",r_addr_i);</pre>
<pre>              end</pre>
<h3>./external/basejump_stl/bsg_mem/bsg_mem_1r1w_sync_synth.v</h3>
<pre>module bsg_mem_1r1w_sync_synth #(parameter width_p=-1</pre>
<pre>				 , parameter els_p=-1</pre>
<pre>				 , parameter addr_width_lp=`BSG_SAFE_CLOG2(els_p)</pre>
<pre>				 , parameter harden_p=0</pre>
<pre>				 )</pre>
<pre>    , input reset_i</pre>
<pre></pre>
<pre>    , input [addr_width_lp-1:0] w_addr_i</pre>
<pre>    , input [width_p-1:0]       w_data_i</pre>
<pre></pre>
<pre>    , input [addr_width_lp-1:0]  r_addr_i</pre>
<pre></pre>
<pre>    );</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre>     if (r_v_i)</pre>
<pre>       r_addr_r <= r_addr_i;</pre>
<pre>     else</pre>
<pre></pre>
<pre></pre>
<pre>     if (w_v_i)</pre>
<pre>       mem[w_addr_i] <= w_data_i;</pre>
<pre></pre>
<h3>./external/basejump_stl/bsg_mem/bsg_mem_1r1w_synth.v</h3>
<pre>module bsg_mem_1r1w_synth #(parameter width_p=-1</pre>
<pre>			    ,parameter els_p=-1</pre>
<pre>			    ,parameter addr_width_lp=`BSG_SAFE_CLOG2(els_p)</pre>
<pre>			    ,parameter harden_p=0)</pre>
<pre>(</pre>
<pre>  ,input w_reset_i</pre>
<pre></pre>
<pre>  ,input [addr_width_lp-1:0] w_addr_i</pre>
<pre>  ,input [width_p-1:0] w_data_i</pre>
<pre></pre>
<pre>  ,input [addr_width_lp-1:0]  r_addr_i</pre>
<pre></pre>
<pre>);</pre>
<pre></pre>
<pre>  wire unused1 = r_v_i;</pre>
<pre></pre>
<pre></pre>
<pre>    if (w_v_i) begin</pre>
<pre>      mem[w_addr_i] <= w_data_i;</pre>
<pre>    end</pre>
<h3>./external/basejump_stl/bsg_mem/bsg_mem_1rw_sync.v</h3>
<pre>module bsg_mem_1rw_sync #(parameter width_p=-1</pre>
<pre>                          , parameter els_p=-1</pre>
<pre>                          , parameter addr_width_lp=`BSG_SAFE_CLOG2(els_p)</pre>
<pre>                          , parameter enable_clock_gating_p=0</pre>
<pre>                          )</pre>
<pre>    , input reset_i</pre>
<pre>    , input [width_p-1:0] data_i</pre>
<pre>    , input [addr_width_lp-1:0] addr_i</pre>
<pre>    , input v_i</pre>
<pre>    , input w_i</pre>
<pre>    , output logic [width_p-1:0]  data_o</pre>
<pre>    );</pre>
<pre></pre>
<pre>     begin</pre>
<pre style="background-color: #FF0000;">       bsg_clkgate_optional icg</pre>
<pre style="background-color: #FF0000;">         (.clk_i( clk_i )</pre>
<pre style="background-color: #FF0000;">         ,.en_i( v_i )</pre>
<pre style="background-color: #FF0000;">         ,.bypass_i( 1'b0 )</pre>
<pre style="background-color: #FF0000;">         ,.gated_clock_o( clk_lo )</pre>
<pre style="background-color: #FF0000;">         );</pre>
<pre>       assign clk_lo = clk_i;</pre>
<pre>     end</pre>
<pre>     #(.width_p(width_p)</pre>
<pre>       ,.els_p(els_p)</pre>
<pre>       ,.latch_last_read_p(latch_last_read_p)</pre>
<pre>       ) synth</pre>
<pre style="background-color: #FF0000;">    (.clk_i( clk_lo )</pre>
<pre>    ,.reset_i</pre>
<pre>    ,.data_i</pre>
<pre>    ,.addr_i</pre>
<pre>    ,.v_i</pre>
<pre>    ,.w_i</pre>
<pre>    ,.data_o</pre>
<pre>    );</pre>
<h3>./external/basejump_stl/bsg_mem/bsg_mem_1rw_sync_mask_write_bit.v</h3>
<pre>module bsg_mem_1rw_sync_mask_write_bit #(parameter width_p=-1</pre>
<pre>			               , parameter els_p=-1</pre>
<pre>                     , parameter latch_last_read_p=0</pre>
<pre>			               , parameter addr_width_lp=`BSG_SAFE_CLOG2(els_p)</pre>
<pre>                     )</pre>
<pre>    , input reset_i</pre>
<pre>    , input [width_p-1:0] data_i</pre>
<pre>    , input [addr_width_lp-1:0] addr_i</pre>
<pre>    , input v_i</pre>
<pre>    , input [width_p-1:0] w_mask_i</pre>
<pre>    , input w_i</pre>
<pre>    , output [width_p-1:0]  data_o</pre>
<pre>    );</pre>
<pre></pre>
<pre>     begin</pre>
<pre style="background-color: #FF0000;">       bsg_clkgate_optional icg</pre>
<pre style="background-color: #FF0000;">         (.clk_i( clk_i )</pre>
<pre style="background-color: #FF0000;">         ,.en_i( v_i )</pre>
<pre style="background-color: #FF0000;">         ,.bypass_i( 1'b0 )</pre>
<pre style="background-color: #FF0000;">         ,.gated_clock_o( clk_lo )</pre>
<pre style="background-color: #FF0000;">         );</pre>
<pre>       assign clk_lo = clk_i;</pre>
<pre>     end</pre>
<pre>     #(.width_p(width_p)</pre>
<pre>       ,.els_p(els_p)</pre>
<pre>       ,.latch_last_read_p(latch_last_read_p)</pre>
<pre>       ) synth</pre>
<pre style="background-color: #FF0000;">       (.clk_i (clk_lo)</pre>
<pre>       ,.reset_i</pre>
<pre>       ,.data_i</pre>
<pre>       ,.addr_i</pre>
<pre>       ,.v_i</pre>
<pre>       ,.w_mask_i</pre>
<pre>       ,.w_i</pre>
<pre>       ,.data_o</pre>
<pre>       );</pre>
<pre>     if (v_i === 1)</pre>
<pre>       assert ((reset_i === 'X) || (reset_i === 1'b1) || (addr_i < els_p))</pre>
<pre>         else $error("Invalid address %x to %m of size %x (reset_i = %b, v_i = %b, clk_lo=%b)\n", addr_i, els_p, reset_i, v_i, clk_lo);</pre>
<pre></pre>
<pre style="background-color: #FF0000;">     begin</pre>
<pre>        $display("## %L: instantiating width_p=%d, els_p=%d (%m)",width_p,els_p);</pre>
<pre>     end</pre>
<h3>./external/basejump_stl/bsg_mem/bsg_mem_1rw_sync_mask_write_bit_synth.v</h3>
<pre>module bsg_mem_1rw_sync_mask_write_bit_synth</pre>
<pre>  #(parameter width_p=-1</pre>
<pre>    , parameter els_p=-1</pre>
<pre>    , parameter addr_width_lp=`BSG_SAFE_CLOG2(els_p)</pre>
<pre>   )</pre>
<pre>    , input reset_i</pre>
<pre>    , input [width_p-1:0] data_i</pre>
<pre>    , input [addr_width_lp-1:0] addr_i</pre>
<pre>    , input v_i</pre>
<pre>    , input [width_p-1:0] w_mask_i</pre>
<pre>    , input w_i</pre>
<pre>    , output logic [width_p-1:0]  data_o</pre>
<pre>    );</pre>
<pre></pre>
<pre>   logic [width_p-1:0] mem [els_p-1:0];</pre>
<pre>   logic read_en;</pre>
<pre></pre>
<pre></pre>
<pre>     if (read_en)</pre>
<pre>       addr_r <= addr_i;</pre>
<pre>     else</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;">     begin: llr</pre>
<pre style="background-color: #FF0000;">      logic read_en_r; </pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">        .width_p(1)</pre>
<pre style="background-color: #FF0000;">      ) read_en_dff (</pre>
<pre style="background-color: #FF0000;">        .clk_i(clk_i)</pre>
<pre style="background-color: #FF0000;">        ,.data_i(read_en)</pre>
<pre style="background-color: #FF0000;">        ,.data_o(read_en_r)</pre>
<pre style="background-color: #FF0000;">      );</pre>
<pre style="background-color: #FF0000;">        .width_p(width_p)</pre>
<pre style="background-color: #FF0000;">      ) dff_bypass (</pre>
<pre style="background-color: #FF0000;">        .clk_i(clk_i)</pre>
<pre style="background-color: #FF0000;">        ,.en_i(read_en_r)</pre>
<pre style="background-color: #FF0000;">        ,.data_i(data_out)</pre>
<pre style="background-color: #FF0000;">        ,.data_o(data_o)</pre>
<pre style="background-color: #FF0000;">      );</pre>
<pre>       assign data_o = data_out;</pre>
<pre>     end</pre>
<pre>   always_ff @(posedge clk_i)</pre>
<pre>     if (v_i & w_i)</pre>
<pre>       for (integer i = 0; i < width_p; i=i+1)</pre>
<pre>         if (w_mask_i[i])</pre>
<pre>           mem[addr_i][i] <= data_i[i];</pre>
<h3>./external/basejump_stl/bsg_mem/bsg_mem_1rw_sync_mask_write_byte_synth.v</h3>
<pre>module bsg_mem_1rw_sync_mask_write_byte_synth</pre>
<pre>    , parameter addr_width_lp = `BSG_SAFE_CLOG2(els_p)</pre>
<pre>    , parameter latch_last_read_p=0</pre>
<pre></pre>
<pre>    , parameter write_mask_width_lp = data_width_p>>3</pre>
<pre>  )</pre>
<pre>   ,input reset_i</pre>
<pre></pre>
<pre>   ,input w_i</pre>
<pre></pre>
<pre>   ,input [data_width_p-1:0]        data_i</pre>
<pre>    // for each bit set in the mask, a byte is written</pre>
<pre></pre>
<pre>  );</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">  begin: bk</pre>
<pre style="background-color: #FF0000;">    bsg_mem_1rw_sync #( .width_p      (8)</pre>
<pre style="background-color: #FF0000;">                        ,.els_p        (els_p)</pre>
<pre style="background-color: #FF0000;">                        ,.addr_width_lp(addr_width_lp)</pre>
<pre style="background-color: #FF0000;">                        ,.latch_last_read_p(latch_last_read_p)</pre>
<pre style="background-color: #FF0000;">                      ) mem_1rw_sync</pre>
<pre style="background-color: #FF0000;">                      ( .clk_i  (clk_i)</pre>
<pre style="background-color: #FF0000;">                       ,.reset_i(reset_i)</pre>
<pre style="background-color: #FF0000;">                       ,.data_i (data_i[(i*8)+:8])</pre>
<pre style="background-color: #FF0000;">                       ,.addr_i (addr_i)</pre>
<pre style="background-color: #FF0000;">                       ,.v_i    (v_i)</pre>
<pre style="background-color: #FF0000;">                       ,.w_i    (w_i & write_mask_i[i])</pre>
<pre style="background-color: #FF0000;">                       ,.data_o (data_o[(i*8)+:8])</pre>
<pre style="background-color: #FF0000;">                      );</pre>
<h3>./external/basejump_stl/bsg_mem/bsg_mem_1rw_sync_synth.v</h3>
<pre>module bsg_mem_1rw_sync_synth</pre>
<pre>  #(parameter width_p=-1</pre>
<pre>    , parameter els_p=-1</pre>
<pre>    , parameter addr_width_lp=`BSG_SAFE_CLOG2(els_p)</pre>
<pre>   )</pre>
<pre>	 	, input v_i</pre>
<pre>		, input reset_i</pre>
<pre>    , input [width_p-1:0] data_i</pre>
<pre>    , input [addr_width_lp-1:0] addr_i</pre>
<pre>    , input w_i</pre>
<pre>    , output logic [width_p-1:0]  data_o</pre>
<pre>    );</pre>
<pre></pre>
<pre>  logic [width_p-1:0]    mem [els_p-1:0];</pre>
<pre>  logic read_en;</pre>
<pre>  logic [width_p-1:0] data_out;</pre>
<pre></pre>
<pre>  assign data_out = mem[addr_r];</pre>
<pre></pre>
<pre>    if (read_en)</pre>
<pre>      addr_r <= addr_i;</pre>
<pre>    else</pre>
<pre></pre>
<pre style="background-color: #FF0000;">    begin: llr</pre>
<pre style="background-color: #FF0000;">      logic read_en_r; </pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">        .width_p(1)</pre>
<pre style="background-color: #FF0000;">      ) read_en_dff (</pre>
<pre style="background-color: #FF0000;">        .clk_i(clk_i)</pre>
<pre style="background-color: #FF0000;">        ,.data_i(read_en)</pre>
<pre style="background-color: #FF0000;">        ,.data_o(read_en_r)</pre>
<pre style="background-color: #FF0000;">      );</pre>
<pre style="background-color: #FF0000;">        .width_p(width_p)</pre>
<pre style="background-color: #FF0000;">      ) dff_bypass (</pre>
<pre style="background-color: #FF0000;">        .clk_i(clk_i)</pre>
<pre style="background-color: #FF0000;">        ,.en_i(read_en_r)</pre>
<pre style="background-color: #FF0000;">        ,.data_i(data_out)</pre>
<pre style="background-color: #FF0000;">        ,.data_o(data_o)</pre>
<pre style="background-color: #FF0000;">      );</pre>
<pre>      assign data_o = data_out;</pre>
<pre>    end</pre>
<pre>    if (v_i & w_i) </pre>
<pre>      mem[addr_i] <= data_i;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">     begin</pre>
<pre>        $display("## %L: instantiating width_p=%d, els_p=%d (%m)",width_p,els_p);</pre>
<pre>     end</pre>
<pre>     if (v_i)</pre>
<pre>       assert ( (v_i !== 1'b1) || (reset_i === 'X) || (reset_i === 1'b1) || (addr_i < els_p))</pre>
<pre>         else $error("Invalid address %x to %m of size %x (reset_i = %b, v_i = %b, clk_i = %b)\n", addr_i, els_p, reset_i, v_i, clk_i);</pre>
<pre>   // synopsys translate_on</pre>
<h3>./external/basejump_stl/bsg_mem/bsg_mem_2r1w_sync.v</h3>
<pre>module bsg_mem_2r1w_sync #(parameter width_p=-1</pre>
<pre>                           , parameter els_p=-1</pre>
<pre>                           , parameter addr_width_lp=`BSG_SAFE_CLOG2(els_p)</pre>
<pre>                           , parameter harden_p=0</pre>
<pre>                           , parameter enable_clock_gating_p=0</pre>
<pre>                           )</pre>
<pre>    , input reset_i</pre>
<pre></pre>
<pre>    , input [addr_width_lp-1:0] w_addr_i</pre>
<pre>    , input [width_p-1:0]       w_data_i</pre>
<pre></pre>
<pre>    , input [addr_width_lp-1:0]  r0_addr_i</pre>
<pre>    , output logic [width_p-1:0] r0_data_o</pre>
<pre></pre>
<pre>    , input [addr_width_lp-1:0]  r1_addr_i</pre>
<pre>    , output logic [width_p-1:0] r1_data_o</pre>
<pre>    );</pre>
<pre></pre>
<pre>     begin</pre>
<pre style="background-color: #FF0000;">       bsg_clkgate_optional icg</pre>
<pre style="background-color: #FF0000;">         (.clk_i( clk_i )</pre>
<pre style="background-color: #FF0000;">         ,.en_i( w_v_i | r0_v_i | r1_v_i )</pre>
<pre style="background-color: #FF0000;">         ,.bypass_i( 1'b0 )</pre>
<pre style="background-color: #FF0000;">         ,.gated_clock_o( clk_lo )</pre>
<pre style="background-color: #FF0000;">         );</pre>
<pre>       assign clk_lo = clk_i;</pre>
<pre>     end</pre>
<pre>     #(.width_p(width_p)</pre>
<pre>       ,.els_p(els_p)</pre>
<pre>       ,.read_write_same_addr_p(read_write_same_addr_p)</pre>
<pre>       ,.harden_p(harden_p)</pre>
<pre>       ) synth</pre>
<pre style="background-color: #FF0000;">    (.clk_i( clk_lo )</pre>
<pre>    ,.reset_i</pre>
<pre>    ,.w_v_i</pre>
<pre>    ,.w_addr_i</pre>
<pre>    ,.w_data_i</pre>
<pre>    ,.r0_v_i</pre>
<pre>    ,.r0_addr_i</pre>
<pre>    ,.r0_data_o</pre>
<pre>    ,.r1_v_i</pre>
<pre>    ,.r1_addr_i</pre>
<pre>    ,.r1_data_o</pre>
<pre>    );</pre>
<pre>     if (w_v_i)</pre>
<pre>       begin</pre>
<pre>          assert (w_addr_i < els_p)</pre>
<pre>            else $error("Invalid address %x to %m of size %x\n", w_addr_i, els_p);</pre>
<pre></pre>
<pre>            else $error("%m: port 0 Attempt to read and write same address");</pre>
<pre></pre>
<pre>            else $error("%m: port 1 Attempt to read and write same address");</pre>
<pre>       end</pre>
<pre style="background-color: #FF0000;">     begin</pre>
<pre>        $display("## %L: instantiating width_p=%d, els_p=%d, read_write_same_addr_p=%d, harden_p=%d (%m)"</pre>
<pre>		 ,width_p,els_p,read_write_same_addr_p,harden_p);</pre>
<pre>     end</pre>
<h3>./external/basejump_stl/bsg_mem/bsg_mem_2r1w_sync_synth.v</h3>
<pre>module bsg_mem_2r1w_sync_synth #(parameter width_p=-1</pre>
<pre>				 , parameter els_p=-1</pre>
<pre>				 , parameter addr_width_lp=`BSG_SAFE_CLOG2(els_p)</pre>
<pre>				 , parameter harden_p=0</pre>
<pre>				 )</pre>
<pre>    , input reset_i</pre>
<pre></pre>
<pre>    , input [addr_width_lp-1:0] w_addr_i</pre>
<pre>    , input [width_p-1:0]       w_data_i</pre>
<pre></pre>
<pre>    , input [addr_width_lp-1:0]  r0_addr_i</pre>
<pre>    , output logic [width_p-1:0] r0_data_o</pre>
<pre></pre>
<pre>    , input [addr_width_lp-1:0]  r1_addr_i</pre>
<pre>    , output logic [width_p-1:0] r1_data_o</pre>
<pre>    );</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre>     if (r0_v_i)</pre>
<pre>       r0_addr_r <= r0_addr_i;</pre>
<pre>     else</pre>
<pre></pre>
<pre>     if (r1_v_i)</pre>
<pre>       r1_addr_r <= r1_addr_i;</pre>
<pre>     else</pre>
<pre></pre>
<pre>   assign r1_data_o = mem[ r1_addr_r ];</pre>
<pre></pre>
<pre>     if (w_v_i)</pre>
<pre>       mem[w_addr_i] <= w_data_i;</pre>
<pre></pre>
<h3>./external/basejump_stl/bsg_misc/bsg_arb_fixed.v</h3>
<pre>module bsg_arb_fixed #(parameter     inputs_p = "inv"</pre>
<pre>                       , parameter lo_to_hi_p = "inv")</pre>
<pre>   ( input ready_i</pre>
<pre>     , input  [inputs_p-1:0] reqs_i</pre>
<pre>     , output [inputs_p-1:0] grants_o</pre>
<pre>   logic [inputs_p-1:0] grants_unmasked_lo;</pre>
<pre>   bsg_priority_encode_one_hot_out #(.width_p    (inputs_p)</pre>
<pre>                                     ,.lo_to_hi_p(lo_to_hi_p)</pre>
<pre style="background-color: #FF0000;">                                     ) enc</pre>
<pre>     (.i ( reqs_i            )</pre>
<pre>      ,.o( grants_unmasked_lo)</pre>
<pre>   assign grants_o = grants_unmasked_lo & { (inputs_p) { ready_i } };</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_array_concentrate_static.v</h3>
<pre>module bsg_array_concentrate_static </pre>
<pre>  #(parameter pattern_els_p="inv"</pre>
<pre>    , parameter width_p="inv"</pre>
<pre>    , sparse_els_lp=`BSG_COUNTONES_SYNTH(pattern_els_p))</pre>
<pre>   ,output [sparse_els_lp-1:0][width_p-1:0] o</pre>
<pre>);</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">     assign o[0]=i[0];</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">     begin : rof</pre>
<pre style="background-color: #FF0000;">       if (pattern_els_p[j])</pre>
<pre style="background-color: #FF0000;">         assign o[`BSG_COUNTONES_SYNTH(pattern_els_p[j-1:0])] = i[j];</pre>
<pre style="background-color: #FF0000;">     end</pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./external/basejump_stl/bsg_misc/bsg_dff_chain.v</h3>
<pre>module bsg_dff_chain #(</pre>
<pre>                 parameter       width_p         =       -1</pre>
<pre>                ,parameter       num_stages_p    =       1</pre>
<pre>                 input                           clk_i</pre>
<pre>                ,input [width_p-1:0]             data_i</pre>
<pre>                ,output[width_p-1:0]             data_o</pre>
<pre style="background-color: #FF0000;">        if( num_stages_p == 0) begin:pass_through</pre>
<pre style="background-color: #FF0000;">                assign data_o   = data_i;</pre>
<pre style="background-color: #FF0000;">        end:pass_through</pre>
<pre>        else begin:chained</pre>
<pre style="background-color: #FF0000;">                logic [num_stages_p:0][width_p-1:0] data_delayed;</pre>
<pre>                assign data_delayed[0]  = data_i                        ;</pre>
<pre>                assign data_o           = data_delayed[num_stages_p]    ;</pre>
<pre style="background-color: #FF0000;">                genvar i;</pre>
<pre>                for(i=1; i<= num_stages_p; i++) begin</pre>
<pre>                        bsg_dff #( .width_p ( width_p ) )</pre>
<pre style="background-color: #FF0000;">                                ch_reg (</pre>
<pre>                                        .clk_i        ( clk_i                 )</pre>
<pre>                                       ,.data_i         ( data_delayed[ i-1 ]   )</pre>
<pre>                                       ,.data_o         ( data_delayed[ i   ]   )</pre>
<pre style="background-color: #FF0000;">        end:chained</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_circular_ptr.v</h3>
<pre>module bsg_circular_ptr #(parameter slots_p     = -1</pre>
<pre>                          , parameter max_add_p = -1</pre>
<pre>			  )</pre>
<pre>    , input reset_i</pre>
<pre>    , input  [$clog2(max_add_p+1)-1:0] add_i</pre>
<pre>    , output [ptr_width_lp-1:0] o</pre>
<pre>    );</pre>
<pre>   logic [ptr_width_lp:0]   ptr_wrap;</pre>
<pre></pre>
<pre></pre>
<pre>     if (reset_i) ptr_r <= 0;</pre>
<pre>     else       ptr_r <= ptr_n;</pre>
<pre></pre>
<pre>     begin</pre>
<pre>	assign ptr_n = 1'b0;</pre>
<pre>	wire ignore = |add_i;</pre>
<pre>     end</pre>
<pre>       begin</pre>
<pre style="background-color: #FF0000;">	  // reduce critical path on add_i signal</pre>
<pre>	    begin</pre>
<pre>	       wire [ptr_width_lp-1:0] ptr_r_p1 = ptr_r + 1'b1;</pre>
<pre>	       assign  ptr_n = add_i ? ptr_r_p1 : ptr_r;</pre>
<pre>	    end</pre>
<pre>       end</pre>
<pre>          always_comb</pre>
<pre>            begin</pre>
<pre>               // compute wrapped and non-wrap cases</pre>
<pre>               ptr_n = ptr_r + add_i;</pre>
<pre></pre>
<pre>                 ptr_n = ptr_wrap[0+:ptr_width_lp];</pre>
<pre></pre>
<pre>                 else $error("bsg_circular_ptr counter overflow (ptr_r=%b/add_i=%b/ptr_wrap=%b/ptr_n=%b)",ptr_r,add_i,ptr_wrap,ptr_n, slots_p);</pre>
<pre>	       // synopsys translate_on</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_dff_reset_en.v</h3>
<pre>module bsg_dff_reset_en</pre>
<pre>  #(parameter width_p="inv"</pre>
<pre>    , parameter reset_val_p=0</pre>
<pre>    , parameter harden_p=0</pre>
<pre>    input clk_i</pre>
<pre>    , input reset_i</pre>
<pre>    , input en_i</pre>
<pre>    , input [width_p-1:0] data_i</pre>
<pre>    , output logic [width_p-1:0] data_o</pre>
<pre>  logic  [width_p-1:0] data_r;</pre>
<pre>  assign data_o = data_r;</pre>
<pre>  always_ff @ (posedge clk_i) begin</pre>
<pre>    if (reset_i) begin</pre>
<pre>      data_r <= width_p'(reset_val_p);</pre>
<pre>    else begin</pre>
<pre>      if (en_i) begin</pre>
<pre>        data_r <= data_i;</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_lfsr.v</h3>
<pre>module bsg_lfsr #(parameter width_p=-1</pre>
<pre>                  , init_val_p = 1 // an initial value of zero is typically the null point for LFSR's.</pre>
<pre>                  , xor_mask_p = 0)</pre>
<pre>   (input clk</pre>
<pre>    , input reset_i</pre>
<pre>    , input yumi_i</pre>
<pre>    , output logic [width_p-1:0] o</pre>
<pre>   logic [width_p-1:0] o_r, o_n, xor_mask;</pre>
<pre>   assign o = o_r;</pre>
<pre>   if (xor_mask_p == 0)</pre>
<pre>     begin : automask</pre>
<pre>        case (width_p)</pre>
<pre style="background-color: #FF0000;">          32:</pre>
<pre style="background-color: #FF0000;">            assign xor_mask = (1 << 31) | (1 << 29) | (1 << 26) | (1 << 25);</pre>
<pre style="background-color: #FF0000;">          60:</pre>
<pre style="background-color: #FF0000;">            assign xor_mask = (1 << 59) | (1 << 58);</pre>
<pre style="background-color: #FF0000;">          64:</pre>
<pre style="background-color: #FF0000;">            assign xor_mask = (1 << 63) | (1 << 62) | (1 << 60) | (1 << 59);</pre>
<pre style="background-color: #FF0000;">          default:</pre>
<pre>            initial assert(width_p==-1)</pre>
<pre style="background-color: #FF0000;">              else</pre>
<pre>                begin</pre>
<pre>                   $display("unhandled default mask for width %d in bsg_lfsr",width_p); $finish();</pre>
<pre style="background-color: #FF0000;">     begin: fi</pre>
<pre style="background-color: #FF0000;">        assign xor_mask = xor_mask_p;</pre>
<pre>   always @(posedge clk)</pre>
<pre>     begin</pre>
<pre>        if (reset_i)</pre>
<pre>          o_r <= (width_p) ' (init_val_p);</pre>
<pre>        else if (yumi_i)</pre>
<pre>          o_r <= o_n;</pre>
<pre>   assign o_n = (o_r >> 1) ^ ({width_p {o_r[0]}} & xor_mask);</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_lru_pseudo_tree_decode.v</h3>
<pre>module bsg_lru_pseudo_tree_decode</pre>
<pre>    ,localparam lg_ways_lp = `BSG_SAFE_CLOG2(ways_p)</pre>
<pre>  )</pre>
<pre>   , output logic [ways_p-2:0] data_o</pre>
<pre>   , output logic [ways_p-2:0] mask_o</pre>
<pre>  );</pre>
<pre style="background-color: #FF0000;">  generate </pre>
<pre style="background-color: #FF0000;">    for(i=0; i<ways_p-1; i++) begin: rof</pre>
<pre>      // Mask generation</pre>
<pre>	    assign mask_o[i] = 1'b1;</pre>
<pre>	  end</pre>
<pre style="background-color: #FF0000;">	    assign mask_o[i] = mask_o[(i-1)/2] & ~way_id_i[lg_ways_lp-`BSG_SAFE_CLOG2(i+2)+1];</pre>
<pre>	  end</pre>
<pre style="background-color: #FF0000;">	    assign mask_o[i] = mask_o[(i-2)/2] & way_id_i[lg_ways_lp-`BSG_SAFE_CLOG2(i+2)+1];</pre>
<pre style="background-color: #FF0000;">	  end</pre>
<pre>    end</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_thermometer_count.v</h3>
<pre>module bsg_thermometer_count #(parameter width_p = -1)</pre>
<pre>   (input [width_p-1:0] i</pre>
<pre>    , output [$clog2(width_p+1)-1:0] o</pre>
<pre style="background-color: #FF0000;">   if (width_p == 1)</pre>
<pre style="background-color: #FF0000;">     assign o = i;</pre>
<pre>     if (width_p == 2)</pre>
<pre>       assign o = { i[1], i[0] & ~ i[1] };</pre>
<pre style="background-color: #FF0000;">       if (width_p == 3)</pre>
<pre style="background-color: #FF0000;">         assign o = { i[1], i[2] | (i[0] & ~i[1]) };</pre>
<pre style="background-color: #FF0000;">         if (width_p == 4)</pre>
<pre style="background-color: #FF0000;">           assign o = {i[3], ~i[3] & i[1], ^i };</pre>
<pre style="background-color: #FF0000;">           begin : big</pre>
<pre style="background-color: #FF0000;">              wire [width_p:0] one_hot =   (  ~{ 1'b0,      i } )</pre>
<pre style="background-color: #FF0000;">                & (   { i   ,   1'b1 } );</pre>
<pre style="background-color: #FF0000;">              bsg_encode_one_hot #(.width_p(width_p+1)) encode_one_hot</pre>
<pre style="background-color: #FF0000;">                (.i(one_hot)</pre>
<pre style="background-color: #FF0000;">                 ,.addr_o(o)</pre>
<pre style="background-color: #FF0000;">                 ,.v_o()</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_round_robin_arb.v</h3>
<pre>                                     ,lg_inputs_p   =`BSG_SAFE_CLOG2(inputs_p)</pre>
<pre style="background-color: #FF0000;">                                     ,reset_on_sr_p = 1'b0</pre>
<pre style="background-color: #FF0000;">                                     ,hold_on_sr_p  = 1'b0 )</pre>
<pre style="background-color: #FF0000;">    (input clk_i</pre>
<pre>    , input reset_i</pre>
<pre>    , input grants_en_i // whether to suppress grants_o</pre>
<pre></pre>
<pre>    , output logic [inputs_p-1:0] grants_o</pre>
<pre>    , output logic [inputs_p-1:0] sel_one_hot_o</pre>
<pre></pre>
<pre>    , output logic [lg_inputs_p-1:0] tag_o // to which input the grant was given</pre>
<pre>    , input yumi_i                         // yes, go ahead with whatever grants_o proposed</pre>
<pre>    );</pre>
<pre>logic hold_on_sr, reset_on_sr;</pre>
<pre></pre>
<pre>begin: inputs_1</pre>
<pre></pre>
<pre></pre>
<pre>begin</pre>
<pre>  unique casez({last_r, reqs_i})</pre>
<pre>    2'b?_0: begin sel_one_hot_n = 1'b0; tag_o = (lg_inputs_p) ' (0); end // X</pre>
<pre>assign grants_o      = sel_one_hot_n & {1{grants_en_i}} ;   </pre>
<pre>    </pre>
<pre style="background-color: #FF0000;">   </pre>
<pre style="background-color: #FF0000;">        unique casez( last_r )</pre>
<pre style="background-color: #FF0000;">           1'b0 : hold_on_sr = ( reqs_i == 1'b1 );</pre>
<pre style="background-color: #FF0000;">           default : hold_on_sr = 1'b0;</pre>
<pre style="background-color: #FF0000;">       endcase</pre>
<pre>    assign hold_on_sr = '0;</pre>
<pre>end //end of hold_on_sr_p </pre>
<pre style="background-color: #FF0000;">    assign reset_on_sr = ( reqs_i == 1'b1 ) </pre>
<pre style="background-color: #FF0000;">                       ;</pre>
<pre>    assign reset_on_sr = '0;</pre>
<pre>end //end of reset_on_sr_p </pre>
<pre style="background-color: #FF0000;"></pre>
<pre>begin: inputs_2</pre>
<pre></pre>
<pre></pre>
<pre>begin</pre>
<pre>  unique casez({last_r, reqs_i})</pre>
<pre>    3'b?_00: begin sel_one_hot_n = 2'b00; tag_o = (lg_inputs_p) ' (0); end // X</pre>
<pre>assign grants_o      = sel_one_hot_n & {2{grants_en_i}} ;   </pre>
<pre>    </pre>
<pre style="background-color: #FF0000;">   </pre>
<pre style="background-color: #FF0000;">        unique casez( last_r )</pre>
<pre style="background-color: #FF0000;">           1'b0 : hold_on_sr = ( reqs_i == 2'b01 );</pre>
<pre style="background-color: #FF0000;">           default: hold_on_sr = ( reqs_i == 2'b10 );</pre>
<pre style="background-color: #FF0000;">       endcase</pre>
<pre>    assign hold_on_sr = '0;</pre>
<pre>end //end of hold_on_sr_p </pre>
<pre style="background-color: #FF0000;">    assign reset_on_sr = ( reqs_i == 2'b01 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 2'b10 ) </pre>
<pre style="background-color: #FF0000;">                       ;</pre>
<pre>    assign reset_on_sr = '0;</pre>
<pre>end //end of reset_on_sr_p </pre>
<pre style="background-color: #FF0000;"></pre>
<pre>begin: inputs_3</pre>
<pre></pre>
<pre></pre>
<pre>begin</pre>
<pre>  unique casez({last_r, reqs_i})</pre>
<pre>    5'b??_000: begin sel_one_hot_n = 3'b000; tag_o = (lg_inputs_p) ' (0); end // X</pre>
<pre>assign grants_o      = sel_one_hot_n & {3{grants_en_i}} ;   </pre>
<pre>    </pre>
<pre style="background-color: #FF0000;">   </pre>
<pre style="background-color: #FF0000;">        unique casez( last_r )</pre>
<pre style="background-color: #FF0000;">           2'b00 : hold_on_sr = ( reqs_i == 3'b010 );</pre>
<pre style="background-color: #FF0000;">           2'b01 : hold_on_sr = ( reqs_i == 3'b001 );</pre>
<pre style="background-color: #FF0000;">           2'b10 : hold_on_sr = ( reqs_i == 3'b100 );</pre>
<pre style="background-color: #FF0000;">           default : hold_on_sr = 1'b0;</pre>
<pre style="background-color: #FF0000;">       endcase</pre>
<pre>    assign hold_on_sr = '0;</pre>
<pre>end //end of hold_on_sr_p </pre>
<pre style="background-color: #FF0000;">    assign reset_on_sr = ( reqs_i == 3'b010 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 3'b001 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 3'b100 ) </pre>
<pre style="background-color: #FF0000;">                       ;</pre>
<pre>    assign reset_on_sr = '0;</pre>
<pre>end //end of reset_on_sr_p </pre>
<pre style="background-color: #FF0000;"></pre>
<pre>begin: inputs_4</pre>
<pre></pre>
<pre></pre>
<pre>begin</pre>
<pre>  unique casez({last_r, reqs_i})</pre>
<pre>    6'b??_0000: begin sel_one_hot_n = 4'b0000; tag_o = (lg_inputs_p) ' (0); end // X</pre>
<pre>assign grants_o      = sel_one_hot_n & {4{grants_en_i}} ;   </pre>
<pre>    </pre>
<pre style="background-color: #FF0000;">   </pre>
<pre style="background-color: #FF0000;">        unique casez( last_r )</pre>
<pre style="background-color: #FF0000;">           2'b00 : hold_on_sr = ( reqs_i == 4'b0100 );</pre>
<pre style="background-color: #FF0000;">           2'b01 : hold_on_sr = ( reqs_i == 4'b0010 );</pre>
<pre style="background-color: #FF0000;">           2'b10 : hold_on_sr = ( reqs_i == 4'b0001 );</pre>
<pre style="background-color: #FF0000;">           default: hold_on_sr = ( reqs_i == 4'b1000 );</pre>
<pre style="background-color: #FF0000;">       endcase</pre>
<pre>    assign hold_on_sr = '0;</pre>
<pre>end //end of hold_on_sr_p </pre>
<pre style="background-color: #FF0000;">    assign reset_on_sr = ( reqs_i == 4'b0100 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 4'b0010 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 4'b0001 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 4'b1000 ) </pre>
<pre style="background-color: #FF0000;">                       ;</pre>
<pre>    assign reset_on_sr = '0;</pre>
<pre>end //end of reset_on_sr_p </pre>
<pre style="background-color: #FF0000;"></pre>
<pre>begin: inputs_5</pre>
<pre></pre>
<pre></pre>
<pre>begin</pre>
<pre>  unique casez({last_r, reqs_i})</pre>
<pre>    8'b???_00000: begin sel_one_hot_n = 5'b00000; tag_o = (lg_inputs_p) ' (0); end // X</pre>
<pre>assign grants_o      = sel_one_hot_n & {5{grants_en_i}} ;   </pre>
<pre>    </pre>
<pre style="background-color: #FF0000;">   </pre>
<pre style="background-color: #FF0000;">        unique casez( last_r )</pre>
<pre style="background-color: #FF0000;">           3'b000 : hold_on_sr = ( reqs_i == 5'b01000 );</pre>
<pre style="background-color: #FF0000;">           3'b001 : hold_on_sr = ( reqs_i == 5'b00100 );</pre>
<pre style="background-color: #FF0000;">           3'b010 : hold_on_sr = ( reqs_i == 5'b00010 );</pre>
<pre style="background-color: #FF0000;">           3'b011 : hold_on_sr = ( reqs_i == 5'b00001 );</pre>
<pre style="background-color: #FF0000;">           3'b100 : hold_on_sr = ( reqs_i == 5'b10000 );</pre>
<pre style="background-color: #FF0000;">           default : hold_on_sr = 1'b0;</pre>
<pre style="background-color: #FF0000;">       endcase</pre>
<pre>    assign hold_on_sr = '0;</pre>
<pre>end //end of hold_on_sr_p </pre>
<pre style="background-color: #FF0000;">    assign reset_on_sr = ( reqs_i == 5'b01000 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 5'b00100 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 5'b00010 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 5'b00001 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 5'b10000 ) </pre>
<pre style="background-color: #FF0000;">                       ;</pre>
<pre>    assign reset_on_sr = '0;</pre>
<pre>end //end of reset_on_sr_p </pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">begin: inputs_6</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">begin</pre>
<pre style="background-color: #FF0000;">  unique casez({last_r, reqs_i})</pre>
<pre style="background-color: #FF0000;">    9'b???_000000: begin sel_one_hot_n = 6'b000000; tag_o = (lg_inputs_p) ' (0); end // X</pre>
<pre style="background-color: #FF0000;">assign grants_o      = sel_one_hot_n & {6{grants_en_i}} ;   </pre>
<pre style="background-color: #FF0000;">    </pre>
<pre style="background-color: #FF0000;">   </pre>
<pre style="background-color: #FF0000;">        unique casez( last_r )</pre>
<pre style="background-color: #FF0000;">           3'b000 : hold_on_sr = ( reqs_i == 6'b010000 );</pre>
<pre style="background-color: #FF0000;">           3'b001 : hold_on_sr = ( reqs_i == 6'b001000 );</pre>
<pre style="background-color: #FF0000;">           3'b010 : hold_on_sr = ( reqs_i == 6'b000100 );</pre>
<pre style="background-color: #FF0000;">           3'b011 : hold_on_sr = ( reqs_i == 6'b000010 );</pre>
<pre style="background-color: #FF0000;">           3'b100 : hold_on_sr = ( reqs_i == 6'b000001 );</pre>
<pre style="background-color: #FF0000;">           3'b101 : hold_on_sr = ( reqs_i == 6'b100000 );</pre>
<pre style="background-color: #FF0000;">           default : hold_on_sr = 1'b0;</pre>
<pre style="background-color: #FF0000;">       endcase</pre>
<pre style="background-color: #FF0000;">    assign hold_on_sr = '0;</pre>
<pre style="background-color: #FF0000;">end //end of hold_on_sr_p </pre>
<pre style="background-color: #FF0000;">    assign reset_on_sr = ( reqs_i == 6'b010000 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 6'b001000 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 6'b000100 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 6'b000010 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 6'b000001 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 6'b100000 ) </pre>
<pre style="background-color: #FF0000;">                       ;</pre>
<pre style="background-color: #FF0000;">    assign reset_on_sr = '0;</pre>
<pre style="background-color: #FF0000;">end //end of reset_on_sr_p </pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">begin: inputs_7</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">begin</pre>
<pre style="background-color: #FF0000;">  unique casez({last_r, reqs_i})</pre>
<pre style="background-color: #FF0000;">    10'b???_0000000: begin sel_one_hot_n = 7'b0000000; tag_o = (lg_inputs_p) ' (0); end // X</pre>
<pre style="background-color: #FF0000;">assign grants_o      = sel_one_hot_n & {7{grants_en_i}} ;   </pre>
<pre style="background-color: #FF0000;">    </pre>
<pre style="background-color: #FF0000;">   </pre>
<pre style="background-color: #FF0000;">        unique casez( last_r )</pre>
<pre style="background-color: #FF0000;">           3'b000 : hold_on_sr = ( reqs_i == 7'b0100000 );</pre>
<pre style="background-color: #FF0000;">           3'b001 : hold_on_sr = ( reqs_i == 7'b0010000 );</pre>
<pre style="background-color: #FF0000;">           3'b010 : hold_on_sr = ( reqs_i == 7'b0001000 );</pre>
<pre style="background-color: #FF0000;">           3'b011 : hold_on_sr = ( reqs_i == 7'b0000100 );</pre>
<pre style="background-color: #FF0000;">           3'b100 : hold_on_sr = ( reqs_i == 7'b0000010 );</pre>
<pre style="background-color: #FF0000;">           3'b101 : hold_on_sr = ( reqs_i == 7'b0000001 );</pre>
<pre style="background-color: #FF0000;">           3'b110 : hold_on_sr = ( reqs_i == 7'b1000000 );</pre>
<pre style="background-color: #FF0000;">           default : hold_on_sr = 1'b0;</pre>
<pre style="background-color: #FF0000;">       endcase</pre>
<pre style="background-color: #FF0000;">    assign hold_on_sr = '0;</pre>
<pre style="background-color: #FF0000;">end //end of hold_on_sr_p </pre>
<pre style="background-color: #FF0000;">    assign reset_on_sr = ( reqs_i == 7'b0100000 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 7'b0010000 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 7'b0001000 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 7'b0000100 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 7'b0000010 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 7'b0000001 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 7'b1000000 ) </pre>
<pre style="background-color: #FF0000;">                       ;</pre>
<pre style="background-color: #FF0000;">    assign reset_on_sr = '0;</pre>
<pre style="background-color: #FF0000;">end //end of reset_on_sr_p </pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">begin: inputs_8</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">begin</pre>
<pre style="background-color: #FF0000;">  unique casez({last_r, reqs_i})</pre>
<pre style="background-color: #FF0000;">    11'b???_00000000: begin sel_one_hot_n = 8'b00000000; tag_o = (lg_inputs_p) ' (0); end // X</pre>
<pre style="background-color: #FF0000;">assign grants_o      = sel_one_hot_n & {8{grants_en_i}} ;   </pre>
<pre style="background-color: #FF0000;">    </pre>
<pre style="background-color: #FF0000;">   </pre>
<pre style="background-color: #FF0000;">        unique casez( last_r )</pre>
<pre style="background-color: #FF0000;">           3'b000 : hold_on_sr = ( reqs_i == 8'b01000000 );</pre>
<pre style="background-color: #FF0000;">           3'b001 : hold_on_sr = ( reqs_i == 8'b00100000 );</pre>
<pre style="background-color: #FF0000;">           3'b010 : hold_on_sr = ( reqs_i == 8'b00010000 );</pre>
<pre style="background-color: #FF0000;">           3'b011 : hold_on_sr = ( reqs_i == 8'b00001000 );</pre>
<pre style="background-color: #FF0000;">           3'b100 : hold_on_sr = ( reqs_i == 8'b00000100 );</pre>
<pre style="background-color: #FF0000;">           3'b101 : hold_on_sr = ( reqs_i == 8'b00000010 );</pre>
<pre style="background-color: #FF0000;">           3'b110 : hold_on_sr = ( reqs_i == 8'b00000001 );</pre>
<pre style="background-color: #FF0000;">           default: hold_on_sr = ( reqs_i == 8'b10000000 );</pre>
<pre style="background-color: #FF0000;">       endcase</pre>
<pre style="background-color: #FF0000;">    assign hold_on_sr = '0;</pre>
<pre style="background-color: #FF0000;">end //end of hold_on_sr_p </pre>
<pre style="background-color: #FF0000;">    assign reset_on_sr = ( reqs_i == 8'b01000000 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 8'b00100000 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 8'b00010000 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 8'b00001000 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 8'b00000100 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 8'b00000010 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 8'b00000001 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 8'b10000000 ) </pre>
<pre style="background-color: #FF0000;">                       ;</pre>
<pre style="background-color: #FF0000;">    assign reset_on_sr = '0;</pre>
<pre style="background-color: #FF0000;">end //end of reset_on_sr_p </pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">begin: inputs_9</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">begin</pre>
<pre style="background-color: #FF0000;">  unique casez({last_r, reqs_i})</pre>
<pre style="background-color: #FF0000;">    13'b????_000000000: begin sel_one_hot_n = 9'b000000000; tag_o = (lg_inputs_p) ' (0); end // X</pre>
<pre style="background-color: #FF0000;">assign grants_o      = sel_one_hot_n & {9{grants_en_i}} ;   </pre>
<pre style="background-color: #FF0000;">    </pre>
<pre style="background-color: #FF0000;">   </pre>
<pre style="background-color: #FF0000;">        unique casez( last_r )</pre>
<pre style="background-color: #FF0000;">           4'b0000 : hold_on_sr = ( reqs_i == 9'b010000000 );</pre>
<pre style="background-color: #FF0000;">           4'b0001 : hold_on_sr = ( reqs_i == 9'b001000000 );</pre>
<pre style="background-color: #FF0000;">           4'b0010 : hold_on_sr = ( reqs_i == 9'b000100000 );</pre>
<pre style="background-color: #FF0000;">           4'b0011 : hold_on_sr = ( reqs_i == 9'b000010000 );</pre>
<pre style="background-color: #FF0000;">           4'b0100 : hold_on_sr = ( reqs_i == 9'b000001000 );</pre>
<pre style="background-color: #FF0000;">           4'b0101 : hold_on_sr = ( reqs_i == 9'b000000100 );</pre>
<pre style="background-color: #FF0000;">           4'b0110 : hold_on_sr = ( reqs_i == 9'b000000010 );</pre>
<pre style="background-color: #FF0000;">           4'b0111 : hold_on_sr = ( reqs_i == 9'b000000001 );</pre>
<pre style="background-color: #FF0000;">           4'b1000 : hold_on_sr = ( reqs_i == 9'b100000000 );</pre>
<pre style="background-color: #FF0000;">           default : hold_on_sr = 1'b0;</pre>
<pre style="background-color: #FF0000;">       endcase</pre>
<pre style="background-color: #FF0000;">    assign hold_on_sr = '0;</pre>
<pre style="background-color: #FF0000;">end //end of hold_on_sr_p </pre>
<pre style="background-color: #FF0000;">    assign reset_on_sr = ( reqs_i == 9'b010000000 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 9'b001000000 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 9'b000100000 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 9'b000010000 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 9'b000001000 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 9'b000000100 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 9'b000000010 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 9'b000000001 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 9'b100000000 ) </pre>
<pre style="background-color: #FF0000;">                       ;</pre>
<pre style="background-color: #FF0000;">    assign reset_on_sr = '0;</pre>
<pre style="background-color: #FF0000;">end //end of reset_on_sr_p </pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">begin: inputs_10</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">begin</pre>
<pre style="background-color: #FF0000;">  unique casez({last_r, reqs_i})</pre>
<pre style="background-color: #FF0000;">    14'b????_0000000000: begin sel_one_hot_n = 10'b0000000000; tag_o = (lg_inputs_p) ' (0); end // X</pre>
<pre style="background-color: #FF0000;">assign grants_o      = sel_one_hot_n & {10{grants_en_i}} ;   </pre>
<pre style="background-color: #FF0000;">    </pre>
<pre style="background-color: #FF0000;">   </pre>
<pre style="background-color: #FF0000;">        unique casez( last_r )</pre>
<pre style="background-color: #FF0000;">           4'b0000 : hold_on_sr = ( reqs_i == 10'b0100000000 );</pre>
<pre style="background-color: #FF0000;">           4'b0001 : hold_on_sr = ( reqs_i == 10'b0010000000 );</pre>
<pre style="background-color: #FF0000;">           4'b0010 : hold_on_sr = ( reqs_i == 10'b0001000000 );</pre>
<pre style="background-color: #FF0000;">           4'b0011 : hold_on_sr = ( reqs_i == 10'b0000100000 );</pre>
<pre style="background-color: #FF0000;">           4'b0100 : hold_on_sr = ( reqs_i == 10'b0000010000 );</pre>
<pre style="background-color: #FF0000;">           4'b0101 : hold_on_sr = ( reqs_i == 10'b0000001000 );</pre>
<pre style="background-color: #FF0000;">           4'b0110 : hold_on_sr = ( reqs_i == 10'b0000000100 );</pre>
<pre style="background-color: #FF0000;">           4'b0111 : hold_on_sr = ( reqs_i == 10'b0000000010 );</pre>
<pre style="background-color: #FF0000;">           4'b1000 : hold_on_sr = ( reqs_i == 10'b0000000001 );</pre>
<pre style="background-color: #FF0000;">           4'b1001 : hold_on_sr = ( reqs_i == 10'b1000000000 );</pre>
<pre style="background-color: #FF0000;">           default : hold_on_sr = 1'b0;</pre>
<pre style="background-color: #FF0000;">       endcase</pre>
<pre style="background-color: #FF0000;">    assign hold_on_sr = '0;</pre>
<pre style="background-color: #FF0000;">end //end of hold_on_sr_p </pre>
<pre style="background-color: #FF0000;">    assign reset_on_sr = ( reqs_i == 10'b0100000000 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 10'b0010000000 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 10'b0001000000 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 10'b0000100000 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 10'b0000010000 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 10'b0000001000 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 10'b0000000100 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 10'b0000000010 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 10'b0000000001 ) </pre>
<pre style="background-color: #FF0000;">                       | ( reqs_i == 10'b1000000000 ) </pre>
<pre style="background-color: #FF0000;">                       ;</pre>
<pre style="background-color: #FF0000;">    assign reset_on_sr = '0;</pre>
<pre style="background-color: #FF0000;">end //end of reset_on_sr_p </pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre>  assign last_r = 1'b0;</pre>
<pre>else</pre>
<pre>    always_comb</pre>
<pre>      if( hold_on_sr_p ) begin: last_n_gen</pre>
<pre>        last_n = hold_on_sr ? last_r :</pre>
<pre>               ( yumi_i     ? tag_o  : last_r );  </pre>
<pre>      end else if( reset_on_sr_p ) begin: reset_on_last_n_gen</pre>
<pre>        last_n = reset_on_sr? (inputs_p-2) :</pre>
<pre>               ( yumi_i     ?tag_o : last_r );  </pre>
<pre>      end else</pre>
<pre></pre>
<pre>      last_r <= (reset_i) ? (lg_inputs_p)'(0):last_n;</pre>
<pre>  end</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_priority_encode_one_hot_out.v</h3>
<pre>module bsg_priority_encode_one_hot_out #(parameter width_p      = "inv"</pre>
<pre>                                         , parameter lo_to_hi_p = "inv"</pre>
<pre>   (input    [width_p-1:0] i</pre>
<pre>    , output [width_p-1:0] o</pre>
<pre>   logic [width_p-1:0] scan_lo;</pre>
<pre>   if (width_p == 1)</pre>
<pre>     assign o = i;</pre>
<pre>     begin</pre>
<pre>	bsg_scan #(.width_p(width_p)</pre>
<pre>		   ,.or_p      (1)</pre>
<pre>		   ,.lo_to_hi_p(lo_to_hi_p)</pre>
<pre>		   ) scan (.i (i)</pre>
<pre>			   ,.o(scan_lo)</pre>
<pre>	if (lo_to_hi_p)</pre>
<pre>	  assign o = scan_lo & { (~scan_lo[width_p-2:0]), 1'b1 };</pre>
<pre>	  assign o = scan_lo & { 1'b1, (~scan_lo[width_p-1:1]) };</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_lru_pseudo_tree_encode.v</h3>
<pre>module bsg_lru_pseudo_tree_encode</pre>
<pre>    ,localparam lg_ways_lp = `BSG_SAFE_CLOG2(ways_p)</pre>
<pre>  )</pre>
<pre>    , output logic [lg_ways_lp-1:0] way_id_o</pre>
<pre>  );</pre>
<pre>  logic [lg_ways_lp-1:0][ways_p-2:0]     pe_i;</pre>
<pre>  logic [lg_ways_lp-1:0][lg_ways_lp-1:0] pe_o;</pre>
<pre>  </pre>
<pre style="background-color: #FF0000;">  generate </pre>
<pre style="background-color: #FF0000;">    for(i=0; i<ways_p-1; i++) begin: rof</pre>
<pre>      if(i == 0) begin: fi</pre>
<pre>	    assign mask[i] = 1'b1;</pre>
<pre>	  end</pre>
<pre style="background-color: #FF0000;">	    assign mask[i] = mask[(i-1)/2] & ~lru_i[(i-1)/2];</pre>
<pre>	  end</pre>
<pre style="background-color: #FF0000;">	    assign mask[i] = mask[(i-2)/2] & lru_i[(i-2)/2];</pre>
<pre style="background-color: #FF0000;">	  end</pre>
<pre style="background-color: #FF0000;">    </pre>
<pre style="background-color: #FF0000;">    </pre>
<pre style="background-color: #FF0000;">	    assign pe_i[i] = mask;</pre>
<pre style="background-color: #FF0000;">	    assign pe_o[i] = '0;</pre>
<pre style="background-color: #FF0000;">	  end</pre>
<pre style="background-color: #FF0000;">        assign pe_i[i] = pe_i[i-1] ^ ({{(ways_p-2){1'b0}}, 1'b1} << pe_o[i-1]);</pre>
<pre style="background-color: #FF0000;">	  end</pre>
<pre style="background-color: #FF0000;">	    bsg_priority_encode </pre>
<pre style="background-color: #FF0000;">          #(.width_p(ways_p-1)</pre>
<pre style="background-color: #FF0000;">            ,.lo_to_hi_p(1'b1)</pre>
<pre style="background-color: #FF0000;">          ) pe </pre>
<pre style="background-color: #FF0000;">          (.i(pe_i[i])</pre>
<pre style="background-color: #FF0000;">           ,.addr_o(pe_o[i])</pre>
<pre style="background-color: #FF0000;">           ,.v_o()</pre>
<pre style="background-color: #FF0000;">          );</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_mux.v</h3>
<pre>module bsg_mux #(parameter width_p="inv"</pre>
<pre>                 , els_p=1</pre>
<pre>                 , harden_p = 0</pre>
<pre>                 , lg_els_lp=`BSG_SAFE_CLOG2(els_p)</pre>
<pre>                 )</pre>
<pre>    ,input [lg_els_lp-1:0] sel_i</pre>
<pre>    ,output [width_p-1:0] data_o</pre>
<pre>    );</pre>
<pre></pre>
<pre style="background-color: #FF0000;">     assert(balanced_p == 0)</pre>
<pre>       else $error("%m warning: synthesizable implementation of bsg_mux does not support balanced_p");</pre>
<pre>   // synopsys translate_on</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_mux_butterfly.v</h3>
<pre>module bsg_mux_butterfly</pre>
<pre>  #(parameter width_p="inv"</pre>
<pre>    , localparam lg_els_lp=`BSG_SAFE_CLOG2(els_p)</pre>
<pre>  )</pre>
<pre>    , input [lg_els_lp-1:0] sel_i</pre>
<pre>    , output logic [els_p-1:0][width_p-1:0] data_o</pre>
<pre>  );</pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;">    for (genvar j = 0; j < els_p/(2**(i+1)); j++) begin: mux_swap</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">        .width_p(width_p*(2**i))</pre>
<pre style="background-color: #FF0000;">      ) swap_inst (</pre>
<pre style="background-color: #FF0000;">        .data_i(data_stage[i][2*width_p*(2**i)*j+:2*width_p*(2**i)])</pre>
<pre style="background-color: #FF0000;">        ,.swap_i(sel_i[i])</pre>
<pre style="background-color: #FF0000;">        ,.data_o(data_stage[i+1][2*width_p*(2**i)*j+:2*width_p*(2**i)])</pre>
<pre style="background-color: #FF0000;">      );</pre>
<pre></pre>
<h3>./external/basejump_stl/bsg_misc/bsg_mux_one_hot.v</h3>
<pre>module bsg_mux_one_hot #(parameter width_p="inv"</pre>
<pre>                         , els_p=1</pre>
<pre>			 , harden_p=1</pre>
<pre>    input [els_p-1:0][width_p-1:0] data_i</pre>
<pre>    ,input [els_p-1:0] sel_one_hot_i</pre>
<pre>    ,output [width_p-1:0] data_o</pre>
<pre>   wire [els_p-1:0][width_p-1:0]   data_masked;</pre>
<pre style="background-color: #FF0000;">   genvar                          i,j;</pre>
<pre>   for (i = 0; i < els_p; i++)</pre>
<pre>     begin : mask</pre>
<pre>        assign data_masked[i] = data_i[i] & { width_p { sel_one_hot_i[i] } };</pre>
<pre>   for (i = 0; i < width_p; i++)</pre>
<pre>     begin: reduce</pre>
<pre>        wire [els_p-1:0] gather;</pre>
<pre>        for (j = 0; j < els_p; j++)</pre>
<pre>          assign gather[j] = data_masked[j][i];</pre>
<pre>        assign data_o[i] = | gather;</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_mux_segmented.v</h3>
<pre>module bsg_mux_segmented #(parameter segments_p="inv"</pre>
<pre>                          ,parameter segment_width_p="inv"</pre>
<pre>                          ,parameter data_width_lp=segments_p*segment_width_p)</pre>
<pre>  input [data_width_lp-1:0] data0_i</pre>
<pre>  ,input [data_width_lp-1:0] data1_i</pre>
<pre>  ,input [segments_p-1:0] sel_i</pre>
<pre>  ,output logic [data_width_lp-1:0] data_o</pre>
<pre style="background-color: #FF0000;">  genvar i;</pre>
<pre>  for (i = 0; i < segments_p; i++) begin</pre>
<pre>    assign data_o[i*segment_width_p+:segment_width_p] = sel_i[i]</pre>
<pre>      ? data1_i[i*segment_width_p+:segment_width_p]</pre>
<pre>      : data0_i[i*segment_width_p+:segment_width_p];</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_priority_encode.v</h3>
<pre>module bsg_priority_encode #(parameter   width_p    = "inv"</pre>
<pre>                             , parameter lo_to_hi_p = "inv"</pre>
<pre>    , output [`BSG_SAFE_CLOG2(width_p)-1:0] addr_o</pre>
<pre>    , output v_o</pre>
<pre>    );</pre>
<pre></pre>
<pre>                                     ,.lo_to_hi_p(lo_to_hi_p)</pre>
<pre>                                     ) a</pre>
<pre style="background-color: #FF0000;">     (.i(i)</pre>
<pre>      ,.o(enc_lo)</pre>
<pre>      );</pre>
<pre>                        ,.lo_to_hi_p(lo_to_hi_p)</pre>
<pre>                        ) b</pre>
<pre style="background-color: #FF0000;">     (.i      (enc_lo)</pre>
<pre>      ,.addr_o(addr_o)</pre>
<pre>      ,.v_o   (v_o)</pre>
<pre>      );</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_scan.v</h3>
<pre>module bsg_scan #(parameter width_p = -1</pre>
<pre>                  , parameter xor_p = 0</pre>
<pre>                  , parameter and_p = 0</pre>
<pre>                  , parameter or_p = 0</pre>
<pre>                  , parameter lo_to_hi_p = 0</pre>
<pre>   (input    [width_p-1:0] i</pre>
<pre>    , output logic [width_p-1:0] o</pre>
<pre style="background-color: #FF0000;">   initial</pre>
<pre>      assert( $countones({xor_p[0], and_p[0], or_p[0]}) == 1)</pre>
<pre>        else $error("bsg_scan: only one function may be selected\n");</pre>
<pre style="background-color: #FF0000;">   genvar j;</pre>
<pre>   wire [$clog2(width_p):0][width_p-1:0] t;</pre>
<pre>   wire [width_p-1:0]                      fill;</pre>
<pre>   if (lo_to_hi_p)</pre>
<pre>     assign t[0] = {<< {i}};</pre>
<pre>     assign t[0] = i;</pre>
<pre>   if ((width_p == 4) & and_p)</pre>
<pre>     begin : scand4</pre>
<pre>	assign t[$clog2(width_p)] = { t[0][3], &t[0][3:2], &t[0][3:1], &t[0][3:0] };</pre>
<pre style="background-color: #FF0000;">   else if ((width_p == 3) & and_p)</pre>
<pre style="background-color: #FF0000;">     begin: scand3</pre>
<pre style="background-color: #FF0000;">	assign t[$clog2(width_p)] = { t[0][2], &t[0][2:1], &t[0][2:0] };</pre>
<pre style="background-color: #FF0000;">   else if ((width_p == 2) & and_p)</pre>
<pre style="background-color: #FF0000;">     begin: scand3</pre>
<pre style="background-color: #FF0000;">	assign t[$clog2(width_p)] = { t[0][1], &t[0][1:0] };</pre>
<pre>     begin : scanN</pre>
<pre>	for (j = 0; j < $clog2(width_p); j = j + 1)</pre>
<pre>	  begin : row</pre>
<pre>             wire [width_p-1:0] shifted = width_p ' ({fill, t[j]} >> (1 << j));</pre>
<pre style="background-color: #FF0000;">             if (xor_p)</pre>
<pre style="background-color: #FF0000;">               begin</pre>
<pre style="background-color: #FF0000;">		  assign fill = { width_p {1'b0} };</pre>
<pre style="background-color: #FF0000;">		  assign t[j+1] = t[j] ^ shifted;</pre>
<pre style="background-color: #FF0000;">             else if (and_p)</pre>
<pre style="background-color: #FF0000;">               begin</pre>
<pre style="background-color: #FF0000;">		  assign fill = { width_p {1'b1} };</pre>
<pre style="background-color: #FF0000;">		  assign t[j+1] = t[j] & shifted;</pre>
<pre>             else if (or_p)</pre>
<pre>               begin</pre>
<pre>		  assign fill = { width_p {1'b0} };</pre>
<pre>		  assign t[j+1] = t[j] | shifted;</pre>
<pre>   if (lo_to_hi_p)</pre>
<pre>for (genvar j = 0; j < width_p; j++) begin</pre>
<pre>      assign o[j] = t[$clog2(width_p)][width_p-1-j];</pre>
<pre>     assign o = t[$clog2(width_p)];</pre>
<h3>./bp_common/src/v/bsg_fifo_1r1w_fence.v</h3>
<pre>module bsg_fifo_1r1w_fence</pre>
<pre> #(parameter width_p = "inv"</pre>
<pre>   , parameter els_p = "inv"</pre>
<pre>   , parameter ready_THEN_valid_p = 0</pre>
<pre>  (input                  clk_i</pre>
<pre>   , input                reset_i</pre>
<pre>   , input                fence_set_i</pre>
<pre>   , input                fence_clr_i</pre>
<pre>   , output               fence_o</pre>
<pre>   , input [width_p-1:0]  data_i</pre>
<pre>   , input                v_i</pre>
<pre>   , output               ready_o</pre>
<pre>   , output [width_p-1:0] data_o</pre>
<pre>   , output               v_o</pre>
<pre>   , input                yumi_i</pre>
<pre>  bsg_fifo_1r1w_small</pre>
<pre>   #(.width_p(width_p)</pre>
<pre>     ,.els_p(els_p)</pre>
<pre>     ,.ready_THEN_valid_p(ready_THEN_valid_p)</pre>
<pre style="background-color: #FF0000;">   fe_cmd_fifo</pre>
<pre>    (.clk_i(clk_i)</pre>
<pre>     ,.reset_i(reset_i)</pre>
<pre>     ,.data_i(data_i)</pre>
<pre>     ,.v_i(v_i)</pre>
<pre>     ,.ready_o(ready_o)</pre>
<pre>     ,.data_o(data_o)</pre>
<pre>     ,.v_o(v_o)</pre>
<pre>     ,.yumi_i(yumi_i)</pre>
<pre>  logic fence_r;</pre>
<pre>  bsg_dff_reset_en</pre>
<pre>   #(.width_p(1))</pre>
<pre style="background-color: #FF0000;">   fence_reg</pre>
<pre>    (.clk_i(clk_i)</pre>
<pre>     ,.reset_i(reset_i)</pre>
<pre>     ,.en_i(fence_set_i | fence_clr_i)</pre>
<pre>     ,.data_i(fence_set_i)</pre>
<pre>     ,.data_o(fence_r)</pre>
<pre>  assign fence_o = fence_r;</pre>
<h3>./external/basejump_stl/bsg_noc/bsg_mesh_router.v</h3>
<pre>module bsg_mesh_router_dor_decoder</pre>
<pre> #( parameter x_cord_width_p  = -1</pre>
<pre>   ,parameter y_cord_width_p = -1</pre>
<pre>   ,parameter dirs_lp       = 5</pre>
<pre>   ,parameter stub_p        = { dirs_lp {1'b0} }  // SNEWP</pre>
<pre>   ,parameter XY_order_p    = 1</pre>
<pre> ( input clk_i   // debug only</pre>
<pre>  ,input reset_i // clock only</pre>
<pre>  ,input [dirs_lp-1:0] v_i</pre>
<pre>  ,input [dirs_lp-1:0][x_cord_width_p-1:0] x_dirs_i</pre>
<pre>  ,input [dirs_lp-1:0][y_cord_width_p-1:0] y_dirs_i</pre>
<pre>  ,input [x_cord_width_p-1:0] my_x_i</pre>
<pre>  ,input [y_cord_width_p-1:0] my_y_i</pre>
<pre>  ,output [dirs_lp-1:0][dirs_lp-1:0] req_o</pre>
<pre>   wire [dirs_lp-1:0] x_eq, x_gt, x_lt;</pre>
<pre>   wire [dirs_lp-1:0] y_eq, y_gt, y_lt;</pre>
<pre>   wire [dirs_lp-1:0] v_i_stub = v_i & ~stub_p;</pre>
<pre style="background-color: #FF0000;">   genvar            i, j;</pre>
<pre>   for (i = 0; i < dirs_lp; i=i+1) begin: comps</pre>
<pre>        assign x_eq[i] = (x_dirs_i[i] == my_x_i);</pre>
<pre>        assign y_eq[i] = (y_dirs_i[i] == my_y_i);</pre>
<pre>        assign x_gt[i] = (x_dirs_i[i] > my_x_i);</pre>
<pre>        assign y_gt[i] = (y_dirs_i[i] > my_y_i);</pre>
<pre>        assign x_lt[i] = ~x_gt[i] & ~x_eq[i];</pre>
<pre>        assign y_lt[i] = ~y_gt[i] & ~y_eq[i];</pre>
<pre>if( XY_order_p == 1 ) begin:XY_dor</pre>
<pre>    for( i=W; i<=E; i++) begin:x2y // X dim to Y dim</pre>
<pre>        assign req_o[i][N] = v_i_stub[i] & x_eq[i] & y_lt[i];</pre>
<pre>        assign req_o[i][S] = v_i_stub[i] & x_eq[i] & y_gt[i];</pre>
<pre>    for( i=N; i<=S; i++) begin:y2x// Y dim to X dim</pre>
<pre>        assign req_o[i][W] = 1'b0;</pre>
<pre>        assign req_o[i][E] = 1'b0;</pre>
<pre>    for( i=W; i<=E; i++) begin// the same X dim routings. For X/Y routing, we don't care Y dimesions.</pre>
<pre>        assign  req_o[i][W] =  i==W ? 1'b0 : v_i_stub[i] & x_lt[i];</pre>
<pre>        assign  req_o[i][E] =  i==E ? 1'b0 : v_i_stub[i] & x_gt[i];</pre>
<pre>    for( i=N; i<=S; i++) begin// the same Y dim routings. For X/Y routing, X must be equal first.</pre>
<pre>        assign  req_o[i][N] =  i==N ? 1'b0 : v_i_stub[i] & x_eq[i] & y_lt[i];</pre>
<pre>        assign  req_o[i][S] =  i==S ? 1'b0 : v_i_stub[i] & x_eq[i] & y_gt[i];</pre>
<pre>    assign req_o[P][E]  =  v_i_stub[P] & x_gt [P];  //ignore Y cord</pre>
<pre>    assign req_o[P][W]  =  v_i_stub[P] & x_lt [P];  //ignore Y cord</pre>
<pre>    assign req_o[P][P]  =  v_i_stub[P] & x_eq[P] & y_eq [P];</pre>
<pre>    assign req_o[P][S]  =  v_i_stub[P] & x_eq[P] & y_gt [P]; // X must equal</pre>
<pre>    assign req_o[P][N]  =  v_i_stub[P] & x_eq[P] & y_lt [P]; // X must equal</pre>
<pre>    for( i=W; i<=S; i++) begin</pre>
<pre>        assign req_o[i][P] = v_i_stub[i] & x_eq[i] & y_eq[i];</pre>
<pre>    always@(negedge clk_i)</pre>
<pre>      begin</pre>
<pre>         assert( (reset_i !== 1'b0)</pre>
<pre>                 |  ~(</pre>
<pre>                      (v_i[N]& ~x_eq[N])</pre>
<pre>                      | (v_i[S] & ~x_eq[S])</pre>
<pre style="background-color: #FF0000;">                 ) else</pre>
<pre>           begin</pre>
<pre>              $error("%m:Y dim to X dim routing. XY_order_p = %b", XY_order_p);</pre>
<pre>              $finish();</pre>
<pre>         assert( (reset_i !== 1'b0)</pre>
<pre>                 |  ~(</pre>
<pre>                      (v_i[W] & x_lt[W])</pre>
<pre>                      | (v_i[E] & x_gt [E] )</pre>
<pre style="background-color: #FF0000;">                 ) else</pre>
<pre>           begin</pre>
<pre>              $error("%m: X dim loopback routing", XY_order_p);</pre>
<pre>              $finish();</pre>
<pre>       assert(  (reset_i !== 1'b0 )</pre>
<pre>                |  ~(</pre>
<pre>                     (v_i[N] & x_eq[N] & y_lt[N])</pre>
<pre>                     | (v_i[S] & x_eq[S] & y_gt [S])</pre>
<pre style="background-color: #FF0000;">                ) else</pre>
<pre>         begin</pre>
<pre>            $error("%m: Y dim loopback routing", XY_order_p);</pre>
<pre>            $finish();</pre>
<pre style="background-color: #FF0000;">end else begin:YX_dor</pre>
<pre style="background-color: #FF0000;">    for( i=W; i<=E; i++) begin:x2y // X dim to Y dim</pre>
<pre style="background-color: #FF0000;">        assign req_o[i][N] = 1'b0;</pre>
<pre style="background-color: #FF0000;">        assign req_o[i][S] = 1'b0;</pre>
<pre style="background-color: #FF0000;">    for( i=N; i<=S; i++) begin:y2x // Y dim to X dim</pre>
<pre style="background-color: #FF0000;">        assign req_o[i][W] = v_i_stub[i] & y_eq[i] & x_lt[i];</pre>
<pre style="background-color: #FF0000;">        assign req_o[i][E] = v_i_stub[i] & y_eq[i] & x_gt[i];</pre>
<pre style="background-color: #FF0000;">    for( i=N; i<=S; i++) begin// the same Y dim routings. For Y/X routing, we don't care X dimesions</pre>
<pre style="background-color: #FF0000;">        assign req_o[i][N] =  i==N ? 1'b0 : v_i_stub[i] &  y_lt[i];</pre>
<pre style="background-color: #FF0000;">        assign req_o[i][S] =  i==S ? 1'b0 : v_i_stub[i] &  y_gt[i];</pre>
<pre style="background-color: #FF0000;">    for( i=W; i<=E; i++) begin// the same X dim routings. For Y/X routing, Y must equal first</pre>
<pre style="background-color: #FF0000;">        assign req_o[i][W] =  i==W ? 1'b0 : v_i_stub[i] & y_eq[i] & x_lt[i];</pre>
<pre style="background-color: #FF0000;">        assign req_o[i][E] =  i==E ? 1'b0 : v_i_stub[i] & y_eq[i] & x_gt[i];</pre>
<pre style="background-color: #FF0000;">    assign req_o[P][S]  =  v_i_stub[P] & y_gt [P];  //ignore X cord</pre>
<pre style="background-color: #FF0000;">    assign req_o[P][N]  =  v_i_stub[P] & y_lt [P];  //ignore X cord</pre>
<pre style="background-color: #FF0000;">    assign req_o[P][P]  =  v_i_stub[P] & x_eq[P] & y_eq [P];</pre>
<pre style="background-color: #FF0000;">    assign req_o[P][E]  =  v_i_stub[P] & y_eq[P] & x_gt [P]; // Y must equal first</pre>
<pre style="background-color: #FF0000;">    assign req_o[P][W]  =  v_i_stub[P] & y_eq[P] & x_lt [P]; // Y must equal first</pre>
<pre style="background-color: #FF0000;">    for( i=W; i<=S; i++) begin</pre>
<pre style="background-color: #FF0000;">        assign req_o[i][P] = v_i_stub[i] & x_eq[i] & y_eq[i];</pre>
<pre style="background-color: #FF0000;">    always@(negedge clk_i)</pre>
<pre style="background-color: #FF0000;">      begin</pre>
<pre style="background-color: #FF0000;">         assert( (reset_i !== 1'b0)</pre>
<pre style="background-color: #FF0000;">                 | ~(</pre>
<pre style="background-color: #FF0000;">                     (v_i[W] & ~y_eq[W])</pre>
<pre style="background-color: #FF0000;">                     | (v_i[E] & ~y_eq[E])</pre>
<pre style="background-color: #FF0000;">                 ) else</pre>
<pre style="background-color: #FF0000;">           begin</pre>
<pre style="background-color: #FF0000;">              $error("%m:X dim to Y dim routing. XY_order_p = %b", XY_order_p);</pre>
<pre style="background-color: #FF0000;">              $finish();</pre>
<pre style="background-color: #FF0000;">         assert( (reset_i !== 1'b0)</pre>
<pre style="background-color: #FF0000;">                 | ~(</pre>
<pre style="background-color: #FF0000;">                     (v_i[W] & y_eq[W] & x_lt[W])</pre>
<pre style="background-color: #FF0000;">                     | (v_i[E] & y_eq[E] & x_gt [E] )</pre>
<pre style="background-color: #FF0000;">                 ) else</pre>
<pre style="background-color: #FF0000;">           begin</pre>
<pre style="background-color: #FF0000;">              $error("%m: X dim loopback routing", XY_order_p);</pre>
<pre style="background-color: #FF0000;">              $finish();</pre>
<pre style="background-color: #FF0000;">         assert( (reset_i !== 1'b0)</pre>
<pre style="background-color: #FF0000;">                 | ~(</pre>
<pre style="background-color: #FF0000;">                     (v_i  [N] & y_lt[N])</pre>
<pre style="background-color: #FF0000;">                     | (v_i[S] & y_gt[S])</pre>
<pre style="background-color: #FF0000;">           else</pre>
<pre style="background-color: #FF0000;">             begin</pre>
<pre style="background-color: #FF0000;">                $error("%m: Y dim loopback routing", XY_order_p);</pre>
<pre style="background-color: #FF0000;">                $finish();</pre>
<pre>module bsg_mesh_router</pre>
<pre style="background-color: #FF0000;">    #(</pre>
<pre>         parameter width_p        = -1</pre>
<pre>        ,parameter x_cord_width_p = -1</pre>
<pre>        ,parameter y_cord_width_p = -1</pre>
<pre>        ,parameter debug_p       = 0</pre>
<pre>        ,parameter dirs_lp       = 5</pre>
<pre>        ,parameter stub_p        = { dirs_lp {1'b0} }  // SNEWP</pre>
<pre>        ,parameter XY_order_p    = 1</pre>
<pre>   (  input clk_i</pre>
<pre>     ,input reset_i</pre>
<pre>     ,input   [dirs_lp-1:0] [width_p-1:0] data_i  // from input twofer</pre>
<pre>     ,input   [dirs_lp-1:0]               v_i // from input twofer</pre>
<pre>     ,output  logic [dirs_lp-1:0]         yumi_o  // to input twofer</pre>
<pre>     ,input   [dirs_lp-1:0]               ready_i // from output twofer</pre>
<pre>     ,output  [dirs_lp-1:0] [width_p-1:0] data_o  // to output twofer</pre>
<pre>     ,output  logic [dirs_lp-1:0]         v_o // to output twofer</pre>
<pre>     ,input   [x_cord_width_p-1:0] my_x_i           // node's x and y coord</pre>
<pre>     ,input   [y_cord_width_p-1:0] my_y_i</pre>
<pre>   wire [dirs_lp-1:0][x_cord_width_p-1:0] x_dirs;</pre>
<pre>   wire [dirs_lp-1:0][y_cord_width_p-1:0] y_dirs;</pre>
<pre>   wire [dirs_lp-1:0] ready_i_stub = ready_i | stub_p;</pre>
<pre>   wire [dirs_lp-1:0] v_i_stub     = v_i     & ~stub_p;</pre>
<pre style="background-color: #FF0000;">   genvar                               i;</pre>
<pre>   for (i = 0; i < dirs_lp; i=i+1)</pre>
<pre>     begin: reshape</pre>
<pre>        assign x_dirs[i] = data_i[i][0+:x_cord_width_p];</pre>
<pre>        assign y_dirs[i] = data_i[i][x_cord_width_p+:y_cord_width_p];</pre>
<pre>   wire [dirs_lp-1:0][dirs_lp-1:0] req;</pre>
<pre>   bsg_mesh_router_dor_decoder  #( .x_cord_width_p  (x_cord_width_p)</pre>
<pre>                                   ,.y_cord_width_p (y_cord_width_p)</pre>
<pre>                                   ,.dirs_lp        (dirs_lp       )</pre>
<pre>                                   ,.XY_order_p     (XY_order_p    )</pre>
<pre style="background-color: #FF0000;">                                   ) dor_decoder</pre>
<pre>     (  .clk_i(clk_i)     // debug only</pre>
<pre>       ,.reset_i(reset_i) // debug only</pre>
<pre>       ,.v_i            (v_i_stub)</pre>
<pre>       ,.my_x_i</pre>
<pre>       ,.my_y_i</pre>
<pre>       ,.x_dirs_i       (x_dirs)</pre>
<pre>       ,.y_dirs_i       (y_dirs)</pre>
<pre>       ,.req_o          (req)</pre>
<pre>   wire P_gnt_p, P_gnt_e, P_gnt_s, P_gnt_n, P_gnt_w;</pre>
<pre>   wire W_gnt_e, W_gnt_p;</pre>
<pre>   wire E_gnt_w, E_gnt_p;</pre>
<pre>   wire N_gnt_s, N_gnt_p;</pre>
<pre>   wire S_gnt_n, S_gnt_p;</pre>
<pre>        wire N_gnt_e, N_gnt_w;</pre>
<pre>        wire S_gnt_e, S_gnt_w;</pre>
<pre>        wire W_gnt_n, W_gnt_s;</pre>
<pre>        wire E_gnt_n, E_gnt_s;</pre>
<pre>   wire P_sel_p, P_sel_e, P_sel_s, P_sel_n, P_sel_w;</pre>
<pre>   wire W_sel_e, W_sel_p;</pre>
<pre>   wire E_sel_w, E_sel_p;</pre>
<pre>   wire N_sel_s, N_sel_p;</pre>
<pre>   wire S_sel_n, S_sel_p;</pre>
<pre>        wire N_sel_e, N_sel_w;</pre>
<pre>        wire S_sel_e, S_sel_w;</pre>
<pre>        wire W_sel_n, W_sel_s;</pre>
<pre>        wire E_sel_n, E_sel_s;</pre>
<pre>   if( XY_order_p == 1) begin</pre>
<pre>        bsg_round_robin_arb #(.inputs_p(2)</pre>
<pre style="background-color: #FF0000;">                             ) west_rr_arb</pre>
<pre>               (.clk_i</pre>
<pre>                ,.reset_i</pre>
<pre>                ,.grants_en_i(ready_i_stub[W])</pre>
<pre>                ,.reqs_i             ({req[E][W],    req[P][W]})</pre>
<pre>                ,.grants_o           ({W_gnt_e,      W_gnt_p})</pre>
<pre>                ,.sel_one_hot_o      ({W_sel_e,      W_sel_p})</pre>
<pre>                ,.v_o    (v_o[W])</pre>
<pre>                ,.tag_o  ()</pre>
<pre>                ,.yumi_i (v_o[W] & ready_i_stub[W])</pre>
<pre>         bsg_mux_one_hot #(.width_p(width_p)</pre>
<pre>                               ,.els_p(2)</pre>
<pre style="background-color: #FF0000;">                               ) mux_data_west</pre>
<pre>               ( .data_i        ({data_i[P], data_i[E]})</pre>
<pre>                ,.sel_one_hot_i ({W_sel_p  , W_sel_e  })</pre>
<pre>                ,.data_o       (data_o[W])</pre>
<pre>        assign W_gnt_n = 1'b0;</pre>
<pre>        assign W_gnt_s = 1'b0;</pre>
<pre style="background-color: #FF0000;">   end else begin</pre>
<pre style="background-color: #FF0000;">        bsg_round_robin_arb #(.inputs_p(4)</pre>
<pre style="background-color: #FF0000;">                             ) west_rr_arb</pre>
<pre style="background-color: #FF0000;">               (.clk_i</pre>
<pre style="background-color: #FF0000;">                ,.reset_i</pre>
<pre style="background-color: #FF0000;">                ,.grants_en_i(ready_i_stub[W])</pre>
<pre style="background-color: #FF0000;">                ,.reqs_i             ({req[E][W],       req[P][W], req[N][W],      req[S][W]})</pre>
<pre style="background-color: #FF0000;">                ,.grants_o           ({W_gnt_e,         W_gnt_p,   W_gnt_n,        W_gnt_s  })</pre>
<pre style="background-color: #FF0000;">                ,.sel_one_hot_o      ({W_sel_e,         W_sel_p,   W_sel_n,        W_sel_s  })</pre>
<pre style="background-color: #FF0000;">                ,.v_o    (v_o[W])</pre>
<pre style="background-color: #FF0000;">                ,.tag_o  ()</pre>
<pre style="background-color: #FF0000;">                ,.yumi_i (v_o[W] & ready_i_stub[W])</pre>
<pre style="background-color: #FF0000;">         bsg_mux_one_hot #(.width_p(width_p)</pre>
<pre style="background-color: #FF0000;">                               ,.els_p(4)</pre>
<pre style="background-color: #FF0000;">                               ) mux_data_west</pre>
<pre style="background-color: #FF0000;">               ( .data_i        ({data_i[P], data_i[E], data_i[N], data_i[S]})</pre>
<pre style="background-color: #FF0000;">                ,.sel_one_hot_i ({W_sel_p  , W_sel_e  , W_sel_n,   W_sel_s  })</pre>
<pre style="background-color: #FF0000;">                ,.data_o       (data_o[W])</pre>
<pre>   if (XY_order_p == 1) begin</pre>
<pre>        bsg_round_robin_arb #(.inputs_p(2)</pre>
<pre style="background-color: #FF0000;">                        ) east_rr_arb</pre>
<pre>          ( .clk_i</pre>
<pre>           ,.reset_i</pre>
<pre>           ,.grants_en_i(ready_i_stub[E])</pre>
<pre>           ,.reqs_i             ({req[W][E],    req[P][E]})</pre>
<pre>           ,.grants_o           ({E_gnt_w,      E_gnt_p})</pre>
<pre>           ,.sel_one_hot_o      ({E_sel_w,      E_sel_p})</pre>
<pre>           ,.v_o   (v_o[E])</pre>
<pre>           ,.tag_o ()</pre>
<pre>           ,.yumi_i(v_o[E] & ready_i_stub[E])</pre>
<pre>        bsg_mux_one_hot #(.width_p(width_p)</pre>
<pre>                          ,.els_p(2)</pre>
<pre style="background-color: #FF0000;">                          ) mux_data_east</pre>
<pre>          ( .data_i        ({data_i[P], data_i[W]})</pre>
<pre>           ,.sel_one_hot_i ({E_sel_p  , E_sel_w  })</pre>
<pre>           ,.data_o       (data_o[E])</pre>
<pre>        assign E_gnt_n = 1'b0;</pre>
<pre>        assign E_gnt_s = 1'b0;</pre>
<pre style="background-color: #FF0000;">   end else begin</pre>
<pre style="background-color: #FF0000;">        bsg_round_robin_arb #(.inputs_p(4)</pre>
<pre style="background-color: #FF0000;">                        ) east_rr_arb</pre>
<pre style="background-color: #FF0000;">          ( .clk_i</pre>
<pre style="background-color: #FF0000;">           ,.reset_i</pre>
<pre style="background-color: #FF0000;">           ,.grants_en_i(ready_i_stub[E])</pre>
<pre style="background-color: #FF0000;">           ,.reqs_i             ({req[W][E],    req[P][E],      req[N][E],      req[S][E]})</pre>
<pre style="background-color: #FF0000;">           ,.grants_o           ({E_gnt_w,      E_gnt_p,        E_gnt_n,        E_gnt_s  })</pre>
<pre style="background-color: #FF0000;">           ,.sel_one_hot_o      ({E_sel_w,      E_sel_p,        E_sel_n,        E_sel_s  })</pre>
<pre style="background-color: #FF0000;">           ,.v_o   (v_o[E])</pre>
<pre style="background-color: #FF0000;">           ,.tag_o ()</pre>
<pre style="background-color: #FF0000;">           ,.yumi_i(v_o[E] & ready_i_stub[E])</pre>
<pre style="background-color: #FF0000;">        bsg_mux_one_hot #(.width_p(width_p)</pre>
<pre style="background-color: #FF0000;">                          ,.els_p(4)</pre>
<pre style="background-color: #FF0000;">                          ) mux_data_east</pre>
<pre style="background-color: #FF0000;">          ( .data_i        ({data_i[P], data_i[W], data_i[N], data_i[S]})</pre>
<pre style="background-color: #FF0000;">           ,.sel_one_hot_i ({E_sel_p  , E_sel_w,   E_sel_n,   E_sel_s  })</pre>
<pre style="background-color: #FF0000;">           ,.data_o       (data_o[E])</pre>
<pre>   if(XY_order_p == 1) begin</pre>
<pre>        bsg_round_robin_arb #(.inputs_p(4)</pre>
<pre style="background-color: #FF0000;">                              ) north_rr_arb</pre>
<pre>          (.clk_i</pre>
<pre>           ,.reset_i</pre>
<pre>           ,.grants_en_i(ready_i_stub[N])</pre>
<pre>           ,.reqs_i          ({req[S][N], req[E][N], req[W][N], req[P][N]})</pre>
<pre>           ,.grants_o        ({ N_gnt_s,  N_gnt_e,   N_gnt_w,   N_gnt_p })</pre>
<pre>           ,.sel_one_hot_o   ({ N_sel_s,  N_sel_e,   N_sel_w,   N_sel_p })</pre>
<pre>           ,.v_o   (v_o[N])</pre>
<pre>           ,.tag_o ()</pre>
<pre>           ,.yumi_i(v_o[N] & ready_i_stub[N])</pre>
<pre>        bsg_mux_one_hot #(.width_p(width_p)</pre>
<pre>                          ,.els_p(4)</pre>
<pre style="background-color: #FF0000;">                          ) mux_data_north</pre>
<pre>          (.data_i        ({data_i[P], data_i[E], data_i[S], data_i[W]})</pre>
<pre>           ,.sel_one_hot_i({N_sel_p  , N_sel_e  , N_sel_s  , N_sel_w  })</pre>
<pre>           ,.data_o       (data_o[N])</pre>
<pre style="background-color: #FF0000;">   end else begin</pre>
<pre style="background-color: #FF0000;">        assign N_gnt_e = 1'b0;</pre>
<pre style="background-color: #FF0000;">        assign N_gnt_w = 1'b0;</pre>
<pre style="background-color: #FF0000;">        bsg_round_robin_arb #(.inputs_p(2)</pre>
<pre style="background-color: #FF0000;">                              ) north_rr_arb</pre>
<pre style="background-color: #FF0000;">          (.clk_i</pre>
<pre style="background-color: #FF0000;">           ,.reset_i</pre>
<pre style="background-color: #FF0000;">           ,.grants_en_i(ready_i_stub[N])</pre>
<pre style="background-color: #FF0000;">           ,.reqs_i          ({req[S][N], req[P][N]})</pre>
<pre style="background-color: #FF0000;">           ,.grants_o        ({ N_gnt_s,  N_gnt_p })</pre>
<pre style="background-color: #FF0000;">           ,.sel_one_hot_o   ({ N_sel_s,  N_sel_p })</pre>
<pre style="background-color: #FF0000;">           ,.v_o   (v_o[N])</pre>
<pre style="background-color: #FF0000;">           ,.tag_o ()</pre>
<pre style="background-color: #FF0000;">           ,.yumi_i(v_o[N] & ready_i_stub[N])</pre>
<pre style="background-color: #FF0000;">        bsg_mux_one_hot #(.width_p(width_p)</pre>
<pre style="background-color: #FF0000;">                          ,.els_p(2)</pre>
<pre style="background-color: #FF0000;">                          ) mux_data_north</pre>
<pre style="background-color: #FF0000;">          (.data_i        ({data_i[P],  data_i[S] })</pre>
<pre style="background-color: #FF0000;">           ,.sel_one_hot_i({N_sel_p  ,  N_sel_s   })</pre>
<pre style="background-color: #FF0000;">           ,.data_o       (data_o[N])</pre>
<pre>   if(XY_order_p == 1) begin</pre>
<pre>        bsg_round_robin_arb #(.inputs_p(4)</pre>
<pre style="background-color: #FF0000;">                              ) south_rr_arb</pre>
<pre>          (.clk_i</pre>
<pre>           ,.reset_i</pre>
<pre>           ,.grants_en_i(ready_i_stub[S])</pre>
<pre>           ,.reqs_i          ({req[N][S], req[E][S], req[W][S], req[P][S]})</pre>
<pre>           ,.grants_o        ({ S_gnt_n,  S_gnt_e,   S_gnt_w,   S_gnt_p })</pre>
<pre>           ,.sel_one_hot_o   ({ S_sel_n,  S_sel_e,   S_sel_w,   S_sel_p })</pre>
<pre>           ,.v_o   (v_o[S])</pre>
<pre>           ,.tag_o ()</pre>
<pre>           ,.yumi_i(v_o[S] & ready_i_stub[S] )</pre>
<pre>        bsg_mux_one_hot #(.width_p(width_p)</pre>
<pre>                          ,.els_p(4)</pre>
<pre style="background-color: #FF0000;">                          ) mux_data_south</pre>
<pre>          (.data_i        ({data_i[P], data_i[E], data_i[N], data_i[W]})</pre>
<pre>           ,.sel_one_hot_i({S_sel_p  , S_sel_e  , S_sel_n  , S_sel_w  })</pre>
<pre>           ,.data_o       (data_o[S])</pre>
<pre style="background-color: #FF0000;">   end else begin</pre>
<pre style="background-color: #FF0000;">        assign S_gnt_e = 1'b0;</pre>
<pre style="background-color: #FF0000;">        assign S_gnt_w = 1'b0;</pre>
<pre style="background-color: #FF0000;">        bsg_round_robin_arb #(.inputs_p(2)</pre>
<pre style="background-color: #FF0000;">                              ) south_rr_arb</pre>
<pre style="background-color: #FF0000;">          (.clk_i</pre>
<pre style="background-color: #FF0000;">           ,.reset_i</pre>
<pre style="background-color: #FF0000;">           ,.grants_en_i(ready_i_stub[S])</pre>
<pre style="background-color: #FF0000;">           ,.reqs_i          ({req[N][S], req[P][S]})</pre>
<pre style="background-color: #FF0000;">           ,.grants_o        ({ S_gnt_n,  S_gnt_p })</pre>
<pre style="background-color: #FF0000;">           ,.sel_one_hot_o   ({ S_sel_n,  S_sel_p })</pre>
<pre style="background-color: #FF0000;">           ,.v_o   (v_o[S])</pre>
<pre style="background-color: #FF0000;">           ,.tag_o ()</pre>
<pre style="background-color: #FF0000;">           ,.yumi_i(v_o[S] & ready_i_stub[S] )</pre>
<pre style="background-color: #FF0000;">        bsg_mux_one_hot #(.width_p(width_p)</pre>
<pre style="background-color: #FF0000;">                          ,.els_p(2)</pre>
<pre style="background-color: #FF0000;">                          ) mux_data_south</pre>
<pre style="background-color: #FF0000;">          (.data_i        ({data_i[P],  data_i[N] })</pre>
<pre style="background-color: #FF0000;">           ,.sel_one_hot_i({S_sel_p  ,  S_sel_n   })</pre>
<pre style="background-color: #FF0000;">           ,.data_o       (data_o[S])</pre>
<pre>   bsg_round_robin_arb #(.inputs_p(5)</pre>
<pre style="background-color: #FF0000;">                         ) proc_rr_arb</pre>
<pre>     (.clk_i</pre>
<pre>      ,.reset_i</pre>
<pre>      ,.grants_en_i(ready_i_stub[P])</pre>
<pre>      ,.reqs_i          ({req[S][P], req[N][P], req[E][P], req[W][P], req[P][P]})</pre>
<pre>      ,.grants_o        ({ P_gnt_s,  P_gnt_n,   P_gnt_e,   P_gnt_w,   P_gnt_p })</pre>
<pre>      ,.sel_one_hot_o   ({ P_sel_s,  P_sel_n,   P_sel_e,   P_sel_w,   P_sel_p })</pre>
<pre>      ,.v_o   (v_o[P])</pre>
<pre>      ,.tag_o ()</pre>
<pre>      ,.yumi_i(v_o[P] & ready_i_stub[P])</pre>
<pre>   bsg_mux_one_hot #(.width_p(width_p)</pre>
<pre>                     ,.els_p(5)</pre>
<pre style="background-color: #FF0000;">                     ) mux_data_proc</pre>
<pre>     (.data_i        ({data_i[P], data_i[E], data_i[S], data_i[W], data_i[N]})</pre>
<pre>      ,.sel_one_hot_i({P_sel_p  , P_sel_e  , P_sel_s  , P_sel_w  , P_sel_n  })</pre>
<pre>      ,.data_o       (data_o[P])</pre>
<pre>   assign yumi_o[P] = E_gnt_p | N_gnt_p | S_gnt_p | P_gnt_p | W_gnt_p;</pre>
<pre>   if( XY_order_p == 1) begin</pre>
<pre>        assign yumi_o[W] = E_gnt_w | N_gnt_w | S_gnt_w | P_gnt_w;</pre>
<pre>        assign yumi_o[E] = W_gnt_e | N_gnt_e | S_gnt_e | P_gnt_e;</pre>
<pre>        assign yumi_o[N] = S_gnt_n | P_gnt_n;</pre>
<pre>        assign yumi_o[S] = N_gnt_s | P_gnt_s;</pre>
<pre style="background-color: #FF0000;">   end else begin</pre>
<pre style="background-color: #FF0000;">        assign yumi_o[W] = E_gnt_w | P_gnt_w;</pre>
<pre style="background-color: #FF0000;">        assign yumi_o[E] = W_gnt_e | P_gnt_e;</pre>
<pre style="background-color: #FF0000;">        assign yumi_o[N] = S_gnt_n | W_gnt_n | E_gnt_n | P_gnt_n;</pre>
<pre style="background-color: #FF0000;">        assign yumi_o[S] = N_gnt_s | W_gnt_s | E_gnt_s | P_gnt_s;</pre>
<pre style="background-color: #FF0000;">   if (debug_p)</pre>
<pre style="background-color: #FF0000;">     for (i = P; i <= S; i=i+1)</pre>
<pre style="background-color: #FF0000;">       begin: rof</pre>
<pre style="background-color: #FF0000;">          Dirs dir = Dirs ' (i);</pre>
<pre style="background-color: #FF0000;">          always_ff @(negedge clk_i)</pre>
<pre style="background-color: #FF0000;">            begin</pre>
<pre style="background-color: #FF0000;">               if (v_i_stub[i])</pre>
<pre style="background-color: #FF0000;">                 $display("%m wants to send %x to {x,y}={%x,%x} from dir %s, req[SNEWP] = %b, ready_i[SNEWP] = %b"</pre>
<pre style="background-color: #FF0000;">                          , data_i[i], x_dirs[i],y_dirs[i],dir.name(), req[i], ready_i_stub);</pre>
<pre style="background-color: #FF0000;">               if (v_o[i])</pre>
<pre style="background-color: #FF0000;">                 $display("%m sending %x in dir %s", data_o[i], dir.name());</pre>
<h3>./external/basejump_stl/bsg_noc/bsg_noc_repeater_node.v</h3>
<pre>module bsg_noc_repeater_node</pre>
<pre>#(parameter width_p = -1</pre>
<pre>, parameter num_in_p = 1</pre>
<pre>, parameter num_nodes_p = 0</pre>
<pre>, parameter bsg_ready_and_link_sif_width_lp = `bsg_ready_and_link_sif_width(width_p)</pre>
<pre>)</pre>
<pre>, input  side_A_reset_i</pre>
<pre></pre>
<pre>, output [num_in_p-1:0][bsg_ready_and_link_sif_width_lp-1:0] side_A_links_o</pre>
<pre></pre>
<pre>, output [num_in_p-1:0][bsg_ready_and_link_sif_width_lp-1:0] side_B_links_o</pre>
<pre>);</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">  `declare_bsg_ready_and_link_sif_s(width_p, bsg_ready_and_link_sif_s);</pre>
<pre>  </pre>
<pre>  assign side_B_links_o              = links_cast_A2B[num_nodes_p];</pre>
<pre>  assign links_cast_B2A[num_nodes_p] = side_B_links_i;</pre>
<pre>  assign side_A_links_o              = links_cast_B2A[0];</pre>
<pre>  </pre>
<pre>  assign reset_r[0] = side_A_reset_i;</pre>
<pre> </pre>
<pre>    wire unused = &{clk_i};</pre>
<pre></pre>
<pre>    begin: ch</pre>
<pre>      </pre>
<pre style="background-color: #FF0000;">        begin: node</pre>
<pre style="background-color: #FF0000;">        </pre>
<pre style="background-color: #FF0000;">            reset_r[n+1] <= reset_r[n];</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">            A_to_B</pre>
<pre style="background-color: #FF0000;">              (.clk_i   ( clk_i )</pre>
<pre style="background-color: #FF0000;">              ,.reset_i ( reset_r[n] )</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">              ,.data_o  ( links_cast_A2B[n+1][i].data )</pre>
<pre style="background-color: #FF0000;">              ,.yumi_i  ( links_cast_A2B[n+1][i].v & links_cast_B2A[n+1][i].ready_and_rev)</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">              ,.data_i  ( links_cast_A2B[n][i].data )</pre>
<pre style="background-color: #FF0000;">              ,.ready_o ( links_cast_B2A[n][i].ready_and_rev )</pre>
<pre style="background-color: #FF0000;">              );</pre>
<pre style="background-color: #FF0000;">            B_to_A</pre>
<pre style="background-color: #FF0000;">              (.clk_i   ( clk_i )</pre>
<pre style="background-color: #FF0000;">              ,.reset_i ( reset_r[n] )</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">              ,.data_i  ( links_cast_B2A[n+1][i].data )</pre>
<pre style="background-color: #FF0000;">              ,.v_i     ( links_cast_B2A[n+1][i].v )</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">              ,.data_o  ( links_cast_B2A[n][i].data )</pre>
<pre style="background-color: #FF0000;">              ,.yumi_i  ( links_cast_B2A[n][i].v & links_cast_A2B[n][i].ready_and_rev )</pre>
<pre style="background-color: #FF0000;">              );</pre>
<pre style="background-color: #FF0000;">    end: ch</pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./external/basejump_stl/bsg_misc/bsg_swap.v</h3>
<pre>module bsg_swap</pre>
<pre>  #(parameter width_p="inv")</pre>
<pre>    input [1:0][width_p-1:0] data_i</pre>
<pre>    , input swap_i</pre>
<pre>    , output logic [1:0][width_p-1:0] data_o</pre>
<pre>  assign data_o = swap_i</pre>
<pre>    ? {data_i[0], data_i[1]}</pre>
<pre>    : {data_i[1], data_i[0]};</pre>
<h3>./bp_common/src/v/bsg_fifo_1r1w_rolly.v</h3>
<pre>module bsg_fifo_1r1w_rolly</pre>
<pre>  #(parameter width_p              = "inv"</pre>
<pre>    , parameter els_p              = "inv"</pre>
<pre>    , parameter ready_THEN_valid_p = 0</pre>
<pre>    )</pre>
<pre>   , input                reset_i</pre>
<pre></pre>
<pre>   , input                deq_v_i</pre>
<pre>   , input                roll_v_i</pre>
<pre></pre>
<pre>   , input                v_i</pre>
<pre>   , output               ready_o</pre>
<pre>   </pre>
<pre>   , output               v_o</pre>
<pre>   , input                yumi_i</pre>
<pre>   );</pre>
<pre>    </pre>
<pre></pre>
<pre>  wire deq  = deq_v_i;</pre>
<pre>  wire read = yumi_i;</pre>
<pre>  wire clr  = clr_v_i;</pre>
<pre>  wire roll = roll_v_i;</pre>
<pre></pre>
<pre>                    ? (cptr_r - rptr_r + (ptr_width_lp+1)'(deq))</pre>
<pre>                    : read </pre>
<pre>                       ? ((ptr_width_lp+1)'(1))</pre>
<pre>                       : ((ptr_width_lp+1)'(0));</pre>
<pre></pre>
<pre>                    ? (rptr_r - wptr_r + (ptr_width_lp+1)'(read))</pre>
<pre>                    : enq</pre>
<pre>                       ? ((ptr_width_lp+1)'(1))</pre>
<pre>                       : ((ptr_width_lp+1)'(0));</pre>
<pre></pre>
<pre>               & (rptr_r[ptr_width_lp] == wptr_r[ptr_width_lp]);</pre>
<pre>  wire full = (cptr_r[0+:ptr_width_lp] == wptr_r[0+:ptr_width_lp]) </pre>
<pre>              & (cptr_r[ptr_width_lp] != wptr_r[ptr_width_lp]);</pre>
<pre></pre>
<pre>  assign v_o     = ~roll & ~empty;</pre>
<pre></pre>
<pre>   #(.slots_p(2*els_p), .max_add_p(1)) </pre>
<pre>   cptr</pre>
<pre style="background-color: #FF0000;">    (.clk(clk_i)</pre>
<pre>     ,.reset_i(reset_i)</pre>
<pre>     ,.add_i(deq_v_i)</pre>
<pre>    ,.o(cptr_r)</pre>
<pre>     );</pre>
<pre>   #(.slots_p(2*els_p),.max_add_p(2*els_p-1))</pre>
<pre>   wptr</pre>
<pre style="background-color: #FF0000;">    (.clk(clk_i)</pre>
<pre>     ,.reset_i(reset_i)</pre>
<pre>     ,.add_i(wptr_jmp)</pre>
<pre>     ,.o(wptr_r)</pre>
<pre>     );</pre>
<pre>  #(.slots_p(2*els_p), .max_add_p(2*els_p-1))</pre>
<pre>  rptr_circ_ptr</pre>
<pre style="background-color: #FF0000;">   (.clk(clk_i)</pre>
<pre>    ,.reset_i(reset_i)</pre>
<pre>    ,.add_i(rptr_jmp)</pre>
<pre>    ,.o(rptr_r)</pre>
<pre>    );</pre>
<pre>  #(.width_p(width_p), .els_p(els_p)) </pre>
<pre>  fifo_mem</pre>
<pre style="background-color: #FF0000;">   (.w_clk_i(clk_i)</pre>
<pre>    ,.w_reset_i(reset_i)</pre>
<pre>    ,.w_v_i(enq)</pre>
<pre>    ,.w_addr_i(wptr_r[0+:ptr_width_lp])</pre>
<pre>    ,.w_data_i(data_i)</pre>
<pre>    ,.r_v_i(read)</pre>
<pre>    ,.r_addr_i(rptr_r[0+:ptr_width_lp])</pre>
<pre>    ,.r_data_o(data_o)</pre>
<pre>    );</pre>
<h3>./external/basejump_stl/bsg_noc/bsg_wormhole_concentrator_in.v</h3>
<pre>// It has zero bubble between wormhole packets.</pre>
<pre>//</pre>
<pre>//</pre>
<pre></pre>
<pre>module bsg_wormhole_concentrator_in</pre>
<pre>  #(parameter flit_width_p        = "inv"</pre>
<pre>   ,parameter len_width_p         = "inv"</pre>
<pre>   ,parameter cid_width_p         = "inv"</pre>
<pre>   ,parameter cord_width_p        = "inv"</pre>
<pre>   ,parameter num_in_p            = 1</pre>
<pre>   ,parameter debug_lp            = 0</pre>
<pre>  (input clk_i</pre>
<pre>  ,input reset_i</pre>
<pre>  ,output [num_in_p-1:0][`bsg_ready_and_link_sif_width(flit_width_p)-1:0] links_o</pre>
<pre></pre>
<pre>  ,output [`bsg_ready_and_link_sif_width(flit_width_p)-1:0] concentrated_link_o</pre>
<pre>  );</pre>
<pre style="background-color: #FF0000;">  `declare_bsg_ready_and_link_sif_s(flit_width_p,bsg_ready_and_link_sif_s);</pre>
<pre style="background-color: #FF0000;">  `declare_bsg_wormhole_concentrator_header_s(cord_width_p, len_width_p, cid_width_p, bsg_wormhole_concentrator_header_s);</pre>
<pre>  bsg_ready_and_link_sif_s concentrated_link_i_cast, concentrated_link_o_cast;</pre>
<pre>  </pre>
<pre>  assign links_o = links_o_cast;</pre>
<pre>  </pre>
<pre>  assign concentrated_link_o = concentrated_link_o_cast;</pre>
<pre> </pre>
<pre style="background-color: #FF0000;"></pre>
<pre>    begin : stub</pre>
<pre>      assign links_o_cast[i].v    = 1'b0;</pre>
<pre>      assign links_o_cast[i].data = 1'b0;</pre>
<pre>    end</pre>
<pre></pre>
<pre>  wire [num_in_p-1:0]                   fifo_valid_lo;</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre>    begin: in_ch</pre>
<pre></pre>
<pre>        (.clk_i</pre>
<pre>        ,.reset_i</pre>
<pre>        ,.ready_o(links_o_cast[i].ready_and_rev)</pre>
<pre>        ,.data_i (links_i_cast[i].data)</pre>
<pre>        ,.v_i    (links_i_cast[i].v)</pre>
<pre>        ,.v_o    (fifo_valid_lo[i])</pre>
<pre>        ,.data_o (fifo_data_lo [i])</pre>
<pre>        ,.yumi_i (yumis[i])</pre>
<pre>        );</pre>
<pre>      assign concentrated_hdr = fifo_data_lo[i][$bits(bsg_wormhole_concentrator_header_s)-1:0];</pre>
<pre></pre>
<pre>        (.clk_i</pre>
<pre>        ,.reset_i</pre>
<pre>        ,.fifo_v_i           (fifo_valid_lo[i])</pre>
<pre>        ,.fifo_yumi_i        (yumis[i])</pre>
<pre>        ,.fifo_decoded_dest_i(1'b1)</pre>
<pre>        ,.fifo_payload_len_i (concentrated_hdr.len)</pre>
<pre>        ,.reqs_o             (reqs[i])</pre>
<pre>        ,.release_o          (releases[i]) // broadcast to all</pre>
<pre>        ,.detected_header_o  ()</pre>
<pre>        );</pre>
<pre></pre>
<pre>    (.clk_i</pre>
<pre>    ,.reset_i</pre>
<pre>    ,.reqs_i    (reqs         )</pre>
<pre>    ,.release_i (releases     )</pre>
<pre>    ,.valid_i   (fifo_valid_lo)</pre>
<pre>    ,.yumi_o    (yumis        )</pre>
<pre>    ,.ready_i   (concentrated_link_i_cast.ready_and_rev)</pre>
<pre>    ,.valid_o   (concentrated_link_o_cast.v)</pre>
<pre>    ,.data_sel_o(data_sel_lo)</pre>
<pre>    );</pre>
<pre>                   ,.els_p  (num_in_p)</pre>
<pre>                   ) data_mux</pre>
<pre style="background-color: #FF0000;">    (.data_i       (fifo_data_lo)</pre>
<pre>    ,.sel_one_hot_i(data_sel_lo)</pre>
<pre>    ,.data_o       (concentrated_link_o_cast.data)</pre>
<pre>    );</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_transpose.v</h3>
<pre>module bsg_transpose #(width_p="inv"</pre>
<pre style="background-color: #FF0000;">		       ,els_p="inv"</pre>
<pre>		       ) (input    [els_p-1:0  ][width_p-1:0] i</pre>
<pre>			  , output [width_p-1:0][els_p-1:0]   o</pre>
<pre style="background-color: #FF0000;">   genvar x, y;</pre>
<pre>   for (x = 0; x < els_p; x++)</pre>
<pre>     begin: rof</pre>
<pre>	for (y = 0; y < width_p; y++)</pre>
<pre>	  begin: rof2</pre>
<pre>	     assign o[y][x] = i[x][y];</pre>
<h3>./external/basejump_stl/bsg_misc/bsg_unconcentrate_static.v</h3>
<pre style="background-color: #FF0000;">                                  , width_lp=`BSG_COUNTONES_SYNTH(pattern_els_p)</pre>
<pre> ,output [$bits(pattern_els_p)-1:0] o</pre>
<pre> );</pre>
<pre style="background-color: #FF0000;"></pre>
<pre>     assign o[0] = i[0];</pre>
<pre style="background-color: #FF0000;">   else</pre>
<pre></pre>
<pre style="background-color: #FF0000;">     begin: rof</pre>
<pre style="background-color: #FF0000;">             if (pattern_els_p[j])</pre>
<pre style="background-color: #FF0000;">               assign o[j] = i[`BSG_COUNTONES_SYNTH(pattern_els_p[j-1:0])];</pre>
<pre style="background-color: #FF0000;">     end</pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./external/basejump_stl/bsg_noc/bsg_mesh_router_buffered.v</h3>
<pre>module bsg_mesh_router_buffered #(width_p        = -1</pre>
<pre>                                  ,x_cord_width_p = -1</pre>
<pre>                                  ,y_cord_width_p = -1</pre>
<pre>                                  ,debug_p       = 0</pre>
<pre>                                  ,dirs_lp       = 5</pre>
<pre>                                  ,stub_p        = { dirs_lp {1'b0}}  // SNEWP</pre>
<pre>                                  ,bsg_ready_and_link_sif_width_lp=`bsg_ready_and_link_sif_width(width_p)</pre>
<pre>                                  // select whether to buffer the output</pre>
<pre>                                  )</pre>
<pre>    input clk_i</pre>
<pre>    , input reset_i</pre>
<pre></pre>
<pre>    , input  [dirs_lp-1:0][bsg_ready_and_link_sif_width_lp-1:0] link_i</pre>
<pre>    , output [dirs_lp-1:0][bsg_ready_and_link_sif_width_lp-1:0] link_o</pre>
<pre></pre>
<pre>    , input [y_cord_width_p-1:0] my_y_i</pre>
<pre>    );</pre>
<pre style="background-color: #FF0000;">   `declare_bsg_ready_and_link_sif_s(width_p,bsg_ready_and_link_sif_s);</pre>
<pre></pre>
<pre>   assign link_o = link_o_cast;</pre>
<pre></pre>
<pre>   logic [dirs_lp-1:0][width_p-1:0] fifo_data;</pre>
<pre>   logic [dirs_lp-1:0]              fifo_yumi;</pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">     for (i = 0; i < dirs_lp;i=i+1)</pre>
<pre style="background-color: #FF0000;">       begin</pre>
<pre style="background-color: #FF0000;">          always_ff @(negedge clk_i)</pre>
<pre style="background-color: #FF0000;">            $display("%m x=%d y=%d SNEWP[%d] v_i=%b ready_o=%b v_o=%b ready_i=%b %b"</pre>
<pre style="background-color: #FF0000;">                     ,my_x_i,my_y_i,i,link_i_cast[i].v,link_o_cast[i].ready_and_rev,</pre>
<pre style="background-color: #FF0000;">                     link_o_cast[i].v,link_i_cast[i].ready_and_rev,link_i[i]);</pre>
<pre style="background-color: #FF0000;">       end</pre>
<pre>     begin: rof</pre>
<pre>        if (stub_p[i])</pre>
<pre style="background-color: #FF0000;">          begin: fi</pre>
<pre style="background-color: #FF0000;">             assign fifo_data   [i] = width_p ' (0);</pre>
<pre style="background-color: #FF0000;">             assign fifo_valid  [i] = 1'b0;</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">               if (link_o_cast[i].v)</pre>
<pre style="background-color: #FF0000;">                 $display("## warning %m: stubbed port %x received word %x",i,link_i_cast[i].data);</pre>
<pre style="background-color: #FF0000;">             // synopsys translate_on</pre>
<pre>             bsg_two_fifo #(.width_p(width_p))</pre>
<pre>             twofer</pre>
<pre style="background-color: #FF0000;">               (.clk_i</pre>
<pre>                ,.reset_i</pre>
<pre></pre>
<pre>                ,.data_i  (link_i_cast[i].data         )</pre>
<pre>                ,.ready_o (link_o_cast[i].ready_and_rev)</pre>
<pre></pre>
<pre>                ,.data_o  (fifo_data [i])</pre>
<pre>                ,.yumi_i  (fifo_yumi [i])</pre>
<pre>                );</pre>
<pre>   logic [dirs_lp-1:0][width_p-1:0] data_lo;</pre>
<pre>   logic [dirs_lp-1:0]              ready_li;</pre>
<pre></pre>
<pre>     begin: rof2</pre>
<pre>        assign link_o_cast[i].v    = valid_lo[i];</pre>
<pre></pre>
<pre>          begin : macro</pre>
<pre>	     wire [width_p-1:0] tmp;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">               begin</pre>
<pre>                  $display("%m with buffers on %d",i);</pre>
<pre>               end</pre>
<pre>               (.i (data_lo[i]         )</pre>
<pre>                ,.o(tmp)</pre>
<pre>                );</pre>
<pre>               (.i (tmp)</pre>
<pre>                ,.o(link_o_cast[i].data)</pre>
<pre>                );</pre>
<pre style="background-color: #FF0000;"></pre>
<pre>     end</pre>
<pre>                      ,.x_cord_width_p(x_cord_width_p)</pre>
<pre>                      ,.y_cord_width_p(y_cord_width_p)</pre>
<pre>                      ,.debug_p      (debug_p      )</pre>
<pre>                      ,.stub_p       (stub_p       )</pre>
<pre>                      ,.XY_order_p   (XY_order_p   )</pre>
<pre>                      ) bmr</pre>
<pre style="background-color: #FF0000;">   (.clk_i</pre>
<pre>    ,.reset_i</pre>
<pre>    ,.v_i    (fifo_valid)</pre>
<pre>    ,.data_i (fifo_data )</pre>
<pre>    ,.yumi_o (fifo_yumi )</pre>
<pre></pre>
<pre>    ,.data_o(data_lo)</pre>
<pre></pre>
<pre></pre>
<pre>    ,.my_y_i</pre>
<pre>    );</pre>
<h3>./external/basejump_stl/bsg_noc/bsg_wormhole_concentrator.v</h3>
<pre>// It has zero bubble between wormhole packets.</pre>
<pre>//</pre>
<pre>//</pre>
<pre></pre>
<pre>module bsg_wormhole_concentrator</pre>
<pre>  #(parameter flit_width_p        = "inv"</pre>
<pre>   ,parameter len_width_p         = "inv"</pre>
<pre>   ,parameter cid_width_p         = "inv"</pre>
<pre>   ,parameter cord_width_p        = "inv"</pre>
<pre>   ,parameter num_in_p            = 1</pre>
<pre>   ,parameter debug_lp            = 0</pre>
<pre>  (input clk_i</pre>
<pre>  ,input reset_i</pre>
<pre>  ,output [num_in_p-1:0][`bsg_ready_and_link_sif_width(flit_width_p)-1:0] links_o</pre>
<pre></pre>
<pre>  ,output [`bsg_ready_and_link_sif_width(flit_width_p)-1:0] concentrated_link_o</pre>
<pre>  );</pre>
<pre style="background-color: #FF0000;">  `declare_bsg_ready_and_link_sif_s(flit_width_p,bsg_ready_and_link_sif_s);</pre>
<pre>  bsg_ready_and_link_sif_s [num_in_p-1:0] links_o_stubbed_v, links_o_stubbed_ready;</pre>
<pre>  </pre>
<pre>  bsg_ready_and_link_sif_s concentrated_link_o_stubbed_v, concentrated_link_o_stubbed_ready;</pre>
<pre>  </pre>
<pre>  assign links_o = links_o_cast;</pre>
<pre></pre>
<pre>  assign concentrated_link_o = concentrated_link_o_cast;</pre>
<pre>  </pre>
<pre>    begin : cast</pre>
<pre>      assign links_o_cast[i].data          = links_o_stubbed_ready[i].data;</pre>
<pre>      assign links_o_cast[i].v             = links_o_stubbed_ready[i].v;</pre>
<pre>      assign links_o_cast[i].ready_and_rev = links_o_stubbed_v[i].ready_and_rev;</pre>
<pre>    end</pre>
<pre>  assign concentrated_link_o_cast.v             = concentrated_link_o_stubbed_ready.v;</pre>
<pre>  assign concentrated_link_o_cast.ready_and_rev = concentrated_link_o_stubbed_v.ready_and_rev;</pre>
<pre></pre>
<pre>   #(.flit_width_p(flit_width_p)</pre>
<pre>     ,.len_width_p(len_width_p)</pre>
<pre>     ,.cid_width_p(cid_width_p)</pre>
<pre>     ,.num_in_p(num_in_p)</pre>
<pre>     ,.cord_width_p(cord_width_p)</pre>
<pre>     ,.debug_lp(debug_lp)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">    (.clk_i(clk_i)</pre>
<pre>     ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>     ,.links_o(links_o_stubbed_v)</pre>
<pre></pre>
<pre>     ,.concentrated_link_o(concentrated_link_o_stubbed_ready)</pre>
<pre>     );</pre>
<pre>   #(.flit_width_p(flit_width_p)</pre>
<pre>     ,.len_width_p(len_width_p)</pre>
<pre>     ,.cid_width_p(cid_width_p)</pre>
<pre>     ,.num_in_p(num_in_p)</pre>
<pre>     ,.cord_width_p(cord_width_p)</pre>
<pre>     ,.debug_lp(debug_lp)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">    (.clk_i(clk_i)</pre>
<pre>     ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>     ,.links_o(links_o_stubbed_ready)</pre>
<pre></pre>
<pre>     ,.concentrated_link_o(concentrated_link_o_stubbed_v)</pre>
<pre>     );</pre>
<h3>./external/basejump_stl/bsg_noc/bsg_wormhole_router_output_control.v</h3>
<pre>module bsg_wormhole_router_output_control</pre>
<pre>  #(parameter input_dirs_p=-1)</pre>
<pre>   (input clk_i</pre>
<pre>    , input reset_i</pre>
<pre>    , input  [input_dirs_p-1:0] reqs_i</pre>
<pre>    , input  [input_dirs_p-1:0] release_i</pre>
<pre>    , input [input_dirs_p-1:0] valid_i</pre>
<pre>    , output [input_dirs_p-1:0] yumi_o</pre>
<pre>    , input ready_i</pre>
<pre>    , output valid_o</pre>
<pre>    , output [input_dirs_p-1:0] data_sel_o</pre>
<pre>   wire [input_dirs_p-1:0] scheduled_r, scheduled_with_release, scheduled_n, grants_lo;</pre>
<pre>   bsg_dff_reset #(.width_p(input_dirs_p)) scheduled_reg (.clk_i, .reset_i, .data_i(scheduled_n), .data_o(scheduled_r));</pre>
<pre>   assign scheduled_with_release = scheduled_r & ~release_i;</pre>
<pre>   wire                     free_to_schedule = !scheduled_with_release;</pre>
<pre>   bsg_round_robin_arb</pre>
<pre>     #(.inputs_p(input_dirs_p)) brr</pre>
<pre>   (.clk_i</pre>
<pre>    ,.reset_i</pre>
<pre>    ,.grants_en_i  (free_to_schedule)      // ports are all free</pre>
<pre>    ,.reqs_i       (reqs_i)                // requests from input ports</pre>
<pre>    ,.grants_o     (grants_lo)             // output grants, takes into account grants_en_i</pre>
<pre>    ,.sel_one_hot_o()                      // output grants, does not take into account grants_en_i</pre>
<pre>    ,.v_o          ()                      // some reqs_i was set</pre>
<pre>    ,.tag_o        ()</pre>
<pre>    ,.yumi_i       (free_to_schedule & valid_o) // update round_robin</pre>
<pre>   assign scheduled_n = grants_lo | scheduled_with_release;</pre>
<pre>   assign data_sel_o = scheduled_n;</pre>
<pre>   assign valid_o = ready_i & (|(scheduled_n & valid_i));</pre>
<pre>   assign yumi_o  = ready_i ? (scheduled_n & valid_i) : '0;</pre>
<h3>./external/basejump_stl/bsg_noc/bsg_mesh_stitch.v</h3>
<pre>module bsg_mesh_stitch</pre>
<pre>  #(parameter width_p = "inv" // data width</pre>
<pre>    , x_max_p = "inv"</pre>
<pre>    , y_max_p = "inv"</pre>
<pre>    , nets_p  = 1 // optional parameter that allows for multiple networks to be routed together</pre>
<pre>   (input    [y_max_p-1:0][x_max_p-1:0][nets_p-1:0][S:W][width_p-1:0] outs_i // for each node, each direction</pre>
<pre>    , output [y_max_p-1:0][x_max_p-1:0][nets_p-1:0][S:W][width_p-1:0] ins_o</pre>
<pre>    , input  [E:W][y_max_p-1:0][nets_p-1:0][width_p-1:0] hor_i</pre>
<pre>    , output [E:W][y_max_p-1:0][nets_p-1:0][width_p-1:0] hor_o</pre>
<pre>    , input  [S:N][x_max_p-1:0][nets_p-1:0][width_p-1:0] ver_i</pre>
<pre>    , output [S:N][x_max_p-1:0][nets_p-1:0][width_p-1:0] ver_o</pre>
<pre style="background-color: #FF0000;">   genvar r,c,net;</pre>
<pre>   for (net = 0; net < nets_p; net=net+1)</pre>
<pre>     begin: _n</pre>
<pre>        for (r = 0; r < y_max_p; r=r+1)</pre>
<pre>          begin: _r</pre>
<pre>             assign hor_o[E][r][net] = outs_i[r][x_max_p-1][net][E];</pre>
<pre>             assign hor_o[W][r][net] = outs_i[r][0        ][net][W];</pre>
<pre>             for (c = 0; c < x_max_p; c=c+1)</pre>
<pre>               begin: _c</pre>
<pre>                 assign ins_o[r][c][net][S] = (r == y_max_p-1)</pre>
<pre>                                            ? ver_i[S][c][net]</pre>
<pre>                                            : outs_i[(r == y_max_p-1) ? r : r+1][c][net][N]; // ?: for warning</pre>
<pre>                 assign ins_o[r][c][net][N] = (r == 0)</pre>
<pre>                                            ? ver_i[N][c][net]</pre>
<pre>                                            : outs_i[r ? r-1: 0][c][net][S]; // ?: to eliminate warning</pre>
<pre>                 assign ins_o[r][c][net][E] = (c == x_max_p-1)</pre>
<pre>                                            ? hor_i[E][r][net]</pre>
<pre>                                            : outs_i[r][(c == x_max_p-1) ? c : (c+1)][net][W]; // ?: for warning</pre>
<pre>                 assign ins_o[r][c][net][W] = (c == 0)</pre>
<pre>                                            ? hor_i[W][r][net]</pre>
<pre>                                            : outs_i[r][c ? (c-1) :0][net][E]; // ?: to eliminate warning</pre>
<pre>        for (c = 0; c < x_max_p; c=c+1)</pre>
<pre>          begin: _c</pre>
<pre>             assign ver_o[S][c][net] = outs_i[y_max_p-1][c][net][S];</pre>
<pre>             assign ver_o[N][c][net] = outs_i[0        ][c][net][N];</pre>
<h3>./external/basejump_stl/bsg_noc/bsg_wormhole_concentrator_out.v</h3>
<pre>// It has zero bubble between wormhole packets.</pre>
<pre>//</pre>
<pre>//</pre>
<pre></pre>
<pre>module bsg_wormhole_concentrator_out</pre>
<pre>  #(parameter flit_width_p        = "inv"</pre>
<pre>   ,parameter len_width_p         = "inv"</pre>
<pre>   ,parameter cid_width_p         = "inv"</pre>
<pre>   ,parameter cord_width_p        = "inv"</pre>
<pre>   ,parameter num_in_p            = 1</pre>
<pre>   ,parameter debug_lp            = 0</pre>
<pre>  (input clk_i</pre>
<pre>  ,input reset_i</pre>
<pre>  ,output [num_in_p-1:0][`bsg_ready_and_link_sif_width(flit_width_p)-1:0] links_o</pre>
<pre></pre>
<pre>  ,output [`bsg_ready_and_link_sif_width(flit_width_p)-1:0] concentrated_link_o</pre>
<pre>  );</pre>
<pre style="background-color: #FF0000;">  `declare_bsg_ready_and_link_sif_s(flit_width_p,bsg_ready_and_link_sif_s);</pre>
<pre style="background-color: #FF0000;">  `declare_bsg_wormhole_concentrator_header_s(cord_width_p, len_width_p, cid_width_p, bsg_wormhole_concentrator_header_s);</pre>
<pre>  bsg_ready_and_link_sif_s concentrated_link_i_cast, concentrated_link_o_cast;</pre>
<pre>  </pre>
<pre>  assign links_o = links_o_cast;</pre>
<pre>  </pre>
<pre>  assign concentrated_link_o = concentrated_link_o_cast;</pre>
<pre>  </pre>
<pre style="background-color: #FF0000;"></pre>
<pre>    begin : stub</pre>
<pre>      assign links_o_cast[i].ready_and_rev = 1'b0;</pre>
<pre>    end</pre>
<pre>  assign concentrated_link_o_cast.data = 1'b0;</pre>
<pre></pre>
<pre>  wire                    concentrated_fifo_valid_lo;</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre>    (.clk_i</pre>
<pre>    ,.reset_i</pre>
<pre>    ,.ready_o(concentrated_link_o_cast.ready_and_rev)</pre>
<pre>    ,.data_i (concentrated_link_i_cast.data)</pre>
<pre>    ,.v_i    (concentrated_link_i_cast.v)</pre>
<pre>    ,.v_o    (concentrated_fifo_valid_lo)</pre>
<pre>    ,.data_o (concentrated_fifo_data_lo )</pre>
<pre>    ,.yumi_i (concentrated_any_yumi)</pre>
<pre>     );</pre>
<pre>  assign concentrated_hdr = concentrated_fifo_data_lo[$bits(bsg_wormhole_concentrator_header_s)-1:0];</pre>
<pre>  </pre>
<pre>  bsg_decode #(.num_out_p(num_in_p)) concentrated_decoder</pre>
<pre>    (.i(concentrated_hdr.cid[0+:`BSG_SAFE_CLOG2(num_in_p)])</pre>
<pre>    ,.o(concentrated_decoded_dest_lo)</pre>
<pre>    );</pre>
<pre>    (.clk_i</pre>
<pre>    ,.reset_i</pre>
<pre>    ,.fifo_v_i           (concentrated_fifo_valid_lo)</pre>
<pre>    ,.fifo_yumi_i        (concentrated_any_yumi)</pre>
<pre>    ,.fifo_decoded_dest_i(concentrated_decoded_dest_lo)</pre>
<pre>    ,.fifo_payload_len_i (concentrated_hdr.len)</pre>
<pre>    ,.reqs_o             (concentrated_reqs)</pre>
<pre>    ,.release_o          (concentrated_releases) // broadcast to all</pre>
<pre>    ,.detected_header_o  ()</pre>
<pre>    );</pre>
<pre>    begin: out_ch</pre>
<pre></pre>
<pre>        (.clk_i</pre>
<pre>        ,.reset_i</pre>
<pre>        ,.reqs_i    (concentrated_reqs[i] )</pre>
<pre>        ,.release_i (concentrated_releases)</pre>
<pre>        ,.valid_i   (concentrated_fifo_valid_lo)</pre>
<pre>        ,.yumi_o    (concentrated_yumis[i])</pre>
<pre>        ,.ready_i   (links_i_cast[i].ready_and_rev)</pre>
<pre>        ,.valid_o   (links_o_cast[i].v)</pre>
<pre>        ,.data_sel_o()</pre>
<pre>        );</pre>
<pre>      </pre>
<h3>./bp_common/src/v/bp_tlb.v</h3>
<pre>module bp_tlb</pre>
<pre>  import bp_common_aviary_pkg::*;</pre>
<pre> #(parameter bp_cfg_e cfg_p = e_bp_inv_cfg</pre>
<pre>   `declare_bp_proc_params(cfg_p)</pre>
<pre style="background-color: #FF0000;">   ,parameter tlb_els_p       = "inv"</pre>
<pre>   </pre>
<pre style="background-color: #FF0000;">   ,localparam lg_els_lp      = `BSG_SAFE_CLOG2(tlb_els_p)</pre>
<pre>   ,localparam entry_width_lp = `bp_pte_entry_leaf_width(paddr_width_p)</pre>
<pre> )</pre>
<pre> (input                               clk_i</pre>
<pre>  , input                             reset_i</pre>
<pre>  , input                             flush_i</pre>
<pre>  </pre>
<pre>  , input                             w_i</pre>
<pre>  , input [vtag_width_p-1:0]          vtag_i</pre>
<pre>  , input [entry_width_lp-1:0]        entry_i</pre>
<pre>    </pre>
<pre style="background-color: #FF0000;">  , output logic                      v_o</pre>
<pre>  , output logic [entry_width_lp-1:0] entry_o</pre>
<pre>  </pre>
<pre>  , output logic [vtag_width_p-1:0]   miss_vtag_o</pre>
<pre> );</pre>
<pre style="background-color: #FF0000;">`declare_bp_fe_be_if(vaddr_width_p, paddr_width_p, asid_width_p, branch_metadata_fwd_width_p);</pre>
<pre style="background-color: #FF0000;">bp_pte_entry_leaf_s r_entry, w_entry, ram_r_data;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">logic [lg_els_lp-1:0] cam_w_addr, cam_r_addr, ram_addr;</pre>
<pre>logic                 r_v, w_v, cam_r_v;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">assign entry_o    = r_entry;</pre>
<pre>assign w_entry    = entry_i;</pre>
<pre>  </pre>
<pre>assign w_v        = v_i & w_i; </pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;">bsg_dff_reset #(.width_p(1))</pre>
<pre>  r_v_reg</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre>   ,.data_i(r_v & cam_r_v)</pre>
<pre>   ,.data_o(v_o)</pre>
<pre>  );</pre>
<pre style="background-color: #FF0000;">bsg_dff_reset #(.width_p(1))</pre>
<pre>  miss_v_reg</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre>   ,.data_i(r_v & ~cam_r_v)</pre>
<pre>   ,.data_o(miss_v_o)</pre>
<pre>  );</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">bsg_dff_reset #(.width_p(vtag_width_p))</pre>
<pre>  miss_vtag_reg</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre>   ,.data_i(vtag_i)</pre>
<pre>   ,.data_o(miss_vtag_o)</pre>
<pre>  );</pre>
<pre style="background-color: #FF0000;">  </pre>
<pre>bp_tlb_replacement #(.ways_p(dtlb_els_p))</pre>
<pre>  plru</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i | flush_i)</pre>
<pre>   </pre>
<pre>   ,.way_i(cam_r_addr)</pre>
<pre>   </pre>
<pre>   ,.way_o(cam_w_addr)</pre>
<pre>  ); </pre>
<pre>  </pre>
<pre>  #(.els_p(dtlb_els_p)</pre>
<pre>    ,.width_p(vtag_width_p)</pre>
<pre>    ,.multiple_entries_p(0)</pre>
<pre>    ,.find_empty_entry_p(1)</pre>
<pre>  )</pre>
<pre style="background-color: #FF0000;">  vtag_cam</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i | flush_i)</pre>
<pre>   ,.en_i(1'b1)</pre>
<pre>   </pre>
<pre>   ,.w_v_i(w_v)</pre>
<pre>   ,.w_set_not_clear_i(1'b1)</pre>
<pre>   ,.w_addr_i(cam_w_addr)</pre>
<pre>   ,.w_data_i(vtag_i)</pre>
<pre>  </pre>
<pre>   ,.r_v_i(r_v)</pre>
<pre>   ,.r_data_i(vtag_i)</pre>
<pre>   </pre>
<pre>   ,.r_v_o(cam_r_v)</pre>
<pre>   ,.r_addr_o(cam_r_addr)</pre>
<pre>   </pre>
<pre style="background-color: #FF0000;">   ,.empty_v_o()</pre>
<pre>   ,.empty_addr_o()</pre>
<pre>  );</pre>
<pre></pre>
<pre>bsg_mem_1rw_sync</pre>
<pre>  #(.width_p(entry_width_lp)</pre>
<pre>    ,.els_p(dtlb_els_p)</pre>
<pre>  )</pre>
<pre>  entry_ram</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre>   ,.data_i(w_entry)</pre>
<pre>   ,.addr_i(ram_addr)</pre>
<pre>   ,.v_i(cam_r_v | w_v)</pre>
<pre>   ,.w_i(w_v)</pre>
<pre>   ,.data_o(r_entry)</pre>
<pre>  );</pre>
<pre>endmodule</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./external/basejump_stl/bsg_noc/bsg_wormhole_router.v</h3>
<pre>module bsg_wormhole_router</pre>
<pre>  #(parameter flit_width_p        = "inv"</pre>
<pre>   ,parameter dims_p              = 2 // 1</pre>
<pre>   ,parameter dirs_lp         = dims_p*2+1</pre>
<pre></pre>
<pre>   ,parameter cord_dims_p = dims_p</pre>
<pre>   ,parameter int cord_markers_pos_p[cord_dims_p:0] =   '{ 5, 4, 0 }  // '{5,0} //</pre>
<pre>   ,parameter bit [1:0][dirs_lp-1:0][dirs_lp-1:0] routing_matrix_p =  (dims_p == 2) ? StrictXY : StrictX</pre>
<pre>   ,parameter reverse_order_p       = 0</pre>
<pre>   ,parameter len_width_p           = "inv"</pre>
<pre>   ,parameter debug_lp              = 0</pre>
<pre>  (input clk_i</pre>
<pre>  ,input reset_i</pre>
<pre>  ,output [dirs_lp-1:0][`bsg_ready_and_link_sif_width(flit_width_p)-1:0] link_o</pre>
<pre></pre>
<pre>  );</pre>
<pre>  localparam output_dirs_lp = dirs_lp;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">  `declare_bsg_wormhole_router_header_s(cord_markers_pos_p[dims_p], len_width_p, bsg_wormhole_router_header_s);</pre>
<pre></pre>
<pre>`ifndef SYNTHESIS</pre>
<pre style="background-color: #FF0000;">    wire [dirs_lp-1:0][dirs_lp-1:0] matrix_out_in_transpose;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">    bsg_transpose #(.width_p(dirs_lp),.els_p(dirs_lp)) tr (.i(routing_matrix_p[0])</pre>
<pre>                                                          ,.o(matrix_out_in_transpose)</pre>
<pre>                                                          );</pre>
<pre>      begin</pre>
<pre>        assert (routing_matrix_p[1] == matrix_out_in_transpose)</pre>
<pre>          else $error("inconsistent matrixes");</pre>
<pre>      end</pre>
<pre>  wire [input_dirs_lp-1:0]                     fifo_valid_lo;</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;">  `declare_bsg_ready_and_link_sif_s(flit_width_p,bsg_ready_and_link_sif_s);</pre>
<pre></pre>
<pre>  assign link_o = link_o_cast;</pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">    begin: in_ch</pre>
<pre>      localparam output_dirs_sparse_lp = `BSG_COUNTONES_SYNTH(routing_matrix_p[0][i]);</pre>
<pre>      wire [output_dirs_sparse_lp-1:0] decoded_dest_sparse_lo;</pre>
<pre>      wire [output_dirs_sparse_lp-1:0] reqs_lo, yumis_li;</pre>
<pre></pre>
<pre>      (.i(yumis_transpose[i])</pre>
<pre>       ,.o(yumis_li)</pre>
<pre>      );</pre>
<pre></pre>
<pre>        (.clk_i</pre>
<pre>         ,.reset_i</pre>
<pre>        ,.ready_o(link_o_cast[i].ready_and_rev)</pre>
<pre>        ,.data_i (link_i_cast[i].data)</pre>
<pre>        ,.v_i    (link_i_cast[i].v)</pre>
<pre>        ,.v_o    (fifo_valid_lo[i])</pre>
<pre>        ,.data_o (fifo_data_lo [i])</pre>
<pre>        ,.yumi_i (any_yumi)</pre>
<pre>         );</pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;">        begin</pre>
<pre style="background-color: #FF0000;">           logic release_r;</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">             release_r <= releases[i];</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">             begin</pre>
<pre style="background-color: #FF0000;">                if (releases[i] & ~release_r)</pre>
<pre style="background-color: #FF0000;">                  $display("%m in  ch%2d: packet finished last cycle",i);</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">                  $display("%m in  ch%2d: nacking   packet %h",i,link_i_cast[i].data);</pre>
<pre style="background-color: #FF0000;">                else</pre>
<pre style="background-color: #FF0000;">                    $display("%m in  ch%2d: accepting packet %h",i,link_i_cast[i].data);</pre>
<pre style="background-color: #FF0000;">                if ((reset_i === 1'b0) && any_yumi)</pre>
<pre style="background-color: #FF0000;">                  begin</pre>
<pre style="background-color: #FF0000;">                     assert (fifo_valid_lo[i]) else $error("Error dequeing when data not available");</pre>
<pre style="background-color: #FF0000;">                     if (reqs_lo)</pre>
<pre style="background-color: #FF0000;">                       $display("%m in  ch%2d: dequeing  header %h (outch=%b,len=%b,dest=%b)",i,fifo_data_lo[i],reqs_lo,hdr.len,hdr.cord);</pre>
<pre style="background-color: #FF0000;">                     else</pre>
<pre style="background-color: #FF0000;">                  end</pre>
<pre>                                       ,.cord_dims_p(cord_dims_p)</pre>
<pre>                                       ,.reverse_order_p(reverse_order_p)</pre>
<pre>                                       ,.cord_markers_pos_p(cord_markers_pos_p)</pre>
<pre>                                       ) dor</pre>
<pre style="background-color: #FF0000;">      (.target_cord_i(hdr.cord)</pre>
<pre>       ,.my_cord_i</pre>
<pre>       ,.req_o(decoded_dest_lo)</pre>
<pre>      );</pre>
<pre>      (.i(decoded_dest_lo)</pre>
<pre>       ,.o(decoded_dest_sparse_lo)</pre>
<pre>      );</pre>
<pre></pre>
<pre>      (.clk_i</pre>
<pre>       ,.reset_i</pre>
<pre>       ,.fifo_v_i           (fifo_valid_lo[i])</pre>
<pre>       ,.fifo_yumi_i        (any_yumi)</pre>
<pre>       ,.fifo_decoded_dest_i(decoded_dest_sparse_lo)</pre>
<pre>       ,.fifo_payload_len_i (hdr.len)</pre>
<pre>       ,.reqs_o             (reqs_lo)</pre>
<pre>       ,.release_o          (releases[i]) // broadcast to all</pre>
<pre>       ,.detected_header_o  (detected_header_lo)</pre>
<pre>      );</pre>
<pre>        (.i  (reqs_lo)</pre>
<pre>         ,.o (reqs[i]) // unicast</pre>
<pre>       );</pre>
<pre>        if (debug_lp)</pre>
<pre>          assert (detected_header_lo!==1'b1 || !(decoded_dest_lo & ~ routing_matrix_p[0][i]))</pre>
<pre>            else $error("%m input port %d request to route in direction not supported by router %b %b",i,decoded_dest_lo, routing_matrix_p[0][i]);</pre>
<pre>`endif</pre>
<pre>   (.i(reqs)</pre>
<pre>    ,.o(reqs_transpose)</pre>
<pre>   );</pre>
<pre style="background-color: #FF0000;">    begin: out_ch</pre>
<pre>      localparam input_dirs_sparse_lp = `BSG_COUNTONES_SYNTH(routing_matrix_p[1][i]);</pre>
<pre>      wire [input_dirs_sparse_lp-1:0][flit_width_p-1:0] fifo_data_sparse_lo;</pre>
<pre></pre>
<pre>      (.i(reqs_transpose[i]),.o(reqs_li));</pre>
<pre></pre>
<pre>      (.i(releases),.o(release_li));</pre>
<pre></pre>
<pre>      (.i(fifo_valid_lo),.o(valids_li));</pre>
<pre></pre>
<pre>      (.i(fifo_data_lo),.o(fifo_data_sparse_lo));</pre>
<pre></pre>
<pre>      (.clk_i</pre>
<pre>      ,.reset_i</pre>
<pre>      ,.reqs_i    (reqs_li   )</pre>
<pre>      ,.release_i (release_li)</pre>
<pre>      ,.valid_i   (valids_li )</pre>
<pre>      ,.yumi_o    (yumis_lo  )</pre>
<pre>      ,.ready_i   (link_i_cast[i].ready_and_rev)</pre>
<pre>      ,.valid_o   (link_o_cast[i].v)</pre>
<pre>      ,.data_sel_o(data_sel_lo)</pre>
<pre>      );</pre>
<pre>         begin</pre>
<pre>            if (debug_lp)</pre>
<pre>              begin</pre>
<pre>                if ((reset_i === 1'b0) && link_o_cast[i].v)</pre>
<pre>                  begin</pre>
<pre>                     // shouldn't really be an error condition; more of indicator that something is not tested enough!</pre>
<pre>                     $display("%m out ch%2d: sending   packet %h",i,link_o_cast[i].data);</pre>
<pre>                  end</pre>
<pre>                       ,.els_p(input_dirs_sparse_lp)</pre>
<pre>                       ) data_mux</pre>
<pre style="background-color: #FF0000;">      (.data_i(fifo_data_sparse_lo)</pre>
<pre>       ,.sel_one_hot_i(data_sel_lo)</pre>
<pre>       ,.data_o(link_o_cast[i].data)</pre>
<pre>      );</pre>
<pre>      (.i (yumis_lo)</pre>
<pre>       ,.o (yumis[i])</pre>
<pre>      );</pre>
<pre>   (.i(yumis)</pre>
<pre>    ,.o(yumis_transpose)</pre>
<pre>   );</pre>
<h3>./external/basejump_stl/bsg_noc/bsg_wormhole_router_input_control.v</h3>
<pre>module bsg_wormhole_router_input_control #(parameter output_dirs_p=-1, parameter payload_len_bits_p=-1)</pre>
<pre>   (input clk_i</pre>
<pre>    , input reset_i</pre>
<pre>    , input fifo_v_i</pre>
<pre>    , input [output_dirs_p-1:0]      fifo_decoded_dest_i</pre>
<pre>    , input [payload_len_bits_p-1:0] fifo_payload_len_i</pre>
<pre>    , input fifo_yumi_i</pre>
<pre>    , output [output_dirs_p-1:0] reqs_o</pre>
<pre>    , output release_o</pre>
<pre>    , output detected_header_o</pre>
<pre>   wire [payload_len_bits_p-1:0] payload_ctr_r;</pre>
<pre>   wire                       counter_expired    = (!payload_ctr_r);</pre>
<pre>   wire                       fifo_has_hdr = counter_expired & fifo_v_i;</pre>
<pre>   bsg_counter_set_down #(.width_p(payload_len_bits_p), .set_and_down_exclusive_p(1'b1)) ctr</pre>
<pre>   (.clk_i</pre>
<pre>    ,.reset_i</pre>
<pre>    ,.set_i    (fifo_yumi_i & counter_expired)   // somebody accepted our header</pre>
<pre>    ,.val_i    (fifo_payload_len_i)</pre>
<pre>    ,.down_i   (fifo_yumi_i & ~counter_expired) // we decrement if somebody grabbed a word and it was not a header</pre>
<pre>    ,.count_r_o(payload_ctr_r)                  // decrement after we no longer have a header</pre>
<pre>   assign reqs_o    = fifo_has_hdr ? fifo_decoded_dest_i : '0;</pre>
<pre>   assign release_o = counter_expired;</pre>
<pre>   assign detected_header_o = fifo_has_hdr;</pre>
<h3>./external/basejump_stl/bsg_noc/bsg_wormhole_router_adapter_out.v</h3>
<pre></pre>
<pre>module bsg_wormhole_router_adapter_out</pre>
<pre>  #(parameter max_payload_width_p = "inv"</pre>
<pre>    , parameter len_width_p       = "inv"</pre>
<pre>    , parameter cord_width_p      = "inv"</pre>
<pre>    , parameter flit_width_p      = "inv"</pre>
<pre></pre>
<pre>    , localparam bsg_ready_and_link_sif_width_lp =</pre>
<pre>        `bsg_ready_and_link_sif_width(flit_width_p)</pre>
<pre>    , localparam bsg_wormhole_packet_width_lp =</pre>
<pre>        `bsg_wormhole_router_packet_width(cord_width_p, len_width_p, max_payload_width_p)</pre>
<pre>    , input                                        reset_i</pre>
<pre></pre>
<pre>    , input [bsg_ready_and_link_sif_width_lp-1:0]  link_i </pre>
<pre>    , output [bsg_ready_and_link_sif_width_lp-1:0] link_o</pre>
<pre></pre>
<pre>    , output                                       v_o</pre>
<pre>    , input                                        yumi_i</pre>
<pre>    );</pre>
<pre style="background-color: #FF0000;">  `declare_bsg_ready_and_link_sif_s(flit_width_p, bsg_ready_and_link_sif_s);</pre>
<pre></pre>
<pre>  assign link_o = link_cast_o;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">  `declare_bsg_wormhole_router_header_s(cord_width_p, len_width_p, bsg_wormhole_header_s);</pre>
<pre>  assign header_li = link_cast_i.data;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">  `declare_bsg_wormhole_router_packet_s(cord_width_p,len_width_p,max_payload_width_p,bsg_wormhole_packet_s);</pre>
<pre>  localparam protocol_len_lp  = `BSG_SAFE_CLOG2(max_num_flits_lp);</pre>
<pre>  logic [max_num_flits_lp*flit_width_p-1:0] packet_padded_lo;</pre>
<pre>  bsg_serial_in_parallel_out_dynamic</pre>
<pre>   #(.width_p(flit_width_p)</pre>
<pre>     ,.max_els_p(max_num_flits_lp)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">    (.clk_i(clk_i)</pre>
<pre>     ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>     ,.len_i(protocol_len_lp'(header_li.len))</pre>
<pre>     ,.ready_o(link_cast_o.ready_and_rev)</pre>
<pre>     ,.len_ready_o(/* unused */)</pre>
<pre>     ,.v_i(link_cast_i.v)</pre>
<pre></pre>
<pre>     ,.data_o(packet_padded_lo)</pre>
<pre>     ,.yumi_i(yumi_i)</pre>
<pre>     );</pre>
<pre></pre>
<pre>  assign link_cast_o.v    = '0;</pre>
<pre></pre>
<pre>  bsg_dff_reset_en</pre>
<pre>   #(.width_p(1))</pre>
<pre>   recv_reg</pre>
<pre style="background-color: #FF0000;">    (.clk_i(clk_i)</pre>
<pre>     ,.reset_i(reset_i)</pre>
<pre>     ,.en_i(link_cast_i.v || yumi_i)</pre>
<pre></pre>
<pre>     ,.data_o(recv_r)</pre>
<pre>     );</pre>
<pre></pre>
<h3>./external/basejump_stl/bsg_noc/bsg_wormhole_router_adapter.v</h3>
<pre>module bsg_wormhole_router_adapter</pre>
<pre>  #(parameter max_payload_width_p = "inv"</pre>
<pre>    , parameter len_width_p       = "inv"</pre>
<pre>    , parameter cord_width_p      = "inv"</pre>
<pre>    , parameter flit_width_p      = "inv"</pre>
<pre></pre>
<pre>    , localparam bsg_ready_and_link_sif_width_lp =</pre>
<pre>        `bsg_ready_and_link_sif_width(flit_width_p)</pre>
<pre>    , localparam bsg_wormhole_packet_width_lp =</pre>
<pre>        `bsg_wormhole_router_packet_width(cord_width_p, len_width_p, max_payload_width_p)</pre>
<pre>    )</pre>
<pre>   (input                                          clk_i</pre>
<pre>    , input                                        reset_i</pre>
<pre></pre>
<pre>    , input                                        v_i</pre>
<pre>    , output                                       ready_o</pre>
<pre> </pre>
<pre>    // To the wormhole router</pre>
<pre></pre>
<pre>    , output                                       v_o</pre>
<pre>    , input                                        yumi_i</pre>
<pre>    );</pre>
<pre>  `declare_bsg_ready_and_link_sif_s(flit_width_p, bsg_ready_and_link_sif_s);</pre>
<pre>  bsg_ready_and_link_sif_s link_o_stubbed_v, link_o_stubbed_ready;</pre>
<pre></pre>
<pre>  assign link_o = link_cast_o;</pre>
<pre></pre>
<pre>  assign link_cast_o.v             = link_o_stubbed_ready.v;</pre>
<pre>  assign link_cast_o.ready_and_rev = link_o_stubbed_v.ready_and_rev;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">  `declare_bsg_wormhole_router_packet_s(cord_width_p,len_width_p,max_payload_width_p,bsg_wormhole_packet_s);</pre>
<pre></pre>
<pre>  bsg_wormhole_router_adapter_in</pre>
<pre>   #(.max_payload_width_p(max_payload_width_p)</pre>
<pre>     ,.len_width_p(len_width_p)</pre>
<pre>     ,.cord_width_p(cord_width_p)</pre>
<pre>     ,.flit_width_p(flit_width_p)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">    (.clk_i(clk_i)</pre>
<pre>     ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>     ,.v_i(v_i)</pre>
<pre>     ,.ready_o(ready_o)</pre>
<pre></pre>
<pre>     ,.link_o(link_o_stubbed_ready)</pre>
<pre>     );</pre>
<pre>   #(.max_payload_width_p(max_payload_width_p)</pre>
<pre>     ,.len_width_p(len_width_p)</pre>
<pre>     ,.cord_width_p(cord_width_p)</pre>
<pre>     ,.flit_width_p(flit_width_p)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">    (.clk_i(clk_i)</pre>
<pre>     ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>     ,.link_o(link_o_stubbed_v)</pre>
<pre></pre>
<pre>     ,.v_o(v_o)</pre>
<pre>     ,.yumi_i(yumi_i)</pre>
<pre>     );</pre>
<pre></pre>
<h3>./external/basejump_stl/bsg_noc/bsg_wormhole_router_decoder_dor.v</h3>
<pre>module bsg_wormhole_router_decoder_dor</pre>
<pre>#(parameter dims_p=2</pre>
<pre>  ,parameter cord_dims_p=dims_p</pre>
<pre>  ,parameter reverse_order_p=0 // e.g., 1->Y THEN X, 0->X THEN Y routing</pre>
<pre>  , parameter int cord_markers_pos_p[cord_dims_p:0] = '{ 5, 4, 0 }</pre>
<pre>  , parameter output_dirs_lp=2*dims_p+1</pre>
<pre>   (input   [cord_markers_pos_p[dims_p]-1:0]    target_cord_i</pre>
<pre>    , input [cord_markers_pos_p[dims_p]-1:0]        my_cord_i</pre>
<pre>    , output [output_dirs_lp-1:0]                       req_o</pre>
<pre style="background-color: #FF0000;">   genvar i;</pre>
<pre>   logic [dims_p-1:0] eq, lt, gt;</pre>
<pre>   for (i = 0; i < dims_p; i=i+1)</pre>
<pre>     begin: rof</pre>
<pre>        localparam upper_marker_lp = cord_markers_pos_p[i+1];</pre>
<pre>        localparam lower_marker_lp = cord_markers_pos_p[i];</pre>
<pre>        localparam local_cord_width_p = upper_marker_lp - lower_marker_lp;</pre>
<pre>        wire [local_cord_width_p-1:0] targ_cord = target_cord_i[upper_marker_lp-1:lower_marker_lp];</pre>
<pre>        wire [local_cord_width_p-1:0] my_cord   =     my_cord_i[upper_marker_lp-1:lower_marker_lp];</pre>
<pre>        assign eq[i] = (targ_cord == my_cord);</pre>
<pre>        assign lt[i] = (targ_cord < my_cord);</pre>
<pre>        assign gt[i] = ~eq[i] & ~lt[i];</pre>
<pre>   assign req_o[0] = & eq;  // processor is at 0 in enum</pre>
<pre>   if (reverse_order_p)</pre>
<pre>     begin: rev</pre>
<pre>        assign req_o[(dims_p-1)*2+1]   = lt[dims_p-1];</pre>
<pre>        assign req_o[(dims_p-1)*2+1+1] = gt[dims_p-1];</pre>
<pre>        if (dims_p > 1)</pre>
<pre>          begin : fi1</pre>
<pre>            for (i = (dims_p-1)-1; i >= 0; i--)</pre>
<pre>              begin: rof3</pre>
<pre>                 assign req_o[i*2+1]   = &eq[dims_p-1:i+1] & lt[i];</pre>
<pre>                 assign req_o[i*2+1+1] = &eq[dims_p-1:i+1] & gt[i];</pre>
<pre>     begin: fwd</pre>
<pre>        assign req_o[1] = lt[0]; // down   (W,N)</pre>
<pre>        assign req_o[2] = gt[0]; // up     (E,S)</pre>
<pre>        for (i = 1; i < dims_p; i++)</pre>
<pre>          begin: rof2</pre>
<pre>             assign req_o[i*2+1]   = (&eq[i-1:0]) & lt[i];</pre>
<pre>             assign req_o[i*2+1+1] = (&eq[i-1:0]) & gt[i];</pre>
<pre>       initial assert(bsg_noc_pkg::P == 0</pre>
<pre>                      && bsg_noc_pkg::W == 1</pre>
<pre>                      && bsg_noc_pkg::E == 2</pre>
<pre>                      && bsg_noc_pkg::N == 3</pre>
<pre>                      && bsg_noc_pkg::S == 4) else $error("%m: bsg_noc_pkg dirs are inconsistent with this module");</pre>
<h3>./external/basejump_stl/bsg_noc/bsg_wormhole_router_adapter_in.v</h3>
<pre>module bsg_wormhole_router_adapter_in</pre>
<pre>  #(parameter max_payload_width_p = "inv"</pre>
<pre>    , parameter len_width_p       = "inv"</pre>
<pre>    , parameter cord_width_p      = "inv"</pre>
<pre>    , parameter flit_width_p      = "inv"</pre>
<pre></pre>
<pre>    , localparam bsg_ready_and_link_sif_width_lp =</pre>
<pre>        `bsg_ready_and_link_sif_width(flit_width_p)</pre>
<pre>    , localparam bsg_wormhole_packet_width_lp = </pre>
<pre>        `bsg_wormhole_router_packet_width(cord_width_p, len_width_p, max_payload_width_p)</pre>
<pre>    , input                                        reset_i</pre>
<pre></pre>
<pre>    , input [bsg_wormhole_packet_width_lp-1:0]     packet_i</pre>
<pre>    , input                                        v_i</pre>
<pre>    , output                                       ready_o</pre>
<pre></pre>
<pre>    , input [bsg_ready_and_link_sif_width_lp-1:0]  link_i </pre>
<pre>    );</pre>
<pre style="background-color: #FF0000;">  `declare_bsg_ready_and_link_sif_s(flit_width_p, bsg_ready_and_link_sif_s);</pre>
<pre></pre>
<pre style="background-color: #FF0000;">  `declare_bsg_wormhole_router_packet_s(cord_width_p, len_width_p, max_payload_width_p, bsg_wormhole_packet_s);</pre>
<pre>  assign packet_cast_i = packet_i;</pre>
<pre></pre>
<pre>  localparam protocol_len_lp  = `BSG_SAFE_CLOG2(max_num_flits_lp);</pre>
<pre>  wire [max_num_flits_lp*flit_width_p-1:0] packet_padded_li = packet_i;</pre>
<pre></pre>
<pre>  assign link_o        = link_cast_o;</pre>
<pre></pre>
<pre>   #(.width_p(flit_width_p)</pre>
<pre>     ,.max_els_p(max_num_flits_lp)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">    (.clk_i(clk_i)</pre>
<pre>     ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>     ,.len_i(protocol_len_lp'(packet_cast_i.len))</pre>
<pre>     ,.data_i(packet_padded_li)</pre>
<pre>     ,.ready_o(ready_o)</pre>
<pre></pre>
<pre>     ,.len_v_o(/* unused */)</pre>
<pre>     ,.data_o(link_cast_o.data)</pre>
<pre>     ,.yumi_i(link_cast_i.ready_and_rev & link_cast_o.v)</pre>
<pre>     );</pre>
<pre></pre>
<pre>    assert(reset_i || ~v_i || (packet_cast_i.len <= max_num_flits_lp))</pre>
<pre>      else </pre>
<pre style="background-color: #FF0000;">        $error("Packet received with len: %x > max_num_flits: %x", packet_cast_i.len, max_num_flits_lp);</pre>
<pre>`endif</pre>
<h3>./bp_be/src/v/bp_be_calculator/bp_be_instr_decoder.v</h3>
<pre>module bp_be_instr_decoder </pre>
<pre style="background-color: #FF0000;"> #(// Generated parameters</pre>
<pre>   , localparam decode_width_lp = `bp_be_decode_width</pre>
<pre>   , input [instr_width_lp-1:0]      instr_i</pre>
<pre>   , input                           fe_exc_not_instr_i</pre>
<pre>   , input bp_fe_exception_code_e    fe_exc_i</pre>
<pre></pre>
<pre>   );</pre>
<pre>bp_be_decode_s decode;</pre>
<pre></pre>
<pre>assign decode_o        = decode;</pre>
<pre></pre>
<pre></pre>
<pre>  begin</pre>
<pre>    // Set decoded defaults</pre>
<pre>    decode.v             = 1'b1;</pre>
<pre>    decode.instr_v       = 1'b1;</pre>
<pre></pre>
<pre>    decode.pipe_int_v    = '0;</pre>
<pre>    decode.pipe_mul_v    = '0;</pre>
<pre>    decode.pipe_mem_v    = '0;</pre>
<pre>    decode.pipe_fp_v     = '0;</pre>
<pre></pre>
<pre>    decode.frf_w_v       = '0;</pre>
<pre>    decode.dcache_r_v    = '0;</pre>
<pre>    decode.dcache_w_v    = '0;</pre>
<pre></pre>
<pre>    decode.csr_v         = '0;</pre>
<pre></pre>
<pre></pre>
<pre>    decode.jmp_v         = '0;</pre>
<pre>    decode.br_v          = '0;</pre>
<pre>    decode.opw_v         = '0;</pre>
<pre></pre>
<pre>    decode.src1_sel      = bp_be_src1_e'('0);</pre>
<pre>    decode.src2_sel      = bp_be_src2_e'('0);</pre>
<pre>    decode.baddr_sel     = bp_be_baddr_e'('0);</pre>
<pre>    decode.result_sel    = bp_be_result_e'('0);</pre>
<pre>    decode.offset_sel    = e_offset_is_imm;</pre>
<pre></pre>
<pre></pre>
<pre>      `RV64_OP_OP, `RV64_OP_32_OP : </pre>
<pre>        begin</pre>
<pre>          decode.pipe_int_v = 1'b1;</pre>
<pre>          decode.irf_w_v    = 1'b1;</pre>
<pre>          decode.opw_v      = (instr.opcode == `RV64_OP_32_OP);</pre>
<pre>          unique casez (instr)</pre>
<pre>            `RV64_ADD, `RV64_ADDW : decode.fu_op = e_int_op_add;</pre>
<pre>            `RV64_SUB, `RV64_SUBW : decode.fu_op = e_int_op_sub;</pre>
<pre>            `RV64_SLL, `RV64_SLLW : decode.fu_op = e_int_op_sll; </pre>
<pre>            `RV64_SRL, `RV64_SRLW : decode.fu_op = e_int_op_srl;</pre>
<pre>            `RV64_SRA, `RV64_SRAW : decode.fu_op = e_int_op_sra;</pre>
<pre>            `RV64_SLT             : decode.fu_op = e_int_op_slt; </pre>
<pre>            `RV64_SLTU            : decode.fu_op = e_int_op_sltu;</pre>
<pre>            `RV64_XOR             : decode.fu_op = e_int_op_xor;</pre>
<pre>            `RV64_OR              : decode.fu_op = e_int_op_or;</pre>
<pre>            `RV64_AND             : decode.fu_op = e_int_op_and;</pre>
<pre>            default : illegal_instr = 1'b1;</pre>
<pre>          endcase</pre>
<pre>          decode.src2_sel   = e_src2_is_rs2;</pre>
<pre>          decode.result_sel = e_result_from_alu;</pre>
<pre>        end</pre>
<pre>        begin</pre>
<pre>          decode.pipe_int_v = 1'b1;</pre>
<pre>          decode.irf_w_v    = 1'b1;</pre>
<pre>          decode.opw_v      = (instr.opcode == `RV64_OP_IMM_32_OP);</pre>
<pre>          unique casez (instr)</pre>
<pre>            `RV64_ADDI, `RV64_ADDIW : decode.fu_op = e_int_op_add;</pre>
<pre>            `RV64_SLLI, `RV64_SLLIW : decode.fu_op = e_int_op_sll;</pre>
<pre>            `RV64_SRLI, `RV64_SRLIW : decode.fu_op = e_int_op_srl;</pre>
<pre>            `RV64_SRAI, `RV64_SRAIW : decode.fu_op = e_int_op_sra;</pre>
<pre>            `RV64_SLTI              : decode.fu_op = e_int_op_slt;</pre>
<pre>            `RV64_SLTIU             : decode.fu_op = e_int_op_sltu;</pre>
<pre>            `RV64_XORI              : decode.fu_op = e_int_op_xor;</pre>
<pre>            `RV64_ORI               : decode.fu_op = e_int_op_or;</pre>
<pre>            `RV64_ANDI              : decode.fu_op = e_int_op_and;</pre>
<pre>            default : illegal_instr = 1'b1;</pre>
<pre>          endcase</pre>
<pre>          decode.src2_sel   = e_src2_is_imm;</pre>
<pre>          decode.result_sel = e_result_from_alu;</pre>
<pre>        end</pre>
<pre>        begin</pre>
<pre>          decode.pipe_int_v = 1'b1;</pre>
<pre>          decode.irf_w_v    = 1'b1;</pre>
<pre>          decode.fu_op      = e_int_op_pass_src2;</pre>
<pre>          decode.src2_sel   = e_src2_is_imm;</pre>
<pre>          decode.result_sel = e_result_from_alu;</pre>
<pre>        end</pre>
<pre>        begin</pre>
<pre>          decode.pipe_int_v = 1'b1;</pre>
<pre>          decode.irf_w_v    = 1'b1;</pre>
<pre>          decode.fu_op      = e_int_op_add;</pre>
<pre>          decode.src1_sel   = e_src1_is_pc;</pre>
<pre>          decode.src2_sel   = e_src2_is_imm;</pre>
<pre>          decode.result_sel = e_result_from_alu;</pre>
<pre>        end</pre>
<pre>        begin</pre>
<pre>          decode.pipe_int_v = 1'b1;</pre>
<pre>          decode.irf_w_v    = 1'b1;</pre>
<pre>          decode.jmp_v      = 1'b1;</pre>
<pre>          decode.baddr_sel  = e_baddr_is_pc;</pre>
<pre>          decode.result_sel = e_result_from_pc_plus4;</pre>
<pre>        end</pre>
<pre>        begin</pre>
<pre>          decode.pipe_int_v = 1'b1;</pre>
<pre>          decode.irf_w_v    = 1'b1;</pre>
<pre>          decode.jmp_v      = 1'b1;</pre>
<pre>          decode.baddr_sel  = e_baddr_is_rs1;</pre>
<pre>          decode.result_sel = e_result_from_pc_plus4;</pre>
<pre>        end</pre>
<pre>        begin</pre>
<pre>          decode.pipe_int_v = 1'b1;</pre>
<pre>          decode.br_v       = 1'b1;</pre>
<pre>          unique casez (instr)</pre>
<pre>            `RV64_BEQ  : decode.fu_op = e_int_op_eq;</pre>
<pre>            `RV64_BNE  : decode.fu_op = e_int_op_ne;</pre>
<pre>            `RV64_BLT  : decode.fu_op = e_int_op_slt; </pre>
<pre>            `RV64_BGE  : decode.fu_op = e_int_op_sge;</pre>
<pre>            `RV64_BLTU : decode.fu_op = e_int_op_sltu;</pre>
<pre>            `RV64_BGEU : decode.fu_op = e_int_op_sgeu;</pre>
<pre>            default : illegal_instr = 1'b1;</pre>
<pre>          endcase</pre>
<pre>          decode.src2_sel   = e_src2_is_rs2;</pre>
<pre>          decode.baddr_sel  = e_baddr_is_pc;</pre>
<pre>          decode.result_sel = e_result_from_alu;</pre>
<pre>        end</pre>
<pre>        begin</pre>
<pre>          decode.pipe_mem_v = 1'b1;</pre>
<pre>          decode.irf_w_v    = 1'b1;</pre>
<pre>          decode.dcache_r_v = 1'b1;</pre>
<pre>          decode.mem_v      = 1'b1;</pre>
<pre>          unique casez (instr)</pre>
<pre>            `RV64_LB : decode.fu_op = e_lb;</pre>
<pre>            `RV64_LH : decode.fu_op = e_lh;</pre>
<pre>            `RV64_LW : decode.fu_op = e_lw;</pre>
<pre>            `RV64_LBU: decode.fu_op = e_lbu;</pre>
<pre>            `RV64_LHU: decode.fu_op = e_lhu;</pre>
<pre>            `RV64_LWU: decode.fu_op = e_lwu;</pre>
<pre>            `RV64_LD : decode.fu_op = e_ld;</pre>
<pre>            default : illegal_instr = 1'b1;</pre>
<pre>          endcase</pre>
<pre>        begin</pre>
<pre>          decode.pipe_mem_v = 1'b1;</pre>
<pre>          decode.dcache_w_v = 1'b1;</pre>
<pre>          decode.mem_v      = 1'b1;</pre>
<pre>          unique casez (instr)</pre>
<pre>            `RV64_SB : decode.fu_op = e_sb;</pre>
<pre>            `RV64_SH : decode.fu_op = e_sh;</pre>
<pre>            `RV64_SW : decode.fu_op = e_sw;</pre>
<pre>            `RV64_SD : decode.fu_op = e_sd;</pre>
<pre>            default : illegal_instr = 1'b1;</pre>
<pre>          endcase</pre>
<pre>        begin</pre>
<pre>          decode.pipe_comp_v = 1'b1;</pre>
<pre>          unique casez (instr)</pre>
<pre>            `RV64_FENCE   : begin end</pre>
<pre>            default : illegal_instr = 1'b1;</pre>
<pre>          endcase</pre>
<pre>        begin</pre>
<pre>          decode.pipe_mem_v = 1'b1;</pre>
<pre>          decode.csr_v = 1'b1;</pre>
<pre>          unique casez (instr)</pre>
<pre>            `RV64_ECALL      : decode.fu_op = e_ecall;</pre>
<pre>            `RV64_EBREAK     : decode.fu_op = e_ebreak;</pre>
<pre>            `RV64_MRET       : decode.fu_op = e_mret;</pre>
<pre>            `RV64_SRET       : decode.fu_op = e_sret;</pre>
<pre>            `RV64_WFI        : decode.fu_op = e_wfi;</pre>
<pre>            `RV64_SFENCE_VMA : decode.fu_op = e_sfence_vma;</pre>
<pre>            default: </pre>
<pre>              begin</pre>
<pre>                decode.irf_w_v     = 1'b1;</pre>
<pre>                unique casez (instr)</pre>
<pre>                  `RV64_CSRRW  : decode.fu_op = e_csrrw;</pre>
<pre>                  `RV64_CSRRWI : decode.fu_op = e_csrrwi;</pre>
<pre>                  `RV64_CSRRS  : decode.fu_op = e_csrrs;</pre>
<pre>                  `RV64_CSRRSI : decode.fu_op = e_csrrsi;</pre>
<pre>                  `RV64_CSRRC  : decode.fu_op = e_csrrc;</pre>
<pre>                  `RV64_CSRRCI : decode.fu_op = e_csrrci;</pre>
<pre>                  default : illegal_instr = 1'b1;</pre>
<pre>                endcase</pre>
<pre>        begin</pre>
<pre>          decode.pipe_mem_v = 1'b1;</pre>
<pre>          decode.irf_w_v    = 1'b1;</pre>
<pre>          decode.dcache_r_v = 1'b1;</pre>
<pre>          decode.dcache_w_v = 1'b1;</pre>
<pre>          decode.mem_v      = 1'b1;</pre>
<pre>          decode.offset_sel = e_offset_is_zero;</pre>
<pre>          // Note: could do a more efficent decoding here by having atomic be a flag</pre>
<pre>            `RV64_LRW: decode.fu_op = e_lrw;</pre>
<pre>            `RV64_SCW: decode.fu_op = e_scw;</pre>
<pre>            `RV64_LRD: decode.fu_op = e_lrd;</pre>
<pre>            `RV64_SCD: decode.fu_op = e_scd;</pre>
<pre>            default : illegal_instr = 1'b1;</pre>
<pre>          endcase</pre>
<pre>    endcase</pre>
<pre>      begin</pre>
<pre>        decode = '0;</pre>
<pre>        decode.v           = 1'b1;</pre>
<pre>        decode.pipe_mem_v  = 1'b1;</pre>
<pre>        decode.csr_v = (fe_exc_i != e_itlb_miss);</pre>
<pre>        decode.mem_v = (fe_exc_i == e_itlb_miss);</pre>
<pre>        casez (fe_exc_i)</pre>
<pre>          e_illegal_instr     : decode.fu_op = e_op_illegal_instr;</pre>
<pre>          e_instr_misaligned  : decode.fu_op = e_op_instr_misaligned;</pre>
<pre>          e_instr_access_fault: decode.fu_op = e_op_instr_access_fault;</pre>
<pre>          e_itlb_miss         : decode.fu_op = e_itlb_fill;</pre>
<pre>        endcase</pre>
<pre>      begin</pre>
<pre>        decode = '0;</pre>
<pre>        decode.v           = 1'b1;</pre>
<pre>        decode.pipe_mem_v  = 1'b1;</pre>
<pre>        decode.csr_v = 1'b1;</pre>
<pre>        decode.fu_op       = e_op_illegal_instr;</pre>
<pre>      end</pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./bp_be/src/v/bp_be_top.v</h3>
<pre style="background-color: #FF0000;"> *    bp_be_top.v</pre>
<pre style="background-color: #FF0000;"> * </pre>
<pre> */</pre>
<pre></pre>
<pre></pre>
<pre>module bp_be_top</pre>
<pre> import bp_common_pkg::*;</pre>
<pre> import bp_common_aviary_pkg::*;</pre>
<pre> import bp_common_rv64_pkg::*;</pre>
<pre> import bp_cfg_link_pkg::*;</pre>
<pre> #(parameter bp_cfg_e cfg_p = e_bp_inv_cfg</pre>
<pre>   `declare_bp_proc_params(cfg_p)</pre>
<pre>   `declare_bp_fe_be_if_widths(vaddr_width_p</pre>
<pre>                               ,paddr_width_p</pre>
<pre>                               ,asid_width_p</pre>
<pre>                               ,branch_metadata_fwd_width_p</pre>
<pre>                               )</pre>
<pre>   `declare_bp_lce_cce_if_widths(num_cce_p</pre>
<pre>                                 ,num_lce_p</pre>
<pre>                                 ,paddr_width_p</pre>
<pre>                                 ,lce_assoc_p</pre>
<pre>                                 ,dword_width_p</pre>
<pre>                                 ,cce_block_width_p</pre>
<pre>                                 )</pre>
<pre></pre>
<pre>   // Default parameters </pre>
<pre>   , localparam proc_cfg_width_lp          = `bp_proc_cfg_width(num_core_p, num_cce_p, num_lce_p)</pre>
<pre>   , localparam ecode_dec_width_lp         = `bp_be_ecode_dec_width</pre>
<pre>   </pre>
<pre>   // VM parameters</pre>
<pre>   , localparam tlb_entry_width_lp = `bp_pte_entry_leaf_width(paddr_width_p)</pre>
<pre>   )</pre>
<pre>  (input                                     clk_i</pre>
<pre>   , input                                   reset_i</pre>
<pre>   , input                                   freeze_i</pre>
<pre></pre>
<pre>   // Config channel</pre>
<pre style="background-color: #FF0000;">   , input                                   cfg_w_v_i</pre>
<pre>   , input [cfg_addr_width_p-1:0]            cfg_addr_i</pre>
<pre>   , input [cfg_data_width_p-1:0]            cfg_data_i</pre>
<pre></pre>
<pre>   // FE queue interface</pre>
<pre>   , output                                  fe_queue_deq_o</pre>
<pre>   , output                                  fe_queue_roll_o</pre>
<pre> </pre>
<pre>   , input [fe_queue_width_lp-1:0]           fe_queue_i</pre>
<pre>   , input                                   fe_queue_v_i</pre>
<pre>   , output                                  fe_queue_yumi_o</pre>
<pre></pre>
<pre>   // FE cmd interface</pre>
<pre>   , output [fe_cmd_width_lp-1:0]            fe_cmd_o</pre>
<pre>   , output                                  fe_cmd_v_o</pre>
<pre>   , input                                   fe_cmd_ready_i</pre>
<pre></pre>
<pre>   // LCE-CCE interface</pre>
<pre style="background-color: #FF0000;">   , output [lce_cce_req_width_lp-1:0]       lce_req_o</pre>
<pre>   , output                                  lce_req_v_o</pre>
<pre>   , input                                   lce_req_ready_i</pre>
<pre></pre>
<pre>   , output [lce_cce_resp_width_lp-1:0]      lce_resp_o</pre>
<pre>   , output                                  lce_resp_v_o</pre>
<pre>   , input                                   lce_resp_ready_i                                 </pre>
<pre></pre>
<pre>   , input [lce_cmd_width_lp-1:0]            lce_cmd_i</pre>
<pre>   , input                                   lce_cmd_v_i</pre>
<pre>   , output                                  lce_cmd_ready_o</pre>
<pre></pre>
<pre>   , output [lce_cmd_width_lp-1:0]           lce_cmd_o</pre>
<pre>   , output                                  lce_cmd_v_o</pre>
<pre>   , input                                   lce_cmd_ready_i</pre>
<pre></pre>
<pre>   // Processor configuration</pre>
<pre style="background-color: #FF0000;">   , input [proc_cfg_width_lp-1:0]           proc_cfg_i</pre>
<pre></pre>
<pre style="background-color: #FF0000;">   , input                                   timer_int_i</pre>
<pre>   , input                                   software_int_i</pre>
<pre>   , input                                   external_int_i</pre>
<pre>   );</pre>
<pre></pre>
<pre>// Declare parameterized structures</pre>
<pre>`declare_bp_be_mmu_structs(vaddr_width_p, ptag_width_p, lce_sets_p, cce_block_width_p)</pre>
<pre>`declare_bp_common_proc_cfg_s(num_core_p, num_cce_p, num_lce_p)</pre>
<pre>`declare_bp_be_internal_if_structs(vaddr_width_p</pre>
<pre>                                   , paddr_width_p</pre>
<pre>                                   , asid_width_p</pre>
<pre>                                   , branch_metadata_fwd_width_p</pre>
<pre>                                   );</pre>
<pre></pre>
<pre>// Casting</pre>
<pre>bp_proc_cfg_s proc_cfg;</pre>
<pre></pre>
<pre>assign proc_cfg = proc_cfg_i;</pre>
<pre></pre>
<pre>// Top-level interface connections</pre>
<pre>bp_be_issue_pkt_s issue_pkt;</pre>
<pre>logic issue_pkt_v, issue_pkt_rdy;</pre>
<pre></pre>
<pre>bp_be_mmu_cmd_s mmu_cmd;</pre>
<pre>logic mmu_cmd_v, mmu_cmd_rdy;</pre>
<pre></pre>
<pre>bp_be_csr_cmd_s csr_cmd;</pre>
<pre>logic csr_cmd_v, csr_cmd_rdy;</pre>
<pre></pre>
<pre>bp_be_mem_resp_s mem_resp;</pre>
<pre>logic mem_resp_v, mem_resp_rdy;</pre>
<pre></pre>
<pre>logic [tlb_entry_width_lp-1:0]  itlb_fill_entry;</pre>
<pre>logic [vaddr_width_p-1:0]       itlb_fill_vaddr;</pre>
<pre>logic                           itlb_fill_v;</pre>
<pre></pre>
<pre>bp_be_isd_status_s     isd_status;</pre>
<pre>bp_be_calc_status_s    calc_status;</pre>
<pre></pre>
<pre>logic chk_dispatch_v, chk_poison_iss, chk_poison_isd;</pre>
<pre>logic chk_poison_ex1, chk_poison_ex2, chk_roll, chk_instr_dequeue_v;</pre>
<pre></pre>
<pre>logic [vaddr_width_p-1:0] chk_tvec_li;</pre>
<pre>logic [vaddr_width_p-1:0] chk_epc_li;</pre>
<pre>logic [vaddr_width_p-1:0] chk_pc_lo;</pre>
<pre></pre>
<pre>logic chk_trap_v_li, chk_ret_v_li, chk_tlb_fence_li, chk_ifence_li;</pre>
<pre></pre>
<pre>logic credits_full_lo, credits_empty_lo;</pre>
<pre></pre>
<pre>logic                     instret_mem3;</pre>
<pre>logic                     pc_v_mem3;</pre>
<pre>logic [vaddr_width_p-1:0] pc_mem3;</pre>
<pre>logic [instr_width_p-1:0] instr_mem3;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">// Module instantiations</pre>
<pre>bp_be_checker_top </pre>
<pre> #(.cfg_p(cfg_p))</pre>
<pre> be_checker</pre>
<pre>  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre>   ,.freeze_i(freeze_i)</pre>
<pre></pre>
<pre>   ,.cfg_w_v_i(cfg_w_v_i)</pre>
<pre>   ,.cfg_addr_i(cfg_addr_i)</pre>
<pre>   ,.cfg_data_i(cfg_data_i)</pre>
<pre></pre>
<pre>   ,.chk_dispatch_v_o(chk_dispatch_v)</pre>
<pre>   ,.chk_roll_o(chk_roll)</pre>
<pre>   ,.chk_poison_iss_o(chk_poison_iss)</pre>
<pre style="background-color: #FF0000;">   ,.chk_poison_isd_o(chk_poison_isd)</pre>
<pre>   ,.chk_poison_ex1_o(chk_poison_ex1)</pre>
<pre>   ,.chk_poison_ex2_o(chk_poison_ex2)</pre>
<pre></pre>
<pre>   ,.isd_status_i(isd_status)</pre>
<pre>   ,.calc_status_i(calc_status)</pre>
<pre>   ,.mmu_cmd_ready_i(mmu_cmd_rdy)</pre>
<pre>   ,.credits_full_i(credits_full_lo)</pre>
<pre>   ,.credits_empty_i(credits_empty_lo)</pre>
<pre></pre>
<pre>   ,.fe_cmd_o(fe_cmd_o)</pre>
<pre>   ,.fe_cmd_v_o(fe_cmd_v_o)</pre>
<pre>   ,.fe_cmd_ready_i(fe_cmd_ready_i)</pre>
<pre>   ,.fe_queue_roll_o(fe_queue_roll_o)</pre>
<pre>   ,.fe_queue_deq_o(fe_queue_deq_o)</pre>
<pre></pre>
<pre>   ,.fe_queue_v_i(fe_queue_v_i)</pre>
<pre>   ,.fe_queue_yumi_o(fe_queue_yumi_o)</pre>
<pre></pre>
<pre>   ,.issue_pkt_v_o(issue_pkt_v)</pre>
<pre>   ,.issue_pkt_ready_i(issue_pkt_rdy)</pre>
<pre></pre>
<pre>   ,.trap_v_i(chk_trap_v_li)</pre>
<pre>   ,.ret_v_i(chk_ret_v_li)</pre>
<pre>   ,.pc_o(chk_pc_lo)</pre>
<pre>   ,.tvec_i(chk_tvec_li)</pre>
<pre>   ,.tlb_fence_i(chk_tlb_fence_li)</pre>
<pre>   </pre>
<pre>   ,.itlb_fill_entry_i(itlb_fill_entry)</pre>
<pre>   );</pre>
<pre style="background-color: #FF0000;"></pre>
<pre>bp_be_calculator_top </pre>
<pre> #(.cfg_p(cfg_p))</pre>
<pre>  (.clk_i(clk_i)</pre>
<pre></pre>
<pre>   ,.proc_cfg_i(proc_cfg_i)</pre>
<pre></pre>
<pre>   ,.issue_pkt_v_i(issue_pkt_v)</pre>
<pre>   </pre>
<pre>   ,.chk_dispatch_v_i(chk_dispatch_v)</pre>
<pre></pre>
<pre>   ,.chk_roll_i(chk_roll)</pre>
<pre>   ,.chk_poison_iss_i(chk_poison_iss)</pre>
<pre>   ,.chk_poison_ex1_i(chk_poison_ex1)</pre>
<pre>   ,.chk_poison_ex2_i(chk_poison_ex2)</pre>
<pre>   ,.isd_status_o(isd_status)</pre>
<pre>   ,.calc_status_o(calc_status)</pre>
<pre></pre>
<pre>   ,.mmu_cmd_v_o(mmu_cmd_v)</pre>
<pre>   ,.mmu_cmd_ready_i(mmu_cmd_rdy)</pre>
<pre></pre>
<pre>   ,.csr_cmd_v_o(csr_cmd_v)</pre>
<pre>   ,.csr_cmd_ready_i(csr_cmd_rdy)</pre>
<pre></pre>
<pre>   ,.mem_resp_v_i(mem_resp_v)</pre>
<pre>   ,.mem_resp_ready_o(mem_resp_rdy)   </pre>
<pre></pre>
<pre>   ,.instret_mem3_o(instret_mem3)</pre>
<pre>   ,.instr_mem3_o(instr_mem3)</pre>
<pre>   );</pre>
<pre style="background-color: #FF0000;"></pre>
<pre>bp_be_mem_top</pre>
<pre> #(.cfg_p(cfg_p))</pre>
<pre> be_mem</pre>
<pre>    ,.reset_i(reset_i)</pre>
<pre>    ,.freeze_i(freeze_i)</pre>
<pre></pre>
<pre>    ,.cfg_addr_i(cfg_addr_i)</pre>
<pre></pre>
<pre>    ,.chk_poison_ex_i(chk_poison_ex2)</pre>
<pre></pre>
<pre>    ,.mmu_cmd_v_i(mmu_cmd_v)</pre>
<pre>    ,.mmu_cmd_ready_o(mmu_cmd_rdy)</pre>
<pre></pre>
<pre>    ,.csr_cmd_v_i(csr_cmd_v)</pre>
<pre>    ,.csr_cmd_ready_o(csr_cmd_rdy)</pre>
<pre></pre>
<pre>    ,.mem_resp_v_o(mem_resp_v)</pre>
<pre>    ,.mem_resp_ready_i(mem_resp_rdy)</pre>
<pre>    </pre>
<pre>    ,.itlb_fill_vaddr_o(itlb_fill_vaddr)</pre>
<pre>    ,.itlb_fill_entry_o(itlb_fill_entry)</pre>
<pre></pre>
<pre>    ,.lce_req_v_o(lce_req_v_o)</pre>
<pre>    ,.lce_req_ready_i(lce_req_ready_i)</pre>
<pre></pre>
<pre>    ,.lce_resp_v_o(lce_resp_v_o)</pre>
<pre>    ,.lce_resp_ready_i(lce_resp_ready_i)        </pre>
<pre></pre>
<pre>    ,.lce_cmd_i(lce_cmd_i)</pre>
<pre>    ,.lce_cmd_v_i(lce_cmd_v_i)</pre>
<pre>    ,.lce_cmd_ready_o(lce_cmd_ready_o)</pre>
<pre></pre>
<pre>    ,.lce_cmd_v_o(lce_cmd_v_o)</pre>
<pre>    ,.lce_cmd_ready_i(lce_cmd_ready_i)</pre>
<pre>    ,.proc_cfg_i(proc_cfg_i)</pre>
<pre>    ,.instret_i(instret_mem3)</pre>
<pre></pre>
<pre>    ,.pc_v_mem3_i(pc_v_mem3)</pre>
<pre>    ,.pc_mem3_i(pc_mem3)</pre>
<pre>    ,.instr_mem3_i(instr_mem3)</pre>
<pre>    ,.credits_full_o(credits_full_lo)</pre>
<pre>    ,.credits_empty_o(credits_empty_lo)</pre>
<pre></pre>
<pre>    ,.timer_int_i(timer_int_i)</pre>
<pre>    ,.interrupt_pc_i(chk_pc_lo)</pre>
<pre></pre>
<pre>    // Should connect priv mode to checker for shadow privilege mode</pre>
<pre>    ,.priv_mode_o()</pre>
<pre>    ,.trap_v_o(chk_trap_v_li)</pre>
<pre>    ,.ret_v_o(chk_ret_v_li)</pre>
<pre>    ,.tlb_fence_o(chk_tlb_fence_li)</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./bp_common/src/v/bp_tlb_replacement.v</h3>
<pre>module bp_tlb_replacement</pre>
<pre>    ,localparam lg_ways_lp=`BSG_SAFE_CLOG2(ways_p)</pre>
<pre>  )</pre>
<pre>   , input                          reset_i</pre>
<pre>   , input                          v_i</pre>
<pre>   , input [lg_ways_lp-1:0]         way_i</pre>
<pre>   , output logic [lg_ways_lp-1:0]  way_o</pre>
<pre>  );</pre>
<pre></pre>
<pre>  assign lru_n[i] = (update_mask[i]) ? update_data[i] : lru_r[i];</pre>
<pre>end</pre>
<pre>  begin</pre>
<pre>    if (reset_i) </pre>
<pre>      lru_r <= '0;</pre>
<pre>    else if (v_i) begin</pre>
<pre>      lru_r <= lru_n;</pre>
<pre>    end</pre>
<pre>  decoder </pre>
<pre style="background-color: #FF0000;">  (.way_id_i(way_i)</pre>
<pre>   ,.data_o(update_data)</pre>
<pre>   ,.mask_o(update_mask)</pre>
<pre>  );</pre>
<pre>  encoder </pre>
<pre style="background-color: #FF0000;">  (.lru_i(lru_r)</pre>
<pre>   ,.way_id_o(way_o)</pre>
<pre>  );  </pre>
<h3>./bp_be/src/v/bp_be_calculator/bp_be_bypass.v</h3>
<pre>module bp_be_bypass</pre>
<pre> #(parameter fwd_els_p = "inv"</pre>
<pre>   , parameter enable_p = 1</pre>
<pre>   , localparam bypass_els_lp     = fwd_els_p + 1</pre>
<pre>   , localparam reg_addr_width_lp = rv64_reg_addr_width_gp</pre>
<pre>   , localparam reg_data_width_lp = rv64_reg_data_width_gp</pre>
<pre>   input [reg_addr_width_lp-1:0]                  id_rs1_addr_i</pre>
<pre>   , input [reg_data_width_lp-1:0]                id_rs1_i</pre>
<pre>   , input [reg_addr_width_lp-1:0]                id_rs2_addr_i</pre>
<pre>   , input [reg_data_width_lp-1:0]                id_rs2_i</pre>
<pre>   , input [fwd_els_p-1:0]                        fwd_rd_v_i</pre>
<pre>   , input [fwd_els_p-1:0][reg_addr_width_lp-1:0] fwd_rd_addr_i</pre>
<pre>   , input [fwd_els_p-1:0][reg_data_width_lp-1:0] fwd_rd_i</pre>
<pre>   , output [reg_data_width_lp-1:0]               bypass_rs1_o</pre>
<pre>   , output [reg_data_width_lp-1:0]               bypass_rs2_o</pre>
<pre>initial begin : parameter_validation</pre>
<pre>  assert (fwd_els_p > 0 && fwd_els_p != "inv") </pre>
<pre>    else $error("fwd_els_p must be positive, else there is nothing to bypass. \</pre>
<pre>  assert (enable_p == 1)</pre>
<pre>    else $warning("Bypassing disabled.");</pre>
<pre>logic [bypass_els_lp-1:0]                        rs1_match_vector       , rs2_match_vector;</pre>
<pre>logic [bypass_els_lp-1:0]                        rs1_match_vector_onehot, rs2_match_vector_onehot;</pre>
<pre>logic [bypass_els_lp-1:0][reg_data_width_lp-1:0] rs1_data_vector        , rs2_data_vector;</pre>
<pre>if (enable_p == 1) </pre>
<pre>  begin : bypass</pre>
<pre>    bsg_priority_encode_one_hot_out </pre>
<pre>     #(.width_p(bypass_els_lp)</pre>
<pre>       ,.lo_to_hi_p(1)</pre>
<pre style="background-color: #FF0000;">     match_one_hot_rs1</pre>
<pre>      (.i(rs1_match_vector)</pre>
<pre>       ,.o(rs1_match_vector_onehot)</pre>
<pre>    bsg_priority_encode_one_hot_out </pre>
<pre>     #(.width_p(bypass_els_lp)</pre>
<pre>       ,.lo_to_hi_p(1)</pre>
<pre style="background-color: #FF0000;">     match_one_hot_rs2</pre>
<pre>      (.i(rs2_match_vector)</pre>
<pre>       ,.o(rs2_match_vector_onehot)</pre>
<pre>    bsg_crossbar_o_by_i </pre>
<pre>     #(.i_els_p(bypass_els_lp)</pre>
<pre>       ,.o_els_p(1)</pre>
<pre>       ,.width_p(reg_data_width_lp)</pre>
<pre style="background-color: #FF0000;">     rs1_crossbar</pre>
<pre>      (.i(rs1_data_vector)</pre>
<pre>       ,.sel_oi_one_hot_i(rs1_match_vector_onehot)</pre>
<pre>       ,.o(bypass_rs1_o)</pre>
<pre>    bsg_crossbar_o_by_i </pre>
<pre>     #(.i_els_p(bypass_els_lp)</pre>
<pre>       ,.o_els_p(1)</pre>
<pre>       ,.width_p(reg_data_width_lp)</pre>
<pre style="background-color: #FF0000;">     rs2_crossbar</pre>
<pre>      (.i(rs2_data_vector)</pre>
<pre>       ,.sel_oi_one_hot_i(rs2_match_vector_onehot)</pre>
<pre>       ,.o(bypass_rs2_o)</pre>
<pre style="background-color: #FF0000;">  begin : passthrough</pre>
<pre style="background-color: #FF0000;">    assign bypass_rs1_o = id_rs1_i;</pre>
<pre style="background-color: #FF0000;">    assign bypass_rs2_o = id_rs2_i;</pre>
<pre>always_comb </pre>
<pre>  begin : vector_generation</pre>
<pre>    rs1_data_vector = {id_rs1_i, fwd_rd_i};</pre>
<pre>    rs2_data_vector = {id_rs2_i, fwd_rd_i};</pre>
<pre>    for (integer i = 0; i < bypass_els_lp; i++) </pre>
<pre>      begin : match_vector</pre>
<pre>        rs1_match_vector[i] = ((i == bypass_els_lp-1)</pre>
<pre>                               || ((id_rs1_addr_i == fwd_rd_addr_i[i])</pre>
<pre>                                   & fwd_rd_v_i[i]</pre>
<pre>                                   & (id_rs1_addr_i != reg_addr_width_lp'(0))</pre>
<pre>        rs2_match_vector[i] = ((i == bypass_els_lp-1)</pre>
<pre>                               || ((id_rs2_addr_i == fwd_rd_addr_i[i]) </pre>
<pre>                                   & fwd_rd_v_i[i]</pre>
<pre>                                   & (id_rs2_addr_i != reg_addr_width_lp'(0))</pre>
<pre style="background-color: #FF0000;">endmodule : bp_be_bypass</pre>
<h3>./bp_be/src/v/bp_be_calculator/bp_be_calculator_top.v</h3>
<pre> *   bp_be_calculator_top.v</pre>
<pre style="background-color: #FF0000;"> * </pre>
<pre> * Description:</pre>
<pre> *</pre>
<pre> * Notes:</pre>
<pre> *   Should subdivide this module into a few helper modules to reduce complexity. Perhaps</pre>
<pre> *     issuer, exe_pipe, completion_pipe, status_gen?</pre>
<pre> *   Exception aggregation could be simplified with constants and more thought. Should fix</pre>
<pre> *     once code is more stable, fixing in cleanup could cause regressions</pre>
<pre></pre>
<pre>module bp_be_calculator_top </pre>
<pre> import bp_common_pkg::*;</pre>
<pre> import bp_common_aviary_pkg::*;</pre>
<pre> import bp_common_rv64_pkg::*;</pre>
<pre> import bp_be_pkg::*;</pre>
<pre> #(parameter bp_cfg_e cfg_p = e_bp_inv_cfg</pre>
<pre>    `declare_bp_proc_params(cfg_p)</pre>
<pre>    `declare_bp_fe_be_if_widths(vaddr_width_p, paddr_width_p, asid_width_p, branch_metadata_fwd_width_p)</pre>
<pre>    `declare_bp_lce_cce_if_widths(num_cce_p, num_lce_p, paddr_width_p, lce_assoc_p, dword_width_p, cce_block_width_p)</pre>
<pre></pre>
<pre>   // Default parameters</pre>
<pre>   , parameter fp_en_p                  = 0</pre>
<pre></pre>
<pre>   // Generated parameters</pre>
<pre>   , localparam proc_cfg_width_lp       = `bp_proc_cfg_width(num_core_p, num_cce_p, num_lce_p)</pre>
<pre>   , localparam issue_pkt_width_lp      = `bp_be_issue_pkt_width(vaddr_width_p, branch_metadata_fwd_width_p)</pre>
<pre>   , localparam isd_status_width_lp     = `bp_be_isd_status_width</pre>
<pre>   , localparam calc_status_width_lp    = `bp_be_calc_status_width(vaddr_width_p, branch_metadata_fwd_width_p)</pre>
<pre>   , localparam exception_width_lp      = `bp_be_exception_width</pre>
<pre>   , localparam mmu_cmd_width_lp        = `bp_be_mmu_cmd_width(vaddr_width_p)</pre>
<pre>   , localparam csr_cmd_width_lp        = `bp_be_csr_cmd_width</pre>
<pre>   , localparam mem_resp_width_lp       = `bp_be_mem_resp_width(vaddr_width_p)</pre>
<pre>   , localparam dispatch_pkt_width_lp   = `bp_be_dispatch_pkt_width(vaddr_width_p, branch_metadata_fwd_width_p)</pre>
<pre></pre>
<pre>   // From BP BE specifications</pre>
<pre>   , localparam pipe_stage_els_lp = 5 </pre>
<pre>   , localparam ecode_dec_width_lp = `bp_be_ecode_dec_width</pre>
<pre></pre>
<pre>   // From RISC-V specifications</pre>
<pre></pre>
<pre>   // Local constants</pre>
<pre>   , localparam dispatch_point_lp   = 0</pre>
<pre>   , localparam int_commit_point_lp = 3</pre>
<pre>   , localparam fp_commit_point_lp  = 4</pre>
<pre></pre>
<pre>   , localparam int_comp_idx_lp = 0</pre>
<pre>   , localparam mul_comp_idx_lp = 1</pre>
<pre>   , localparam mem_comp_idx_lp = 2</pre>
<pre>   , localparam fp_comp_idx_lp  = 3</pre>
<pre>   )</pre>
<pre> (input                                  clk_i</pre>
<pre>  , input                                reset_i</pre>
<pre>   </pre>
<pre>  // Slow inputs   </pre>
<pre style="background-color: #FF0000;">  , input [proc_cfg_width_lp-1:0]        proc_cfg_i</pre>
<pre>   </pre>
<pre>  // Calculator - Checker interface   </pre>
<pre>  , input [issue_pkt_width_lp-1:0]       issue_pkt_i</pre>
<pre>  , input                                issue_pkt_v_i</pre>
<pre>  , output                               issue_pkt_ready_o</pre>
<pre>   </pre>
<pre>  , input                                chk_dispatch_v_i</pre>
<pre>  , input                                chk_roll_i</pre>
<pre>  , input                                chk_poison_iss_i</pre>
<pre>  , input                                chk_poison_isd_i</pre>
<pre>  , input                                chk_poison_ex1_i</pre>
<pre>  , input                                chk_poison_ex2_i</pre>
<pre>   </pre>
<pre style="background-color: #FF0000;">  , output [isd_status_width_lp-1:0]     isd_status_o</pre>
<pre>  , output [calc_status_width_lp-1:0]    calc_status_o</pre>
<pre>   </pre>
<pre>  // Mem interface   </pre>
<pre>  , output [mmu_cmd_width_lp-1:0]        mmu_cmd_o</pre>
<pre>  , output                               mmu_cmd_v_o</pre>
<pre>  , input                                mmu_cmd_ready_i</pre>
<pre>   </pre>
<pre>  , output [csr_cmd_width_lp-1:0]        csr_cmd_o</pre>
<pre>  , output                               csr_cmd_v_o</pre>
<pre>  , input                                csr_cmd_ready_i</pre>
<pre></pre>
<pre>  , input                                mem_resp_v_i</pre>
<pre>  , output                               mem_resp_ready_o</pre>
<pre></pre>
<pre>  // CSRs</pre>
<pre>  , output                               instret_mem3_o</pre>
<pre>  , output [vaddr_width_p-1:0]           pc_mem3_o</pre>
<pre>  , output [instr_width_p-1:0]          instr_mem3_o</pre>
<pre>  , output                               pc_v_mem3_o</pre>
<pre>  );</pre>
<pre></pre>
<pre>// Declare parameterizable structs</pre>
<pre style="background-color: #FF0000;">`declare_bp_be_mmu_structs(vaddr_width_p, ppn_width_p, lce_sets_p, cce_block_width_p / 8)</pre>
<pre>`declare_bp_common_proc_cfg_s(num_core_p, num_cce_p, num_lce_p)</pre>
<pre>`declare_bp_be_internal_if_structs(vaddr_width_p, paddr_width_p, asid_width_p, branch_metadata_fwd_width_p);</pre>
<pre></pre>
<pre>// Cast input and output ports </pre>
<pre>bp_be_issue_pkt_s   issue_pkt;</pre>
<pre>bp_be_isd_status_s  isd_status;</pre>
<pre>bp_be_calc_status_s calc_status;</pre>
<pre>bp_be_mem_resp_s    mem_resp;</pre>
<pre>bp_proc_cfg_s       proc_cfg;</pre>
<pre></pre>
<pre>assign issue_pkt = issue_pkt_i;</pre>
<pre>assign mem_resp = mem_resp_i;</pre>
<pre>assign proc_cfg = proc_cfg_i;</pre>
<pre>assign calc_status_o = calc_status;</pre>
<pre>assign isd_status_o = isd_status;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">// Declare intermediate signals</pre>
<pre>logic                   chk_poison_iss_r;</pre>
<pre>bp_be_issue_pkt_s       issue_pkt_r;</pre>
<pre>logic                   issue_pkt_v_r;</pre>
<pre>bp_be_dispatch_pkt_s    dispatch_pkt, dispatch_pkt_r;</pre>
<pre>logic                   dispatch_pkt_v_r;</pre>
<pre>bp_be_decode_s          decoded;</pre>
<pre></pre>
<pre>// Register bypass network</pre>
<pre>logic [dword_width_p-1:0] irf_rs1    , irf_rs2;</pre>
<pre>logic [dword_width_p-1:0] frf_rs1    , frf_rs2;</pre>
<pre>logic [dword_width_p-1:0] bypass_irs1, bypass_irs2;</pre>
<pre>logic [dword_width_p-1:0] bypass_frs1, bypass_frs2;</pre>
<pre>logic [dword_width_p-1:0] bypass_rs1 , bypass_rs2;</pre>
<pre></pre>
<pre>// Exception signals</pre>
<pre>logic load_misaligned_mem1, store_misaligned_mem3;</pre>
<pre></pre>
<pre>bp_be_pipe_stage_reg_s [pipe_stage_els_lp-1:0] calc_stage_r;</pre>
<pre>bp_be_pipe_stage_reg_s                         calc_stage_isd;</pre>
<pre>bp_be_exception_s      [pipe_stage_els_lp-1:0] exc_stage_r;</pre>
<pre>bp_be_exception_s      [pipe_stage_els_lp  :0] exc_stage_n;</pre>
<pre></pre>
<pre>logic [pipe_stage_els_lp-1:0][dword_width_p-1:0] comp_stage_r, comp_stage_n;</pre>
<pre></pre>
<pre>logic [dword_width_p-1:0] pipe_nop_data_lo;</pre>
<pre>logic [dword_width_p-1:0] pipe_int_data_lo, pipe_mul_data_lo, pipe_mem_data_lo, pipe_fp_data_lo;</pre>
<pre></pre>
<pre>logic nop_pipe_result_v;</pre>
<pre>logic pipe_int_data_lo_v, pipe_mul_data_lo_v, pipe_mem_data_lo_v, pipe_fp_data_lo_v;</pre>
<pre>logic pipe_mem_exc_v_lo, pipe_mem_miss_v_lo;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">logic [vaddr_width_p-1:0] br_tgt_int1;</pre>
<pre></pre>
<pre>// Forwarding information</pre>
<pre>logic [pipe_stage_els_lp-1:1]                        comp_stage_n_slice_iwb_v;</pre>
<pre>logic [pipe_stage_els_lp-1:1]                        comp_stage_n_slice_fwb_v;</pre>
<pre>logic [pipe_stage_els_lp-1:1][reg_addr_width_lp-1:0] comp_stage_n_slice_rd_addr;</pre>
<pre>logic [pipe_stage_els_lp-1:1][dword_width_p-1:0] comp_stage_n_slice_rd;</pre>
<pre></pre>
<pre>// Handshakes</pre>
<pre style="background-color: #FF0000;">assign issue_pkt_ready_o = (chk_dispatch_v_i | ~issue_pkt_v_r);</pre>
<pre></pre>
<pre>#(.cfg_p(cfg_p))</pre>
<pre> int_regfile</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>   ,.issue_v_i(issue_pkt_v_i)</pre>
<pre>   ,.dispatch_v_i(chk_dispatch_v_i)</pre>
<pre></pre>
<pre>   ,.rd_addr_i(calc_stage_r[int_commit_point_lp].instr.fields.rtype.rd_addr)</pre>
<pre>   ,.rd_data_i(comp_stage_r[int_commit_point_lp])</pre>
<pre></pre>
<pre>   ,.rs1_addr_i(issue_pkt.instr.fields.rtype.rs1_addr)</pre>
<pre>   ,.rs1_data_o(irf_rs1)</pre>
<pre></pre>
<pre>   ,.rs2_addr_i(issue_pkt.instr.fields.rtype.rs2_addr)</pre>
<pre>   ,.rs2_data_o(irf_rs2)</pre>
<pre>   );</pre>
<pre style="background-color: #FF0000;"></pre>
<pre>if (fp_en_p)</pre>
<pre>  begin : fp_rf</pre>
<pre style="background-color: #FF0000;">    bp_be_regfile</pre>
<pre style="background-color: #FF0000;">    #(.cfg_p(cfg_p))</pre>
<pre>     float_regfile</pre>
<pre style="background-color: #FF0000;">      (.clk_i(clk_i)</pre>
<pre style="background-color: #FF0000;">       ,.reset_i(reset_i)</pre>
<pre style="background-color: #FF0000;">    </pre>
<pre style="background-color: #FF0000;">       ,.dispatch_v_i(chk_dispatch_v_i)</pre>
<pre style="background-color: #FF0000;">    </pre>
<pre style="background-color: #FF0000;">       ,.rd_addr_i(calc_stage_r[fp_commit_point_lp].rd_addr)</pre>
<pre style="background-color: #FF0000;">       ,.rd_data_i(comp_stage_r[fp_commit_point_lp])</pre>
<pre style="background-color: #FF0000;">    </pre>
<pre style="background-color: #FF0000;">       ,.rs1_addr_i(issue_pkt.instr.fields.rtype.rs1_addr)</pre>
<pre style="background-color: #FF0000;">       ,.rs1_data_o(frf_rs1)</pre>
<pre style="background-color: #FF0000;">    </pre>
<pre style="background-color: #FF0000;">       ,.rs2_addr_i(issue_pkt.instr.fields.rtype.rs2_addr)</pre>
<pre style="background-color: #FF0000;">       ,.rs2_data_o(frf_rs2)</pre>
<pre style="background-color: #FF0000;">       );</pre>
<pre style="background-color: #FF0000;">     // Don't need to forward isd data</pre>
<pre style="background-color: #FF0000;">     fp_bypass</pre>
<pre style="background-color: #FF0000;">      (.id_rs1_addr_i(issue_pkt_r.instr.fields.rtype.rs1_addr)</pre>
<pre style="background-color: #FF0000;">       ,.id_rs1_i(frf_rs1)</pre>
<pre style="background-color: #FF0000;">    </pre>
<pre style="background-color: #FF0000;">       ,.id_rs2_i(frf_rs2)</pre>
<pre>    </pre>
<pre style="background-color: #FF0000;">       ,.fwd_rd_addr_i(comp_stage_n_slice_rd_addr)</pre>
<pre style="background-color: #FF0000;">       ,.fwd_rd_i(comp_stage_n_slice_rd)</pre>
<pre style="background-color: #FF0000;">    </pre>
<pre style="background-color: #FF0000;">       ,.bypass_rs2_o(bypass_frs2)</pre>
<pre style="background-color: #FF0000;">       );</pre>
<pre style="background-color: #FF0000;">     #(.width_p(dword_width_p)</pre>
<pre style="background-color: #FF0000;">       ,.els_p(2)</pre>
<pre style="background-color: #FF0000;">       ) </pre>
<pre style="background-color: #FF0000;">      (.data_i({bypass_frs1, bypass_irs1})</pre>
<pre style="background-color: #FF0000;">       ,.sel_i(issue_pkt_r.frs1_v)</pre>
<pre style="background-color: #FF0000;">       ,.data_o(bypass_rs1)</pre>
<pre style="background-color: #FF0000;">       );</pre>
<pre style="background-color: #FF0000;">     #(.width_p(dword_width_p)</pre>
<pre style="background-color: #FF0000;">       ,.els_p(2)</pre>
<pre style="background-color: #FF0000;">       ) </pre>
<pre style="background-color: #FF0000;">      (.data_i({bypass_frs2, bypass_irs2})</pre>
<pre style="background-color: #FF0000;">       ,.sel_i(issue_pkt_r.frs2_v)</pre>
<pre style="background-color: #FF0000;">       ,.data_o(bypass_rs2)</pre>
<pre style="background-color: #FF0000;">       );</pre>
<pre>    assign frf_rs1 = '0;</pre>
<pre>    assign frf_rs2 = '0;</pre>
<pre></pre>
<pre>    assign bypass_frs2 = '0;</pre>
<pre></pre>
<pre>    assign bypass_rs2 = bypass_irs2;</pre>
<pre>  end</pre>
<pre> #(.width_p(1+issue_pkt_width_lp))</pre>
<pre> issue_reg</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i | chk_roll_i)</pre>
<pre>   ,.en_i(issue_pkt_v_i | chk_dispatch_v_i)</pre>
<pre></pre>
<pre>   ,.data_o({issue_pkt_v_r, issue_pkt_r})</pre>
<pre>   );</pre>
<pre> #(.width_p(1))</pre>
<pre> issue_psn_reg</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre>   ,.en_i(issue_pkt_v_i | chk_dispatch_v_i | chk_poison_iss_i)</pre>
<pre></pre>
<pre>   ,.data_o(chk_poison_iss_r)</pre>
<pre>   );</pre>
<pre>bp_fe_exception_code_e fe_exc_isd;</pre>
<pre>// Decode the dispatched instruction</pre>
<pre> instr_decoder</pre>
<pre style="background-color: #FF0000;">  (.instr_v_i(issue_pkt_v_r)</pre>
<pre>   ,.instr_i(issue_pkt_r.instr)</pre>
<pre>   ,.fe_exc_not_instr_i(issue_pkt_r.fe_exception_not_instr)</pre>
<pre>   ,.fe_exc_i(issue_pkt_r.fe_exception_code)</pre>
<pre></pre>
<pre>   );</pre>
<pre> // Don't need to forward isd data</pre>
<pre> int_bypass </pre>
<pre style="background-color: #FF0000;">  (.id_rs1_addr_i(issue_pkt_r.instr.fields.rtype.rs1_addr)</pre>
<pre>   ,.id_rs1_i(irf_rs1)</pre>
<pre></pre>
<pre>   ,.id_rs2_i(irf_rs2)</pre>
<pre></pre>
<pre style="background-color: #FF0000;">   ,.fwd_rd_v_i(comp_stage_n_slice_iwb_v)</pre>
<pre>   ,.fwd_rd_addr_i(comp_stage_n_slice_rd_addr)</pre>
<pre>   ,.fwd_rd_i(comp_stage_n_slice_rd)</pre>
<pre></pre>
<pre style="background-color: #FF0000;">   ,.bypass_rs1_o(bypass_irs1)</pre>
<pre>   ,.bypass_rs2_o(bypass_irs2)</pre>
<pre>   );</pre>
<pre> #(.vaddr_width_p(vaddr_width_p))</pre>
<pre> pipe_int</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre> </pre>
<pre style="background-color: #FF0000;">   ,.kill_ex1_i(exc_stage_n[1].poison_v)</pre>
<pre></pre>
<pre>   ,.pc_i(dispatch_pkt_r.pc)</pre>
<pre>   ,.rs1_i(dispatch_pkt_r.rs1)</pre>
<pre>   ,.rs2_i(dispatch_pkt_r.rs2)</pre>
<pre>   ,.imm_i(dispatch_pkt_r.imm)</pre>
<pre></pre>
<pre>   </pre>
<pre>   );</pre>
<pre> pipe_mul</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre></pre>
<pre style="background-color: #FF0000;">   ,.kill_ex1_i(exc_stage_n[1].poison_v)</pre>
<pre>   ,.kill_ex2_i(exc_stage_n[2].poison_v)</pre>
<pre></pre>
<pre>   ,.rs1_i(dispatch_pkt_r.rs1)</pre>
<pre>   ,.rs2_i(dispatch_pkt_r.rs2)</pre>
<pre></pre>
<pre>   );</pre>
<pre> #(.cfg_p(cfg_p))</pre>
<pre> pipe_mem</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>   ,.kill_ex2_i(exc_stage_n[2].poison_v)</pre>
<pre>   ,.kill_ex3_i(exc_stage_r[2].poison_v) </pre>
<pre></pre>
<pre>   ,.pc_i(dispatch_pkt_r.pc)</pre>
<pre>   ,.instr_i(dispatch_pkt_r.instr)</pre>
<pre>   ,.rs1_i(dispatch_pkt_r.rs1)</pre>
<pre>   ,.rs2_i(dispatch_pkt_r.rs2)</pre>
<pre>   ,.imm_i(dispatch_pkt_r.imm)</pre>
<pre></pre>
<pre>   ,.mmu_cmd_v_o(mmu_cmd_v_o)</pre>
<pre>   ,.mmu_cmd_ready_i(mmu_cmd_ready_i)</pre>
<pre></pre>
<pre>   ,.csr_cmd_v_o(csr_cmd_v_o)</pre>
<pre>   ,.csr_cmd_ready_i(csr_cmd_ready_i)</pre>
<pre></pre>
<pre>   ,.mem_resp_v_i(mem_resp_v_i)</pre>
<pre>   ,.mem_resp_ready_o(mem_resp_ready_o)</pre>
<pre></pre>
<pre>   ,.miss_v_o(pipe_mem_miss_v_lo)</pre>
<pre>   ,.data_o(pipe_mem_data_lo)</pre>
<pre>   );</pre>
<pre>   pipe_fp</pre>
<pre style="background-color: #FF0000;">    (.clk_i(clk_i)</pre>
<pre>     ,.reset_i(reset_i)</pre>
<pre>  </pre>
<pre>     ,.kill_ex2_i(exc_stage_n[2].poison_v)</pre>
<pre>     ,.kill_ex3_i(exc_stage_n[3].poison_v) </pre>
<pre>     ,.kill_ex4_i(exc_stage_n[4].poison_v) </pre>
<pre>  </pre>
<pre>     ,.rs1_i(dispatch_pkt_r.rs1)</pre>
<pre>     ,.rs2_i(dispatch_pkt_r.rs2)</pre>
<pre>  </pre>
<pre>     );</pre>
<pre> #(.width_p(pipe_stage_reg_width_lp*pipe_stage_els_lp))</pre>
<pre> calc_stage_reg</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.data_i({calc_stage_r[0+:pipe_stage_els_lp-1], calc_stage_isd})</pre>
<pre>   ,.data_o(calc_stage_r)</pre>
<pre>   );</pre>
<pre> #(.width_p(1+dispatch_pkt_width_lp))</pre>
<pre> dispatch_pkt_reg</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.data_i({(issue_pkt_v_r & chk_dispatch_v_i), dispatch_pkt})</pre>
<pre>   ,.data_o({dispatch_pkt_v_r, dispatch_pkt_r})</pre>
<pre>   );</pre>
<pre>assign pipe_mem_data_lo_v = calc_stage_r[2].pipe_mem_v;</pre>
<pre>assign pipe_mul_data_lo_v = calc_stage_r[1].pipe_mul_v;</pre>
<pre>assign pipe_int_data_lo_v = calc_stage_r[0].pipe_int_v;</pre>
<pre></pre>
<pre></pre>
<pre>logic [pipe_stage_els_lp-1:0]                        comp_stage_mux_sel_li;</pre>
<pre></pre>
<pre>assign comp_stage_mux_sel_li = {pipe_fp_data_lo_v, pipe_mem_data_lo_v, pipe_mul_data_lo_v, pipe_int_data_lo_v, 1'b1};</pre>
<pre>bsg_mux_segmented </pre>
<pre> #(.segments_p(pipe_stage_els_lp)</pre>
<pre>   ,.segment_width_p(dword_width_p)</pre>
<pre>   ) </pre>
<pre style="background-color: #FF0000;">  (.data0_i({comp_stage_r[0+:pipe_stage_els_lp-1], dword_width_p'(0)})</pre>
<pre>   ,.data1_i(comp_stage_mux_li)</pre>
<pre>   ,.sel_i(comp_stage_mux_sel_li)</pre>
<pre>   ,.data_o(comp_stage_n)</pre>
<pre>   );</pre>
<pre> #(.width_p(dword_width_p*pipe_stage_els_lp)</pre>
<pre>   ) </pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.data_i(comp_stage_n)</pre>
<pre>   ,.data_o(comp_stage_r)</pre>
<pre>   );</pre>
<pre> #(.width_p(exception_width_lp*pipe_stage_els_lp)</pre>
<pre>   ) </pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.data_i(exc_stage_n[0+:pipe_stage_els_lp])</pre>
<pre>   ,.data_o(exc_stage_r)</pre>
<pre>   );</pre>
<pre>wire be_nop_v = ~chk_dispatch_v_i &  mmu_cmd_ready_i;</pre>
<pre>wire me_nop_v = ~chk_dispatch_v_i & ~mmu_cmd_ready_i;</pre>
<pre></pre>
<pre>  begin</pre>
<pre>    // Form dispatch packet</pre>
<pre>    dispatch_pkt.branch_metadata_fwd = issue_pkt_r.branch_metadata_fwd;</pre>
<pre>    dispatch_pkt.instr               = issue_pkt_r.instr;</pre>
<pre>    dispatch_pkt.rs1                 = bypass_rs1;</pre>
<pre>    dispatch_pkt.rs2                 = bypass_rs2;</pre>
<pre>    dispatch_pkt.imm                 = issue_pkt_r.imm;</pre>
<pre></pre>
<pre>      else if (be_nop_v) dispatch_pkt = '0;</pre>
<pre>      else if (me_nop_v) dispatch_pkt = '0;</pre>
<pre>      else               dispatch_pkt.decode = decoded;</pre>
<pre></pre>
<pre>    calc_stage_isd.instr          = dispatch_pkt.instr;</pre>
<pre>    calc_stage_isd.v              = dispatch_pkt.decode.v;</pre>
<pre>    calc_stage_isd.instr_v        = dispatch_pkt.decode.instr_v;</pre>
<pre>    calc_stage_isd.pipe_int_v     = dispatch_pkt.decode.pipe_int_v;</pre>
<pre>    calc_stage_isd.pipe_mul_v     = dispatch_pkt.decode.pipe_mul_v;</pre>
<pre>    calc_stage_isd.pipe_mem_v     = dispatch_pkt.decode.pipe_mem_v;</pre>
<pre>    calc_stage_isd.pipe_fp_v      = dispatch_pkt.decode.pipe_fp_v;</pre>
<pre>    calc_stage_isd.mem_v          = dispatch_pkt.decode.mem_v;</pre>
<pre>    calc_stage_isd.csr_v          = dispatch_pkt.decode.csr_v;</pre>
<pre>    calc_stage_isd.irf_w_v        = dispatch_pkt.decode.irf_w_v;</pre>
<pre>    calc_stage_isd.frf_w_v        = dispatch_pkt.decode.frf_w_v;</pre>
<pre></pre>
<pre>    isd_status.isd_mem_v    = issue_pkt_v_r & issue_pkt_r.mem_v;</pre>
<pre>    isd_status.isd_irs1_v   = issue_pkt_v_r & issue_pkt_r.irs1_v;</pre>
<pre>    isd_status.isd_frs1_v   = issue_pkt_v_r & issue_pkt_r.frs1_v;</pre>
<pre>    isd_status.isd_rs1_addr = issue_pkt_r.instr.fields.rtype.rs1_addr;</pre>
<pre>    isd_status.isd_irs2_v   = issue_pkt_v_r & issue_pkt_r.irs2_v;</pre>
<pre>    isd_status.isd_frs2_v   = issue_pkt_v_r & issue_pkt_r.frs2_v;</pre>
<pre>    isd_status.isd_rs2_addr = issue_pkt_r.instr.fields.rtype.rs2_addr;</pre>
<pre></pre>
<pre>    calc_status.int1_br_tgt              = br_tgt_int1;</pre>
<pre>    calc_status.int1_branch_metadata_fwd = dispatch_pkt_r.branch_metadata_fwd;</pre>
<pre>    calc_status.int1_btaken              = (dispatch_pkt_r.decode.br_v & pipe_int_data_lo[0])</pre>
<pre>                                           | dispatch_pkt_r.decode.jmp_v;</pre>
<pre>    calc_status.int1_br_or_jmp           = dispatch_pkt_r.decode.br_v </pre>
<pre>                                           | dispatch_pkt_r.decode.jmp_v;</pre>
<pre>    calc_status.ex1_v                    = dispatch_pkt_r.decode.v & ~exc_stage_r[0].poison_v;</pre>
<pre>    calc_status.ex1_pc                   = dispatch_pkt_r.pc;</pre>
<pre>    calc_status.ex1_instr_v              = dispatch_pkt_r.decode.instr_v & ~exc_stage_r[0].poison_v;</pre>
<pre>    calc_status.mem1_fencei_v            = dispatch_pkt_r.decode.fencei_v;</pre>
<pre></pre>
<pre>      begin : dep_status</pre>
<pre>        calc_status.dep_status[i].int_iwb_v = calc_stage_r[i].pipe_int_v </pre>
<pre>                                              & ~exc_stage_n[i+1].poison_v</pre>
<pre>                                              & calc_stage_r[i].irf_w_v;</pre>
<pre>        calc_status.dep_status[i].mul_iwb_v = calc_stage_r[i].pipe_mul_v </pre>
<pre>                                              & ~exc_stage_n[i+1].poison_v</pre>
<pre>                                              & calc_stage_r[i].irf_w_v;</pre>
<pre>        calc_status.dep_status[i].mem_iwb_v = calc_stage_r[i].pipe_mem_v </pre>
<pre>                                              & ~exc_stage_n[i+1].poison_v</pre>
<pre>                                              & calc_stage_r[i].irf_w_v;</pre>
<pre>        calc_status.dep_status[i].mem_fwb_v = calc_stage_r[i].pipe_mem_v </pre>
<pre>                                              & ~exc_stage_n[i+1].poison_v</pre>
<pre>                                              & calc_stage_r[i].frf_w_v;</pre>
<pre>        calc_status.dep_status[i].fp_fwb_v  = calc_stage_r[i].pipe_fp_v  </pre>
<pre>                                              & ~exc_stage_n[i+1].poison_v</pre>
<pre>                                              & calc_stage_r[i].frf_w_v;</pre>
<pre>        calc_status.dep_status[i].rd_addr   = calc_stage_r[i].instr.fields.rtype.rd_addr;</pre>
<pre>        calc_status.dep_status[i].mem_v     = calc_stage_r[i].mem_v & ~exc_stage_n[i+1].poison_v;</pre>
<pre>        calc_status.dep_status[i].serial_v  = calc_stage_r[i].csr_v & ~exc_stage_n[i+1].poison_v;</pre>
<pre>      end</pre>
<pre>    calc_status.mem3_miss_v = pipe_mem_miss_v_lo & ~exc_stage_r[2].poison_v;</pre>
<pre>    calc_status.mem3_cmt_v  = calc_stage_r[2].v & ~exc_stage_r[2].roll_v;</pre>
<pre>    </pre>
<pre>      begin : comp_stage_slice</pre>
<pre>        comp_stage_n_slice_iwb_v[i]   = calc_stage_r[i-1].irf_w_v & ~exc_stage_n[i].poison_v; </pre>
<pre>        comp_stage_n_slice_fwb_v[i]   = calc_stage_r[i-1].frf_w_v & ~exc_stage_n[i].poison_v; </pre>
<pre>        comp_stage_n_slice_rd_addr[i] = calc_stage_r[i-1].instr.fields.rtype.rd_addr;</pre>
<pre></pre>
<pre>      end</pre>
<pre>  begin</pre>
<pre>    // Exception aggregation</pre>
<pre>      begin : exc_stage</pre>
<pre>        // Normally, shift down in the pipe</pre>
<pre>      end</pre>
<pre>        exc_stage_n[0].be_nop_v        = be_nop_v;</pre>
<pre>        exc_stage_n[0].me_nop_v        = me_nop_v;</pre>
<pre></pre>
<pre>        exc_stage_n[1].roll_v          = exc_stage_r[0].roll_v   | chk_roll_i;</pre>
<pre>        exc_stage_n[2].roll_v          = exc_stage_r[1].roll_v   | chk_roll_i;</pre>
<pre>        exc_stage_n[3].roll_v          = exc_stage_r[2].roll_v   | chk_roll_i;</pre>
<pre></pre>
<pre>        exc_stage_n[1].poison_v        = exc_stage_r[0].poison_v | chk_poison_ex1_i;</pre>
<pre>        exc_stage_n[2].poison_v        = exc_stage_r[1].poison_v | chk_poison_ex2_i;</pre>
<pre>        exc_stage_n[3].poison_v        = exc_stage_r[2].poison_v | pipe_mem_miss_v_lo | pipe_mem_exc_v_lo;</pre>
<pre>  end</pre>
<pre>assign pc_mem3_o      = calc_stage_r[2].pc;</pre>
<pre>assign pc_v_mem3_o    = calc_stage_r[2].v & ~exc_stage_r[2].poison_v;</pre>
<pre>assign instr_mem3_o   = calc_stage_r[2].instr;</pre>
<pre></pre>
<h3>./bp_be/src/v/bp_be_calculator/bp_be_int_alu.v</h3>
<pre>module bp_be_int_alu </pre>
<pre>   localparam fu_op_width_lp      = `bp_be_fu_op_width</pre>
<pre>   , localparam word_width_lp     = rv64_word_width_gp</pre>
<pre>   , localparam shamt_width_lp    = rv64_shamt_width_gp</pre>
<pre>   , localparam shamtw_width_lp   = rv64_shamtw_width_gp</pre>
<pre>   )</pre>
<pre>   , input [reg_data_width_lp-1:0]  src2_i</pre>
<pre></pre>
<pre>   , input                          opw_v_i</pre>
<pre></pre>
<pre>   );</pre>
<pre>logic signed [word_width_lp-1:0]     src1_w_sgn , src2_w_sgn;</pre>
<pre>logic signed [reg_data_width_lp-1:0] result_sgn ;</pre>
<pre>logic signed [word_width_lp-1:0]     resultw_sgn;</pre>
<pre>logic        [shamt_width_lp-1:0]    shamt;</pre>
<pre>logic        [shamtw_width_lp-1:0]   shamtw;</pre>
<pre> </pre>
<pre>assign src2_sgn   = $signed(src2_i);</pre>
<pre>assign src1_w_sgn = $signed(src1_i[0+:word_width_lp]);</pre>
<pre>assign src2_w_sgn = $signed(src2_i[0+:word_width_lp]);</pre>
<pre></pre>
<pre>assign shamtw     = src2_i[0+:shamtw_width_lp];</pre>
<pre></pre>
<pre>  begin</pre>
<pre>    // These two case statements are mutually exclusive, but we separate them because they </pre>
<pre>      e_int_op_add : resultw_sgn = src1_w_sgn +   src2_w_sgn;</pre>
<pre>      e_int_op_sub : resultw_sgn = src1_w_sgn -   src2_w_sgn;</pre>
<pre>      e_int_op_sll : resultw_sgn = src1_w_sgn <<  shamtw;</pre>
<pre>      e_int_op_srl : resultw_sgn = src1_w_sgn >>  shamtw;</pre>
<pre>      e_int_op_sra : resultw_sgn = src1_w_sgn >>> shamtw;</pre>
<pre>      default      : resultw_sgn = '0;</pre>
<pre>    endcase</pre>
<pre>      e_int_op_add       : result_sgn = src1_sgn +   src2_sgn;</pre>
<pre>      e_int_op_sub       : result_sgn = src1_sgn -   src2_sgn;</pre>
<pre>      e_int_op_xor       : result_sgn = src1_sgn ^   src2_sgn;</pre>
<pre>      e_int_op_or        : result_sgn = src1_sgn |   src2_sgn;</pre>
<pre>      e_int_op_and       : result_sgn = src1_sgn &   src2_sgn;</pre>
<pre>      e_int_op_sll       : result_sgn = src1_sgn <<  shamt;</pre>
<pre>      e_int_op_srl       : result_sgn = src1_sgn >>  shamt;</pre>
<pre>      e_int_op_sra       : result_sgn = src1_sgn >>> shamt;</pre>
<pre>      e_int_op_pass_src2 : result_sgn =              src2_i;</pre>
<pre>  </pre>
<pre>      e_int_op_sge  : result_sgn = (reg_data_width_lp)'($unsigned(src1_sgn >= src2_sgn));</pre>
<pre>      e_int_op_eq   : result_sgn = (reg_data_width_lp)'($unsigned(src1_i   == src2_i));</pre>
<pre>      e_int_op_ne   : result_sgn = (reg_data_width_lp)'($unsigned(src1_i   != src2_i));</pre>
<pre>      e_int_op_sltu : result_sgn = (reg_data_width_lp)'($unsigned(src1_i   <  src2_i));</pre>
<pre>      e_int_op_sgeu : result_sgn = (reg_data_width_lp)'($unsigned(src1_i   >= src2_i));</pre>
<pre>      default       : result_sgn = '0;</pre>
<pre>    endcase</pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<h3>./bp_be/src/v/bp_be_mem/bp_be_csr.v</h3>
<pre>module bp_be_csr</pre>
<pre>  #(parameter bp_cfg_e cfg_p = e_bp_inv_cfg</pre>
<pre>    `declare_bp_proc_params(cfg_p)</pre>
<pre>    , localparam fu_op_width_lp = `bp_be_fu_op_width</pre>
<pre>    , localparam csr_cmd_width_lp = `bp_be_csr_cmd_width</pre>
<pre>    , localparam ecode_dec_width_lp = `bp_be_ecode_dec_width</pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre>    )</pre>
<pre>   (input                            clk_i</pre>
<pre>    , input                          reset_i</pre>
<pre></pre>
<pre>    , input [csr_cmd_width_lp-1:0]   csr_cmd_i</pre>
<pre>    , input                          csr_cmd_v_i</pre>
<pre>    , output                         csr_cmd_ready_o</pre>
<pre></pre>
<pre>    , output [dword_width_p-1:0]     data_o</pre>
<pre>    , output                         v_o</pre>
<pre>    , output logic                   illegal_instr_o</pre>
<pre></pre>
<pre>    , input [hartid_width_lp-1:0]    hartid_i</pre>
<pre>    , input                          instret_i</pre>
<pre></pre>
<pre style="background-color: #FF0000;">    , input                          exception_v_i</pre>
<pre>    , input [vaddr_width_p-1:0]      exception_pc_i</pre>
<pre>    , input [vaddr_width_p-1:0]      exception_vaddr_i</pre>
<pre>    , input [instr_width_p-1:0]      exception_instr_i</pre>
<pre>    , input [ecode_dec_width_lp-1:0] exception_ecode_dec_i</pre>
<pre></pre>
<pre>    , input                          software_int_i</pre>
<pre>    , input                          external_int_i</pre>
<pre>    , input [vaddr_width_p-1:0]      interrupt_pc_i</pre>
<pre></pre>
<pre>    , output logic                      trap_v_o</pre>
<pre>    , output logic                      ret_v_o</pre>
<pre>    , output logic [vaddr_width_p-1:0]  epc_o</pre>
<pre>    , output logic [vaddr_width_p-1:0]  tvec_o</pre>
<pre>    , output [satp_width_lp-1:0]        satp_o</pre>
<pre>    , output                            translation_en_o</pre>
<pre>    , output logic                      tlb_fence_o</pre>
<pre>    );</pre>
<pre style="background-color: #FF0000;"></pre>
<pre>bp_be_ecode_dec_s exception_ecode_dec_cast_i;</pre>
<pre></pre>
<pre>assign exception_ecode_dec_cast_i = exception_ecode_dec_i;</pre>
<pre></pre>
<pre></pre>
<pre>rv64_mie_s sie_wmask_li, sie_rmask_li;</pre>
<pre>rv64_mip_s sip_wmask_li, sip_rmask_li;;</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre>wire is_s_mode = (priv_mode_r == `PRIV_MODE_S);</pre>
<pre>wire is_u_mode = (priv_mode_r == `PRIV_MODE_U);</pre>
<pre></pre>
<pre>wire msi_v = mstatus_r.mie & mie_r.msie & mip_r.msip;</pre>
<pre>wire mei_v = mstatus_r.mie & mie_r.meie & mip_r.meip;</pre>
<pre></pre>
<pre>wire ssi_v = mstatus_r.sie & mie_r.ssie & mip_r.ssip;</pre>
<pre>wire sei_v = mstatus_r.sie & mie_r.seie & mip_r.seip;</pre>
<pre></pre>
<pre>  {4'b0</pre>
<pre></pre>
<pre>   ,mei_v & ~mideleg_lo.mei</pre>
<pre>   ,1'b0</pre>
<pre>   ,sei_v &  mideleg_lo.sei</pre>
<pre>   ,1'b0</pre>
<pre></pre>
<pre>   ,1'b0 // Reserved</pre>
<pre>   ,sti_v &  mideleg_lo.sei</pre>
<pre>   ,1'b0</pre>
<pre></pre>
<pre>   ,msi_v & ~mideleg_lo.msi</pre>
<pre>   ,1'b0 // Reserved</pre>
<pre>   ,ssi_v &  mideleg_lo.ssi</pre>
<pre>   ,1'b0</pre>
<pre>   };</pre>
<pre>logic [3:0] exception_ecode_li;</pre>
<pre>logic       exception_ecode_v_li;</pre>
<pre>bsg_priority_encode </pre>
<pre> #(.width_p(ecode_dec_width_lp)</pre>
<pre>   ,.lo_to_hi_p(1)</pre>
<pre>   )</pre>
<pre> mcause_exception_enc</pre>
<pre style="background-color: #FF0000;">  (.i(exception_ecode_dec_i)</pre>
<pre>   ,.addr_o(exception_ecode_li)</pre>
<pre>   ,.v_o(exception_ecode_v_li)</pre>
<pre>   );</pre>
<pre></pre>
<pre>// TODO: This priority encoder needs to be swizzled, right now it is non-compliant with the spec...</pre>
<pre>logic [3:0] exception_icode_li;</pre>
<pre>logic       exception_icode_v_li;</pre>
<pre>bsg_priority_encode</pre>
<pre> #(.width_p(ecode_dec_width_lp)</pre>
<pre>   ,.lo_to_hi_p(1)</pre>
<pre>   )</pre>
<pre> mcause_interrupt_enc</pre>
<pre>  (.i(exception_icode_dec_li)</pre>
<pre>   ,.addr_o(exception_icode_li)</pre>
<pre>   ,.v_o(exception_icode_v_li)</pre>
<pre>   );</pre>
<pre>// Compute input CSR data</pre>
<pre>wire [dword_width_p-1:0] csr_imm_li = dword_width_p'(csr_cmd.data[4:0]);</pre>
<pre>always_comb </pre>
<pre>  begin</pre>
<pre>    unique casez (csr_cmd.csr_op)</pre>
<pre>      e_csrrw : csr_data_li =  csr_cmd.data;</pre>
<pre>      e_csrrs : csr_data_li =  csr_cmd.data | csr_data_lo;</pre>
<pre>      e_csrrc : csr_data_li = ~csr_cmd.data & csr_data_lo;</pre>
<pre></pre>
<pre>      e_csrrwi: csr_data_li =  csr_imm_li;</pre>
<pre>      e_csrrsi: csr_data_li =  csr_imm_li | csr_data_lo;</pre>
<pre>      e_csrrci: csr_data_li = ~csr_imm_li & csr_data_lo;</pre>
<pre>      default : csr_data_li = '0;</pre>
<pre>    endcase</pre>
<pre>// sstatus subset of mstatus</pre>
<pre>// sedeleg hardcoded to 0</pre>
<pre style="background-color: #FF0000;">// sideleg hardcoded to 0</pre>
<pre>`declare_csr(stvec)</pre>
<pre>`declare_csr(scounteren)</pre>
<pre>`declare_csr(sscratch)</pre>
<pre>`declare_csr(sepc)</pre>
<pre>`declare_csr(scause)</pre>
<pre>`declare_csr(stval)</pre>
<pre></pre>
<pre>`declare_csr(medeleg)</pre>
<pre>`declare_csr(pmpcfg0)</pre>
<pre>`declare_csr(pmpaddr1)</pre>
<pre>// mhpmcounter not implemented</pre>
<pre>`declare_csr(mcountinhibit)</pre>
<pre>// mhpmevent not implemented</pre>
<pre>//   This is non-compliant. We should hardcode to 0 instead of trapping</pre>
<pre style="background-color: #FF0000;"></pre>
<pre> #(.width_p(2) </pre>
<pre>   ,.reset_val_p(`PRIV_MODE_M)</pre>
<pre>   )</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>   ,.data_o(priv_mode_r)</pre>
<pre>   );</pre>
<pre>  begin</pre>
<pre>    priv_mode_n = priv_mode_r;</pre>
<pre></pre>
<pre>    stvec_li      = stvec_lo;</pre>
<pre>    scounteren_li = scounteren_lo;</pre>
<pre></pre>
<pre>    sepc_li     = sepc_lo;</pre>
<pre>    scause_li   = scause_lo;</pre>
<pre>    stval_li    = stval_lo;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">    satp_li     = satp_lo;</pre>
<pre></pre>
<pre>    medeleg_li    = medeleg_lo;</pre>
<pre>    mideleg_li    = mideleg_lo;</pre>
<pre>    mie_li        = mie_lo;</pre>
<pre>    mtvec_li      = mtvec_lo;</pre>
<pre>    mcounteren_li = mcounteren_lo;</pre>
<pre></pre>
<pre>    mscratch_li = mscratch_lo;</pre>
<pre>    mepc_li     = mepc_lo;</pre>
<pre>    mcause_li   = mcause_lo;</pre>
<pre>    mtval_li    = mtval_lo;</pre>
<pre>    mip_li      = mip_lo;</pre>
<pre></pre>
<pre>    pmpaddr0_li = pmpaddr0_lo;</pre>
<pre>    pmpaddr1_li = pmpaddr1_lo;</pre>
<pre>    pmpaddr2_li = pmpaddr2_lo;</pre>
<pre>    pmpaddr3_li = pmpaddr3_lo;</pre>
<pre></pre>
<pre>    minstret_li      = mcountinhibit_lo.ir ? minstret_lo + dword_width_p'(instret_i) : minstret_lo;</pre>
<pre>    mcountinhibit_li = mcountinhibit_lo;</pre>
<pre></pre>
<pre>    ret_v_o         = '0;</pre>
<pre>    illegal_instr_o = '0;</pre>
<pre>    csr_data_lo     = '0;</pre>
<pre>    tlb_fence_o     = '0;</pre>
<pre></pre>
<pre>    sstatus_rmask_li = '0;</pre>
<pre>    sie_wmask_li     = '0;</pre>
<pre>    sie_rmask_li     = '0;</pre>
<pre>    sip_wmask_li     = '0;</pre>
<pre>    sip_rmask_li     = '0;</pre>
<pre>        </pre>
<pre>      if (csr_cmd.csr_op == e_sfence_vma)</pre>
<pre>        begin</pre>
<pre>          illegal_instr_o = (priv_mode_r < `PRIV_MODE_S);</pre>
<pre>          tlb_fence_o     = ~illegal_instr_o;</pre>
<pre>        end</pre>
<pre>        begin</pre>
<pre>          priv_mode_n      = mstatus_lo.mpp;</pre>
<pre></pre>
<pre>          mstatus_li.mpp   = `PRIV_MODE_M; // Should be U when U-mode is supported</pre>
<pre>          mstatus_li.mpie  = 1'b1;</pre>
<pre>          mstatus_li.mie   = mstatus_lo.mpie;</pre>
<pre></pre>
<pre>          ret_v_o          = ~illegal_instr_o;</pre>
<pre>        end</pre>
<pre>        begin</pre>
<pre>          priv_mode_n      = {1'b0, mstatus_lo.spp};</pre>
<pre>          </pre>
<pre>          mstatus_li.spie  = 1'b1;</pre>
<pre>          mstatus_li.sie   = mstatus_lo.spie;</pre>
<pre></pre>
<pre>          ret_v_o          = ~illegal_instr_o;</pre>
<pre>        end</pre>
<pre>        begin</pre>
<pre>          // NOPs for now. EBREAK and WFI are likely to remain a NOP for a while, whereas</pre>
<pre>          sstatus_wmask_li = '{mpp: 2'b00, spp: 2'b11</pre>
<pre>                               ,mpie: 1'b0, spie: 1'b1, upie: 1'b1</pre>
<pre>                               ,mie: 1'b0, sie: 1'b1, uie: 1'b1</pre>
<pre>                               ,default: '0</pre>
<pre>                               };</pre>
<pre>          sstatus_rmask_li = '{sd: 1'b1, uxl: 2'b11</pre>
<pre>                               ,mxr: 1'b1, sum: 1'b1</pre>
<pre>                               ,xs: 2'b11, fs: 2'b11</pre>
<pre>                               ,mpp: 2'b00, spp: 2'b11</pre>
<pre>                               ,mpie: 1'b0, spie: 1'b1, upie: 1'b1</pre>
<pre>                               ,mie: 1'b0, sie: 1'b1, uie: 1'b1</pre>
<pre>                               ,default: '0</pre>
<pre>                               };</pre>
<pre style="background-color: #FF0000;">          sie_wmask_li     = '{meie: mideleg_lo.mei, seie: 1'b1</pre>
<pre>                               ,mtie: mideleg_lo.mti, stie: 1'b1</pre>
<pre>                               ,msie: mideleg_lo.msi, ssie: 1'b1</pre>
<pre>                               ,default: '0</pre>
<pre>                               };</pre>
<pre>                               ,mtie: mideleg_lo.mti, stie: 1'b1</pre>
<pre>                               ,msie: mideleg_lo.msi, ssie: 1'b1</pre>
<pre>                               ,default: '0</pre>
<pre>                               };</pre>
<pre>                               ,mtip: 1'b0, stip: 1'b1</pre>
<pre>                               ,msip: 1'b0, ssip: 1'b1</pre>
<pre>                               ,default: '0</pre>
<pre>                               };</pre>
<pre>                               ,mtip: mideleg_lo.mti, stip: 1'b1</pre>
<pre>                               ,msip: mideleg_lo.msi, ssip: 1'b1</pre>
<pre>                               ,default: '0};</pre>
<pre></pre>
<pre>          endcase</pre>
<pre>      illegal_instr_o = 1'b1;</pre>
<pre>    if (is_u_mode & (csr_cmd.csr_addr == `CSR_ADDR_CYCLE) & ~scounteren_lo.cy)</pre>
<pre>      illegal_instr_o = 1'b1;</pre>
<pre>    if (is_s_mode & (csr_cmd.csr_addr == `CSR_ADDR_INSTRET) & ~mcounteren_lo.ir)</pre>
<pre>      illegal_instr_o = 1'b1;</pre>
<pre>    if (is_u_mode & (csr_cmd.csr_addr == `CSR_ADDR_INSTRET) & ~scounteren_lo.ir)</pre>
<pre>      illegal_instr_o = 1'b1;</pre>
<pre></pre>
<pre>        mip_li.mtip = 1'b1;</pre>
<pre></pre>
<pre>        mip_li.msip = 1'b1;</pre>
<pre></pre>
<pre>        mip_li.meip = 1'b1;</pre>
<pre></pre>
<pre>      if (medeleg_lo[exception_ecode_li] & ~is_m_mode)</pre>
<pre>        begin</pre>
<pre>          priv_mode_n          = `PRIV_MODE_S;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">          mstatus_li.spp       = priv_mode_r;</pre>
<pre>          mstatus_li.spie      = mstatus_lo.sie;</pre>
<pre>          mstatus_li.sie       = 1'b0;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">          sepc_li              = paddr_width_p'($signed(exception_pc_i));</pre>
<pre>          stval_li             = exception_ecode_dec_cast_i.illegal_instr </pre>
<pre>                                ? exception_instr_i </pre>
<pre>                                : paddr_width_p'($signed(exception_vaddr_i));</pre>
<pre></pre>
<pre style="background-color: #FF0000;">          scause_li._interrupt = 1'b0;</pre>
<pre>          scause_li.ecode      = exception_ecode_li;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">          trap_v_o            = 1'b1;</pre>
<pre>        end</pre>
<pre style="background-color: #FF0000;">        begin</pre>
<pre>          priv_mode_n          = `PRIV_MODE_M;</pre>
<pre></pre>
<pre>          mstatus_li.mpie      = mstatus_lo.mie;</pre>
<pre>          mstatus_li.mie       = 1'b0;</pre>
<pre></pre>
<pre>          mtval_li             = exception_ecode_dec_cast_i.illegal_instr </pre>
<pre>                                ? exception_instr_i </pre>
<pre>                                : paddr_width_p'($signed(exception_vaddr_i));</pre>
<pre></pre>
<pre>          mcause_li.ecode      = exception_ecode_li;</pre>
<pre></pre>
<pre>          trap_v_o             = 1'b1;</pre>
<pre>        end</pre>
<pre>      if (mideleg_lo[exception_icode_li] & ~is_m_mode)</pre>
<pre>        begin</pre>
<pre>          priv_mode_n          = `PRIV_MODE_S;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">          mstatus_li.spp       = priv_mode_r;</pre>
<pre>          mstatus_li.spie      = mstatus_lo.sie;</pre>
<pre>          mstatus_li.sie       = 1'b0;</pre>
<pre></pre>
<pre>                                ? paddr_width_p'($signed(exception_pc_i))</pre>
<pre>                                : paddr_width_p'($signed(interrupt_pc_i));</pre>
<pre>          stval_li             = '0;</pre>
<pre>          scause_li._interrupt = 1'b1;</pre>
<pre>          scause_li.ecode      = exception_icode_li;</pre>
<pre></pre>
<pre>        end</pre>
<pre>          priv_mode_n          = `PRIV_MODE_M;</pre>
<pre></pre>
<pre>          mstatus_li.mpie      = mstatus_lo.mie;</pre>
<pre>          mstatus_li.mie       = 1'b0;</pre>
<pre></pre>
<pre>                                ? paddr_width_p'($signed(exception_pc_i))</pre>
<pre>                                : paddr_width_p'($signed(interrupt_pc_i));</pre>
<pre>          mtval_li             = '0;</pre>
<pre>          mcause_li._interrupt = 1'b1;</pre>
<pre>          mcause_li.ecode      = exception_icode_li;</pre>
<pre></pre>
<pre>        end</pre>
<pre>assign tvec_o          = (priv_mode_n == `PRIV_MODE_S) ? stvec_r : mtvec_r;</pre>
<pre>assign satp_o          = satp_r;</pre>
<pre>// We only support SV39 so the mode can either be 0(off) or 1(SV39)</pre>
<pre>                          | (mstatus_lo.mprv & (mstatus_lo.mpp < `PRIV_MODE_M) & (satp_r.mode == 1'b1));</pre>
<pre></pre>
<pre>assign data_o          = dword_width_p'(csr_data_lo);</pre>
<pre>assign v_o             = csr_cmd_v_i;</pre>
<pre></pre>
<pre>endmodule: bp_be_csr</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./bp_be/src/v/bp_be_checker/bp_be_detector.v</h3>
<pre>module bp_be_detector </pre>
<pre> import bp_common_aviary_pkg::*;</pre>
<pre> import bp_common_rv64_pkg::*;</pre>
<pre> import bp_be_pkg::*;</pre>
<pre> #(parameter bp_cfg_e cfg_p = e_bp_inv_cfg</pre>
<pre>   `declare_bp_proc_params(cfg_p)</pre>
<pre></pre>
<pre>   // Generated parameters</pre>
<pre>   , localparam isd_status_width_lp = `bp_be_isd_status_width</pre>
<pre>   , localparam calc_status_width_lp = `bp_be_calc_status_width(vaddr_width_p, branch_metadata_fwd_width_p)</pre>
<pre>   )</pre>
<pre>  (input                               clk_i</pre>
<pre>   , input                             reset_i</pre>
<pre></pre>
<pre>   , input [isd_status_width_lp-1:0]   isd_status_i</pre>
<pre>   , input [calc_status_width_lp-1:0]  calc_status_i</pre>
<pre>   , input [vaddr_width_p-1:0]         expected_npc_i</pre>
<pre>   , input                             mmu_cmd_ready_i</pre>
<pre>   , input                             credits_full_i</pre>
<pre>   , input                             credits_empty_i</pre>
<pre></pre>
<pre>   , input                             flush_i</pre>
<pre></pre>
<pre>   // Pipeline control signals from the checker to the calculator</pre>
<pre style="background-color: #FF0000;">   , output                            chk_dispatch_v_o</pre>
<pre>   , output                            chk_roll_o</pre>
<pre>   , output                            chk_poison_iss_o</pre>
<pre>   , output                            chk_poison_isd_o</pre>
<pre>   , output                            chk_poison_ex1_o</pre>
<pre>   , output                            chk_poison_ex2_o</pre>
<pre>  );</pre>
<pre></pre>
<pre>`declare_bp_be_internal_if_structs(vaddr_width_p, paddr_width_p, asid_width_p, branch_metadata_fwd_width_p); </pre>
<pre></pre>
<pre>// Casting </pre>
<pre>bp_be_isd_status_s       isd_status_cast_i;</pre>
<pre>bp_be_calc_status_s      calc_status_cast_i;</pre>
<pre>bp_be_dep_status_s [4:0] dep_status_li;</pre>
<pre></pre>
<pre>assign isd_status_cast_i  = isd_status_i;</pre>
<pre>assign calc_status_cast_i = calc_status_i;</pre>
<pre>assign dep_status_li      = calc_status_cast_i.dep_status;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">// Suppress unused inputs</pre>
<pre></pre>
<pre>// Integer data hazards</pre>
<pre>logic [2:0] irs1_data_haz_v , irs2_data_haz_v;</pre>
<pre>// Floating point data hazards</pre>
<pre>logic [2:0] frs1_data_haz_v , frs2_data_haz_v;</pre>
<pre>logic [2:0] rs1_match_vector, rs2_match_vector;</pre>
<pre></pre>
<pre>logic fence_haz_v, serial_haz_v, data_haz_v, struct_haz_v, mispredict_v, mem_in_pipe_v;</pre>
<pre></pre>
<pre>always_comb </pre>
<pre>  begin</pre>
<pre>    // Generate matches for rs1 and rs2.</pre>
<pre>    // 3 stages because we only care about ex1, ex2, and iwb dependencies. fwb dependencies</pre>
<pre>    for(integer i = 0; i < 3; i++) </pre>
<pre>      begin</pre>
<pre>        rs1_match_vector[i] = (isd_status_cast_i.isd_rs1_addr != '0)</pre>
<pre>                              & (isd_status_cast_i.isd_rs1_addr == dep_status_li[i].rd_addr);</pre>
<pre></pre>
<pre>        rs2_match_vector[i] = (isd_status_cast_i.isd_rs2_addr != '0)</pre>
<pre>                              & (isd_status_cast_i.isd_rs2_addr == dep_status_li[i].rd_addr);</pre>
<pre>      end</pre>
<pre>    irs1_data_haz_v[0] = (isd_status_cast_i.isd_irs1_v & rs1_match_vector[0])</pre>
<pre>                         & (dep_status_li[0].mul_iwb_v | dep_status_li[0].mem_iwb_v);</pre>
<pre></pre>
<pre>    irs2_data_haz_v[0] = (isd_status_cast_i.isd_irs2_v & rs2_match_vector[0])</pre>
<pre>                         & (dep_status_li[0].mul_iwb_v | dep_status_li[0].mem_iwb_v);</pre>
<pre></pre>
<pre>    frs1_data_haz_v[0] = (isd_status_cast_i.isd_frs1_v & rs1_match_vector[0])</pre>
<pre>                         & (dep_status_li[0].mem_fwb_v | dep_status_li[0].fp_fwb_v);</pre>
<pre></pre>
<pre>    frs2_data_haz_v[0] = (isd_status_cast_i.isd_frs2_v & rs2_match_vector[0])</pre>
<pre>                         & (dep_status_li[0].mem_fwb_v | dep_status_li[0].fp_fwb_v);</pre>
<pre></pre>
<pre>    // Detect integer and float data hazards for EX2</pre>
<pre>    irs1_data_haz_v[1] = (isd_status_cast_i.isd_irs1_v & rs1_match_vector[1])</pre>
<pre>                         & (dep_status_li[1].mem_iwb_v);</pre>
<pre></pre>
<pre>    irs2_data_haz_v[1] = (isd_status_cast_i.isd_irs2_v & rs2_match_vector[1])</pre>
<pre>                         & (dep_status_li[1].mem_iwb_v);</pre>
<pre></pre>
<pre>    frs1_data_haz_v[1] = (isd_status_cast_i.isd_frs1_v & rs1_match_vector[1])</pre>
<pre>                         & (dep_status_li[1].mem_fwb_v | dep_status_li[1].fp_fwb_v);</pre>
<pre></pre>
<pre>    frs2_data_haz_v[1] = (isd_status_cast_i.isd_frs2_v & rs2_match_vector[1])</pre>
<pre>                         & (dep_status_li[1].mem_fwb_v | dep_status_li[1].fp_fwb_v);</pre>
<pre></pre>
<pre>    irs1_data_haz_v[2] = '0;</pre>
<pre>    irs2_data_haz_v[2] = '0;</pre>
<pre></pre>
<pre>    frs1_data_haz_v[2] = (isd_status_cast_i.isd_frs1_v & rs1_match_vector[2])</pre>
<pre>                         & (dep_status_li[2].fp_fwb_v);</pre>
<pre></pre>
<pre>    frs2_data_haz_v[2] = (isd_status_cast_i.isd_frs2_v & rs2_match_vector[2])</pre>
<pre>                         & (dep_status_li[2].fp_fwb_v);</pre>
<pre></pre>
<pre>    mem_in_pipe_v      = dep_status_li[0].mem_v | dep_status_li[1].mem_v | dep_status_li[2].mem_v;</pre>
<pre>    fence_haz_v        = (isd_status_cast_i.isd_fence_v & (~credits_empty_i | mem_in_pipe_v))</pre>
<pre>                         | (isd_status_cast_i.isd_mem_v & credits_full_i);</pre>
<pre></pre>
<pre>    serial_haz_v       = dep_status_li[0].serial_v</pre>
<pre>                         | dep_status_li[1].serial_v</pre>
<pre>                         | dep_status_li[2].serial_v</pre>
<pre>                         | dep_status_li[3].serial_v;</pre>
<pre></pre>
<pre>    // Combine all data hazard information</pre>
<pre>    // TODO: Parameterize away floating point data hazards without hardware support</pre>
<pre>                 | (|irs2_data_haz_v) </pre>
<pre>                 | (|frs1_data_haz_v) </pre>
<pre>                 | (|frs2_data_haz_v);</pre>
<pre></pre>
<pre>    // Combine all structural hazard information</pre>
<pre>    struct_haz_v = ~mmu_cmd_ready_i | fence_haz_v | serial_haz_v;</pre>
<pre></pre>
<pre>    // Detect misprediction</pre>
<pre>    mispredict_v = (calc_status_cast_i.ex1_v & (calc_status_cast_i.ex1_pc != expected_npc_i));</pre>
<pre>  end</pre>
<pre>// Generate calculator control signals</pre>
<pre>assign chk_dispatch_v_o = ~(data_haz_v | struct_haz_v); </pre>
<pre>assign chk_roll_o       = calc_status_cast_i.mem3_miss_v;</pre>
<pre></pre>
<pre>assign chk_poison_iss_o = mispredict_v</pre>
<pre>                          | flush_i</pre>
<pre>                          | calc_status_cast_i.mem3_miss_v;</pre>
<pre>                          </pre>
<pre>assign chk_poison_isd_o = mispredict_v</pre>
<pre>                          | flush_i</pre>
<pre>                          | calc_status_cast_i.mem3_miss_v;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">assign chk_poison_ex1_o = mispredict_v</pre>
<pre>                          | flush_i</pre>
<pre>                          | calc_status_cast_i.mem3_miss_v;</pre>
<pre></pre>
<pre>                          | calc_status_cast_i.mem3_miss_v;</pre>
<pre></pre>
<h3>./bp_be/src/v/bp_be_mem/bp_be_mem_top.v</h3>
<pre> *    bp_be_mem_top.v</pre>
<pre style="background-color: #FF0000;"> * </pre>
<pre> *  Description:</pre>
<pre> *    memory management unit.</pre>
<pre> *</pre>
<pre> */</pre>
<pre></pre>
<pre>module bp_be_mem_top </pre>
<pre>  import bp_common_pkg::*;</pre>
<pre>  import bp_common_aviary_pkg::*;</pre>
<pre>  import bp_be_pkg::*;</pre>
<pre>  import bp_common_rv64_pkg::*;</pre>
<pre>  import bp_be_dcache_pkg::*;</pre>
<pre> #(parameter bp_cfg_e cfg_p = e_bp_inv_cfg</pre>
<pre>   `declare_bp_proc_params(cfg_p)</pre>
<pre>   `declare_bp_lce_cce_if_widths(num_cce_p</pre>
<pre>                                 ,num_lce_p</pre>
<pre>                                 ,paddr_width_p</pre>
<pre>                                 ,lce_assoc_p</pre>
<pre>                                 ,dword_width_p</pre>
<pre>                                 ,cce_block_width_p</pre>
<pre>                                 )</pre>
<pre>   , localparam ecode_dec_width_lp = `bp_be_ecode_dec_width</pre>
<pre>   // Generated parameters</pre>
<pre>   // D$   </pre>
<pre>   , localparam block_size_in_words_lp = lce_assoc_p // Due to cache interleaving scheme</pre>
<pre>   , localparam data_mask_width_lp     = (dword_width_p >> 3) // Byte mask</pre>
<pre>   , localparam byte_offset_width_lp   = `BSG_SAFE_CLOG2(dword_width_p >> 3)</pre>
<pre>   , localparam word_offset_width_lp   = `BSG_SAFE_CLOG2(block_size_in_words_lp)</pre>
<pre>   , localparam block_offset_width_lp  = (word_offset_width_lp + byte_offset_width_lp)</pre>
<pre>   , localparam index_width_lp         = `BSG_SAFE_CLOG2(lce_sets_p)</pre>
<pre>   , localparam page_offset_width_lp   = (block_offset_width_lp + index_width_lp)</pre>
<pre>   , localparam dcache_pkt_width_lp    = `bp_be_dcache_pkt_width(page_offset_width_lp</pre>
<pre>                                                                 , dword_width_p</pre>
<pre>                                                                 )</pre>
<pre>   , localparam proc_cfg_width_lp      = `bp_proc_cfg_width(num_core_p, num_cce_p, num_lce_p)</pre>
<pre>   , localparam lce_id_width_lp        = `BSG_SAFE_CLOG2(num_lce_p)</pre>
<pre></pre>
<pre style="background-color: #FF0000;">   // MMU                                                              </pre>
<pre>   , localparam mmu_cmd_width_lp  = `bp_be_mmu_cmd_width(vaddr_width_p)</pre>
<pre>   , localparam csr_cmd_width_lp  = `bp_be_csr_cmd_width</pre>
<pre>   , localparam mem_resp_width_lp = `bp_be_mem_resp_width(vaddr_width_p)</pre>
<pre>   </pre>
<pre>   // VM</pre>
<pre>   , localparam tlb_entry_width_lp = `bp_pte_entry_leaf_width(paddr_width_p)</pre>
<pre>   )</pre>
<pre>  (input                                     clk_i</pre>
<pre>   , input                                   reset_i</pre>
<pre>   , input                                   freeze_i</pre>
<pre></pre>
<pre>   // Config channel</pre>
<pre>   , input                                   cfg_w_v_i</pre>
<pre>   , input [cfg_addr_width_p-1:0]            cfg_addr_i</pre>
<pre>   , input [cfg_data_width_p-1:0]            cfg_data_i</pre>
<pre></pre>
<pre>   , input [mmu_cmd_width_lp-1:0]            mmu_cmd_i</pre>
<pre>   , input                                   mmu_cmd_v_i</pre>
<pre>   , output                                  mmu_cmd_ready_o</pre>
<pre></pre>
<pre>   , input [csr_cmd_width_lp-1:0]            csr_cmd_i</pre>
<pre>   , input                                   csr_cmd_v_i</pre>
<pre>   , output                                  csr_cmd_ready_o</pre>
<pre></pre>
<pre>   , input                                   chk_poison_ex_i</pre>
<pre></pre>
<pre>   , output [mem_resp_width_lp-1:0]          mem_resp_o</pre>
<pre>   , output                                  mem_resp_v_o</pre>
<pre>   , input                                   mem_resp_ready_i</pre>
<pre></pre>
<pre>   , output                                  itlb_fill_v_o</pre>
<pre>   , output [vaddr_width_p-1:0]              itlb_fill_vaddr_o</pre>
<pre>   , output [tlb_entry_width_lp-1:0]         itlb_fill_entry_o</pre>
<pre>   </pre>
<pre>   , output                                  lce_req_v_o</pre>
<pre>   , input                                   lce_req_ready_i</pre>
<pre></pre>
<pre>   , output [lce_cce_resp_width_lp-1:0]      lce_resp_o</pre>
<pre>   , output                                  lce_resp_v_o</pre>
<pre>   , input                                   lce_resp_ready_i                                 </pre>
<pre></pre>
<pre>   , input [lce_cmd_width_lp-1:0]            lce_cmd_i</pre>
<pre>   , input                                   lce_cmd_v_i</pre>
<pre>   , output                                  lce_cmd_ready_o</pre>
<pre></pre>
<pre>   , output [lce_cmd_width_lp-1:0]           lce_cmd_o</pre>
<pre>   , output                                  lce_cmd_v_o</pre>
<pre>   , input                                   lce_cmd_ready_i </pre>
<pre></pre>
<pre>   , output                                  credits_full_o</pre>
<pre>   , output                                  credits_empty_o</pre>
<pre></pre>
<pre>   // CSRs</pre>
<pre>   , input [proc_cfg_width_lp-1:0]           proc_cfg_i</pre>
<pre>   , input                                   instret_i</pre>
<pre></pre>
<pre>   , input [vaddr_width_p-1:0]               pc_mem3_i</pre>
<pre>   , input [instr_width_p-1:0]               instr_mem3_i</pre>
<pre>   , input                                   pc_v_mem3_i</pre>
<pre></pre>
<pre>   , input                                   timer_int_i</pre>
<pre>   , input                                   software_int_i</pre>
<pre>   , input                                   external_int_i</pre>
<pre>   , input [vaddr_width_p-1:0]               interrupt_pc_i</pre>
<pre></pre>
<pre>   , output [rv64_priv_width_gp-1:0]         priv_mode_o</pre>
<pre>   , output                                  trap_v_o</pre>
<pre>   , output                                  ret_v_o</pre>
<pre>   , output [vaddr_width_p-1:0]              epc_o</pre>
<pre>   , output [vaddr_width_p-1:0]              tvec_o</pre>
<pre>   , output                                  tlb_fence_o</pre>
<pre>   );</pre>
<pre>`declare_bp_fe_be_if(vaddr_width_p, paddr_width_p, asid_width_p, branch_metadata_fwd_width_p);</pre>
<pre>`declare_bp_be_internal_if_structs(vaddr_width_p, paddr_width_p, asid_width_p, branch_metadata_fwd_width_p);</pre>
<pre></pre>
<pre>`declare_bp_common_proc_cfg_s(num_core_p, num_cce_p, num_lce_p)</pre>
<pre>`declare_bp_be_mmu_structs(vaddr_width_p, ptag_width_p, lce_sets_p, cce_block_width_p/8)</pre>
<pre>`declare_bp_be_dcache_pkt_s(page_offset_width_lp, dword_width_p);</pre>
<pre></pre>
<pre>// Cast input and output ports </pre>
<pre>bp_proc_cfg_s          proc_cfg;</pre>
<pre>bp_be_mmu_cmd_s        mmu_cmd;</pre>
<pre>bp_be_csr_cmd_s        csr_cmd;</pre>
<pre>bp_be_mem_resp_s       mem_resp;</pre>
<pre>bp_be_mmu_vaddr_s      mmu_cmd_vaddr;</pre>
<pre>bp_be_mmu_vaddr_s      pc_mem3_cast_i;</pre>
<pre></pre>
<pre>assign proc_cfg = proc_cfg_i;</pre>
<pre>assign mmu_cmd = mmu_cmd_i;</pre>
<pre>assign csr_cmd = csr_cmd_i;</pre>
<pre></pre>
<pre>assign mem_resp_o = mem_resp;</pre>
<pre>assign pc_mem3_cast_i = pc_mem3_i;</pre>
<pre></pre>
<pre>// Suppress unused signal warnings</pre>
<pre>wire unused0 = mem_resp_ready_i;</pre>
<pre></pre>
<pre>/* Internal connections */</pre>
<pre>/* TLB ports */</pre>
<pre>logic                    dtlb_en, dtlb_miss_v, dtlb_w_v, dtlb_r_v, dtlb_r_v_lo;</pre>
<pre>logic [vtag_width_p-1:0] dtlb_r_vtag, dtlb_w_vtag, dtlb_miss_vtag;</pre>
<pre>bp_pte_entry_leaf_s      dtlb_r_entry, dtlb_w_entry;</pre>
<pre></pre>
<pre>/* PTW ports */</pre>
<pre>logic [ptag_width_p-1:0]  ptw_dcache_ptag;</pre>
<pre>logic                     ptw_dcache_v, ptw_busy, ptw_store_not_load;</pre>
<pre>bp_be_dcache_pkt_s        ptw_dcache_pkt; </pre>
<pre>logic                     ptw_tlb_miss_v, ptw_tlb_w_v;</pre>
<pre>logic [vtag_width_p-1:0]  ptw_tlb_w_vtag, ptw_tlb_miss_vtag;</pre>
<pre>bp_pte_entry_leaf_s       ptw_tlb_w_entry;</pre>
<pre>logic                     ptw_page_fault_v, ptw_instr_page_fault_v, ptw_load_page_fault_v, ptw_store_page_fault_v;</pre>
<pre></pre>
<pre>/* D-Cache ports */</pre>
<pre>logic [dword_width_p-1:0] dcache_data;</pre>
<pre>logic [ptag_width_p-1:0]  dcache_ptag;</pre>
<pre>logic                     dcache_ready, dcache_miss_v, dcache_v, dcache_pkt_v;</pre>
<pre>logic                     dcache_tlb_miss, dcache_poison;</pre>
<pre>logic                     dcache_uncached;</pre>
<pre></pre>
<pre>/* CSR signals */</pre>
<pre>logic                     csr_illegal_instr_lo;</pre>
<pre>bp_satp_s                 satp_lo;</pre>
<pre>logic [dword_width_p-1:0] csr_data_lo;</pre>
<pre>logic                     csr_v_lo;</pre>
<pre>logic                     translation_en_lo;</pre>
<pre></pre>
<pre>logic load_access_fault_v, store_access_fault_v;</pre>
<pre></pre>
<pre>logic itlb_not_dtlb_resp;</pre>
<pre>logic mmu_cmd_v_r, mmu_cmd_v_rr, dtlb_miss_r;</pre>
<pre>bp_be_mmu_vaddr_s vaddr_mem3, fault_vaddr;</pre>
<pre>logic is_itlb_fill_mem3;</pre>
<pre>logic is_store_mem3;</pre>
<pre>logic [vaddr_width_p-1:0] fault_pc;</pre>
<pre></pre>
<pre>wire itlb_fill_cmd_v = is_itlb_fill_mem3;</pre>
<pre>wire dtlb_fill_cmd_v = dtlb_miss_r & pc_v_mem3_i;</pre>
<pre></pre>
<pre> #(.width_p(2*vaddr_width_p))</pre>
<pre> fault_reg</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.en_i(itlb_fill_cmd_v | dtlb_fill_cmd_v)</pre>
<pre></pre>
<pre>   ,.data_o({fault_vaddr, fault_pc})</pre>
<pre>   );</pre>
<pre>wire is_store     = mmu_cmd_v_i & mmu_cmd.mem_op inside {e_sb, e_sh, e_sw, e_sd};</pre>
<pre>bsg_dff_chain</pre>
<pre> #(.width_p(2+vaddr_width_p)</pre>
<pre>   ,.num_stages_p(2)</pre>
<pre>   )</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   </pre>
<pre>   ,.data_o({vaddr_mem3, is_store_mem3, is_itlb_fill_mem3})</pre>
<pre>   );</pre>
<pre>assign exception_ecode_dec_li = </pre>
<pre>  '{instr_misaligned : csr_cmd_v_i & (csr_cmd.csr_op == e_op_instr_misaligned)</pre>
<pre>    ,instr_fault     : csr_cmd_v_i & (csr_cmd.csr_op == e_op_instr_access_fault)</pre>
<pre>    ,illegal_instr   : csr_cmd_v_i & ((csr_cmd.csr_op == e_op_illegal_instr) || csr_illegal_instr_lo)</pre>
<pre>    ,breakpoint      : csr_cmd_v_i & (csr_cmd.csr_op == e_ebreak)</pre>
<pre>    ,load_misaligned : 1'b0</pre>
<pre>    ,load_fault      : load_access_fault_v</pre>
<pre>    ,store_misaligned: 1'b0</pre>
<pre>    ,store_fault     : store_access_fault_v</pre>
<pre>    ,ecall_u_mode    : csr_cmd_v_i & (csr_cmd.csr_op == e_ecall) & (priv_mode_o == `PRIV_MODE_U)</pre>
<pre>    ,ecall_s_mode    : csr_cmd_v_i & (csr_cmd.csr_op == e_ecall) & (priv_mode_o == `PRIV_MODE_S)</pre>
<pre>    ,ecall_m_mode    : csr_cmd_v_i & (csr_cmd.csr_op == e_ecall) & (priv_mode_o == `PRIV_MODE_M)</pre>
<pre>    ,instr_page_fault: ptw_instr_page_fault_v</pre>
<pre>    ,load_page_fault : ptw_load_page_fault_v</pre>
<pre>    ,store_page_fault: ptw_store_page_fault_v</pre>
<pre>    ,default: '0</pre>
<pre>    };</pre>
<pre>wire [vaddr_width_p-1:0] exception_vaddr_li = pc_v_mem3_i ? vaddr_mem3 : fault_vaddr;</pre>
<pre>bp_be_csr</pre>
<pre> #(.cfg_p(cfg_p))</pre>
<pre>  csr</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>   ,.csr_cmd_v_i(csr_cmd_v_i)</pre>
<pre>   ,.csr_cmd_ready_o(csr_cmd_ready_o)</pre>
<pre></pre>
<pre>   ,.v_o(csr_v_lo)</pre>
<pre>   ,.illegal_instr_o(csr_illegal_instr_lo)</pre>
<pre></pre>
<pre>   ,.instret_i(instret_i)</pre>
<pre></pre>
<pre>   ,.exception_pc_i(pc_mem3_li)</pre>
<pre>   ,.exception_vaddr_i(exception_vaddr_li)</pre>
<pre>   ,.exception_instr_i(instr_mem3_i)</pre>
<pre>   ,.exception_ecode_dec_i(exception_ecode_dec_li)</pre>
<pre></pre>
<pre>   ,.software_int_i(software_int_i)</pre>
<pre>   ,.external_int_i(external_int_i)</pre>
<pre>   ,.interrupt_pc_i(interrupt_pc_i)</pre>
<pre></pre>
<pre>   ,.trap_v_o(trap_v_o)</pre>
<pre>   ,.ret_v_o(ret_v_o)</pre>
<pre>   ,.epc_o(epc_o)</pre>
<pre>   ,.tvec_o(tvec_o)</pre>
<pre>   ,.satp_o(satp_lo)</pre>
<pre>   ,.translation_en_o(translation_en_lo)</pre>
<pre>   ,.tlb_fence_o(tlb_fence_o)</pre>
<pre>   );</pre>
<pre>  #(.cfg_p(cfg_p)</pre>
<pre>    ,.tlb_els_p(dtlb_els_p)</pre>
<pre>  )</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre>   ,.flush_i(tlb_fence_o)</pre>
<pre>   </pre>
<pre>   ,.w_i(dtlb_w_v)</pre>
<pre>   ,.vtag_i((dtlb_w_v)? dtlb_w_vtag : dtlb_r_vtag)</pre>
<pre>   ,.entry_i(dtlb_w_entry)</pre>
<pre>   </pre>
<pre>   ,.entry_o(dtlb_r_entry)</pre>
<pre>      </pre>
<pre>   ,.miss_vtag_o(dtlb_miss_vtag)</pre>
<pre>  );</pre>
<pre>  #(.cfg_p(cfg_p)</pre>
<pre>    ,.pte_width_p(bp_sv39_pte_width_gp)</pre>
<pre>    ,.page_table_depth_p(bp_sv39_page_table_depth_gp)</pre>
<pre>  )</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre>   ,.base_ppn_i(satp_lo.ppn)</pre>
<pre>   ,.translation_en_i(translation_en_lo)</pre>
<pre>   ,.busy_o(ptw_busy)</pre>
<pre>   </pre>
<pre>   ,.itlb_not_dtlb_o(itlb_not_dtlb_resp)</pre>
<pre>   </pre>
<pre>   </pre>
<pre style="background-color: #FF0000;">   ,.instr_page_fault_o(ptw_instr_page_fault_v)</pre>
<pre>   ,.load_page_fault_o(ptw_load_page_fault_v)</pre>
<pre>   ,.store_page_fault_o(ptw_store_page_fault_v)</pre>
<pre>   </pre>
<pre>   ,.tlb_miss_vtag_i(ptw_tlb_miss_vtag)</pre>
<pre>   </pre>
<pre style="background-color: #FF0000;">   ,.tlb_w_v_o(ptw_tlb_w_v)</pre>
<pre>   ,.tlb_w_vtag_o(ptw_tlb_w_vtag)</pre>
<pre>   ,.tlb_w_entry_o(ptw_tlb_w_entry)</pre>
<pre></pre>
<pre>   ,.dcache_v_i(dcache_v)</pre>
<pre>   ,.dcache_data_i(dcache_data)</pre>
<pre>   </pre>
<pre style="background-color: #FF0000;">   ,.dcache_v_o(ptw_dcache_v)</pre>
<pre>   ,.dcache_pkt_o(ptw_dcache_pkt)</pre>
<pre>   ,.dcache_ptag_o(ptw_dcache_ptag)</pre>
<pre>   ,.dcache_rdy_i(dcache_ready)</pre>
<pre>   ,.dcache_miss_i(dcache_miss_v)</pre>
<pre>  );</pre>
<pre style="background-color: #FF0000;"></pre>
<pre>  #(.cfg_p(cfg_p))</pre>
<pre>  dcache</pre>
<pre style="background-color: #FF0000;">   (.clk_i(clk_i)</pre>
<pre>    ,.reset_i(reset_i)</pre>
<pre>    ,.freeze_i(freeze_i)</pre>
<pre></pre>
<pre>    ,.lce_id_i(proc_cfg.dcache_id)</pre>
<pre>    ,.cfg_w_v_i(cfg_w_v_i)</pre>
<pre>    ,.cfg_addr_i(cfg_addr_i)</pre>
<pre>    ,.cfg_data_i(cfg_data_i)</pre>
<pre></pre>
<pre>    ,.v_i(dcache_pkt_v)</pre>
<pre>    ,.ready_o(dcache_ready)</pre>
<pre></pre>
<pre style="background-color: #FF0000;">    ,.v_o(dcache_v)</pre>
<pre>    ,.data_o(dcache_data)</pre>
<pre></pre>
<pre style="background-color: #FF0000;">    ,.tlb_miss_i(dcache_tlb_miss)</pre>
<pre>    ,.ptag_i(dcache_ptag)</pre>
<pre>    ,.uncached_i(dcache_uncached)</pre>
<pre></pre>
<pre>    ,.poison_i(dcache_poison)</pre>
<pre></pre>
<pre>    ,.lce_req_o(lce_req_o)</pre>
<pre>    ,.lce_req_v_o(lce_req_v_o)</pre>
<pre>    ,.lce_req_ready_i(lce_req_ready_i)</pre>
<pre></pre>
<pre>    ,.lce_resp_v_o(lce_resp_v_o)</pre>
<pre>    ,.lce_resp_ready_i(lce_resp_ready_i)</pre>
<pre></pre>
<pre style="background-color: #FF0000;">    // CCE-LCE interface</pre>
<pre>    ,.lce_cmd_v_i(lce_cmd_v_i)</pre>
<pre>    ,.lce_cmd_ready_o(lce_cmd_ready_o)</pre>
<pre></pre>
<pre>    ,.lce_cmd_v_o(lce_cmd_v_o)</pre>
<pre>    ,.lce_cmd_ready_i(lce_cmd_ready_i)</pre>
<pre></pre>
<pre>    ,.credits_empty_o(credits_empty_o)</pre>
<pre>  </pre>
<pre>    ,.store_access_fault_o(store_access_fault_v)</pre>
<pre>    );</pre>
<pre>  if(reset_i) begin</pre>
<pre>    dtlb_miss_r  <= '0;</pre>
<pre>    mmu_cmd_v_r  <= '0;</pre>
<pre>    mmu_cmd_v_rr <= '0;</pre>
<pre>  end</pre>
<pre>    dtlb_miss_r  <= dtlb_miss_v;</pre>
<pre>    mmu_cmd_v_r  <= mmu_cmd_v_i;</pre>
<pre>    mmu_cmd_v_rr <= mmu_cmd_v_r;</pre>
<pre>  end</pre>
<pre></pre>
<pre>assign dcache_tlb_miss = (ptw_busy)? 1'b0 : dtlb_miss_v;</pre>
<pre>assign dcache_poison   = (ptw_busy)? 1'b0 : chk_poison_ex_i;</pre>
<pre>assign dcache_pkt_v    = (ptw_busy)? ptw_dcache_v : dcache_cmd_v;</pre>
<pre></pre>
<pre>  begin</pre>
<pre>    // TODO: Should we allow uncached accesses during PTW?</pre>
<pre>      dcache_pkt = ptw_dcache_pkt;</pre>
<pre>      dcache_uncached = '0;</pre>
<pre>    end</pre>
<pre>      dcache_uncached        = dtlb_r_v_lo & dtlb_r_entry.uc;</pre>
<pre>      dcache_pkt.opcode      = bp_be_dcache_opcode_e'(mmu_cmd.mem_op);</pre>
<pre>      dcache_pkt.page_offset = {mmu_cmd.vaddr.index, mmu_cmd.vaddr.offset};</pre>
<pre>      dcache_pkt.data        = mmu_cmd.data;</pre>
<pre>    end</pre>
<pre>assign dtlb_r_vtag  = mmu_cmd.vaddr.tag;</pre>
<pre>assign dtlb_w_v     = ptw_tlb_w_v & ~itlb_not_dtlb_resp;</pre>
<pre>assign dtlb_w_vtag  = ptw_tlb_w_vtag;</pre>
<pre>assign dtlb_w_entry = ptw_tlb_w_entry;</pre>
<pre></pre>
<pre>assign ptw_tlb_miss_vtag = vaddr_mem3.tag;</pre>
<pre>assign ptw_page_fault_v  = ptw_instr_page_fault_v | ptw_load_page_fault_v | ptw_store_page_fault_v;</pre>
<pre>assign ptw_store_not_load = dtlb_fill_cmd_v & is_store_mem3;</pre>
<pre> </pre>
<pre>assign mem_resp.exc_v  = |exception_ecode_dec_li;</pre>
<pre>assign mem_resp.data   = dcache_v ? dcache_data : csr_data_lo;</pre>
<pre></pre>
<pre>assign mmu_cmd_ready_o = dcache_ready & ~dcache_miss_v & ~ptw_busy;</pre>
<pre></pre>
<pre>assign itlb_fill_vaddr_o = fault_vaddr;</pre>
<pre>assign itlb_fill_entry_o = ptw_tlb_w_entry;</pre>
<pre></pre>
<pre>always_ff @(negedge clk_i)</pre>
<pre>  begin</pre>
<pre>    dcache_pkt_v_r <= dcache_pkt_v;</pre>
<pre>    assert (~(dcache_pkt_v_r & dcache_uncached & ~dtlb_miss_v & mmu_cmd.mem_op inside {e_lrw, e_lrd, e_scw, e_scd}))</pre>
<pre>      else $warning("LR/SC to uncached memory not supported");</pre>
<pre>  end</pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./bp_be/src/v/bp_be_calculator/bp_be_regfile.v</h3>
<pre>module bp_be_regfile</pre>
<pre>    `declare_bp_proc_params(cfg_p)</pre>
<pre>   , input                         reset_i</pre>
<pre></pre>
<pre>   , input                         dispatch_v_i</pre>
<pre></pre>
<pre>   , input [reg_addr_width_p-1:0]  rd_addr_i</pre>
<pre>   , input [dword_width_p-1:0]     rd_data_i</pre>
<pre></pre>
<pre>   , input  [reg_addr_width_p-1:0] rs1_addr_i</pre>
<pre>   , output [dword_width_p-1:0]    rs1_data_o</pre>
<pre>   </pre>
<pre>   , input  [reg_addr_width_p-1:0] rs2_addr_i</pre>
<pre>   , output [dword_width_p-1:0]    rs2_data_o</pre>
<pre>   );</pre>
<pre>logic                        rs1_issue_v    , rs2_issue_v;</pre>
<pre>logic [dword_width_p-1:0]    rs1_reg_data   , rs2_reg_data;</pre>
<pre>logic [reg_addr_width_p-1:0] rs1_addr_r     , rs2_addr_r,      rd_addr_r;</pre>
<pre>logic [reg_addr_width_p-1:0] rs1_reread_addr, rs2_reread_addr;</pre>
<pre>logic [dword_width_p-1:0]    rd_data_r;</pre>
<pre></pre>
<pre>bsg_mem_2r1w_sync </pre>
<pre> #(.width_p(dword_width_p), .els_p(rf_els_lp))</pre>
<pre> rf</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>   ,.w_addr_i(rd_addr_i)</pre>
<pre>   ,.w_data_i(rd_data_i)</pre>
<pre></pre>
<pre>   ,.r0_addr_i(rs1_reread_addr)</pre>
<pre>   ,.r0_data_o(rs1_reg_data)</pre>
<pre></pre>
<pre>   ,.r1_addr_i(rs2_reread_addr)</pre>
<pre>   ,.r1_data_o(rs2_reg_data)</pre>
<pre>   );</pre>
<pre> #(.width_p(2*reg_addr_width_p))</pre>
<pre> rs1_addr</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre>   ,.en_i(rs1_issue_v | rs2_issue_v)</pre>
<pre></pre>
<pre>   ,.data_o({rs1_addr_r, rs2_addr_r})</pre>
<pre>   );</pre>
<pre>wire fwd_rs1  = rd_w_v_i & (rd_addr_i == rs1_reread_addr);</pre>
<pre>wire fwd_rs2  = rd_w_v_i & (rd_addr_i == rs2_reread_addr);</pre>
<pre>wire zero_rs1 = (rs1_reread_addr == '0);</pre>
<pre>wire zero_rs2 = (rs2_reread_addr == '0);</pre>
<pre>bsg_dff</pre>
<pre> #(.width_p(4+dword_width_p))</pre>
<pre> rw_fwd_reg</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.data_i({zero_rs1, zero_rs2, fwd_rs1, fwd_rs2, rd_data_i})</pre>
<pre>   ,.data_o({zero_rs1_r, zero_rs2_r, fwd_rs1_r, fwd_rs2_r, rd_data_r})</pre>
<pre>   );</pre>
<pre>always_comb </pre>
<pre>  begin</pre>
<pre>    // Instruction has been issued, don't bother reading if the register data is not used</pre>
<pre>    rs1_issue_v = (issue_v_i & rs1_r_v_i);</pre>
<pre>    rs2_issue_v = (issue_v_i & rs2_r_v_i);</pre>
<pre>  </pre>
<pre>    // We need to read from the regfile if we have issued a new request, or if we have stalled</pre>
<pre>    rs1_read_v = (rs1_issue_v | ~dispatch_v_i) & ~fwd_rs1;</pre>
<pre>    rs2_read_v = (rs2_issue_v | ~dispatch_v_i) & ~fwd_rs2;</pre>
<pre>  </pre>
<pre>    // If we have issued a new instruction, use input address to read, </pre>
<pre>    //   else use last request address to read</pre>
<pre>    rs1_reread_addr = rs1_issue_v ? rs1_addr_i : rs1_addr_r;</pre>
<pre>    rs2_reread_addr = rs2_issue_v ? rs2_addr_i : rs2_addr_r;</pre>
<pre>end</pre>
<pre>assign rs1_data_o = zero_rs1_r ? '0 : fwd_rs1_r ? rd_data_r : rs1_reg_data;</pre>
<pre>assign rs2_data_o = zero_rs2_r ? '0 : fwd_rs2_r ? rd_data_r : rs2_reg_data;</pre>
<pre></pre>
<pre>endmodule </pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<h3>./bp_be/src/v/bp_be_calculator/bp_be_pipe_fp.v</h3>
<pre>module bp_be_pipe_fp</pre>
<pre>   localparam decode_width_lp      = `bp_be_decode_width</pre>
<pre>   )</pre>
<pre>   , input                          reset_i</pre>
<pre></pre>
<pre>   , input                          kill_ex2_i</pre>
<pre>   , input                          kill_ex3_i</pre>
<pre>   , input                          kill_ex4_i</pre>
<pre></pre>
<pre>   , input [reg_data_width_lp-1:0]  rs1_i</pre>
<pre>   , input [reg_data_width_lp-1:0]  rs2_i</pre>
<pre></pre>
<pre>   );</pre>
<pre></pre>
<pre></pre>
<pre>wire unused1 = reset_i;</pre>
<pre>wire unused2 = kill_ex1_i;</pre>
<pre>wire unused3 = kill_ex2_i;</pre>
<pre>wire unused4 = kill_ex3_i;</pre>
<pre>wire unused5 = kill_ex4_i;</pre>
<pre></pre>
<pre>wire [reg_data_width_lp-1:0]  unused7 = rs1_i;</pre>
<pre>wire [reg_data_width_lp-1:0]  unused8 = rs2_i;</pre>
<pre></pre>
<pre></pre>
<pre>  // Fires immediately after reset</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<h3>./bp_be/src/v/bp_be_calculator/bp_be_pipe_int.v</h3>
<pre>module bp_be_pipe_int </pre>
<pre> #(parameter vaddr_width_p = "inv"</pre>
<pre>   , localparam decode_width_lp        = `bp_be_decode_width</pre>
<pre>   , localparam exception_width_lp   = `bp_be_exception_width</pre>
<pre>   , localparam reg_addr_width_lp = rv64_reg_addr_width_gp</pre>
<pre>   )</pre>
<pre>   , input                          reset_i</pre>
<pre></pre>
<pre></pre>
<pre>   , input [vaddr_width_p-1:0]      pc_i</pre>
<pre>   , input [reg_data_width_lp-1:0]  rs1_i</pre>
<pre>   , input [reg_data_width_lp-1:0]  rs2_i</pre>
<pre>   , input [reg_data_width_lp-1:0]  imm_i</pre>
<pre></pre>
<pre></pre>
<pre>   );</pre>
<pre></pre>
<pre></pre>
<pre>wire unused1 = reset_i;</pre>
<pre>wire unused2 = kill_ex1_i;</pre>
<pre></pre>
<pre></pre>
<pre>logic [reg_data_width_lp-1:0] pc_plus4;</pre>
<pre>logic [reg_data_width_lp-1:0] data_lo;</pre>
<pre></pre>
<pre> alu</pre>
<pre style="background-color: #FF0000;">  (.src1_i(src1)</pre>
<pre>   ,.src2_i(src2)</pre>
<pre>   ,.op_i(decode.fu_op)</pre>
<pre>   ,.opw_v_i(decode.opw_v)</pre>
<pre></pre>
<pre>   );</pre>
<pre>  begin </pre>
<pre>    src1     = decode.src1_sel  ? pc_sext_li : rs1_i;</pre>
<pre>    src2     = decode.src2_sel  ? imm_i      : rs2_i;</pre>
<pre>    baddr    = decode.baddr_sel ? src1       : pc_sext_li;</pre>
<pre>    pc_plus4 = pc_sext_li + reg_data_width_lp'(4);</pre>
<pre>  end</pre>
<pre>                  ? pc_plus4</pre>
<pre>                  : alu_result;</pre>
<pre>assign br_tgt_o = baddr + imm_i;</pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<h3>./bp_be/src/v/bp_be_calculator/bp_be_pipe_mem.v</h3>
<pre> * Description:</pre>
<pre> * Parameters:</pre>
<pre> *   vaddr_width_p    -</pre>
<pre> *</pre>
<pre style="background-color: #FF0000;"> * Inputs:</pre>
<pre> *   reset_i          -</pre>
<pre> *   decode_i         - All of the pipeline control information needed for a dispatched instruction</pre>
<pre> *   pc_i             - PC of the dispatched instruction</pre>
<pre> *   rs1_i            - Source register data for the dispatched instruction</pre>
<pre style="background-color: #FF0000;"> *   rs2_i            - Source register data for the dispatched instruction</pre>
<pre> *   exc_i            - Exception information for a dispatched instruction</pre>
<pre> *   mem_resp_i       - Load / store response from the MMU.</pre>
<pre> *   mem_resp_v_i     - 'ready-then-valid' interface</pre>
<pre> *   mem_resp_ready_o   - </pre>
<pre style="background-color: #FF0000;"></pre>
<pre> * Outputs:</pre>
<pre> *   mmu_cmd_v_o      -  'ready-then-valid' interface</pre>
<pre> *   mmu_cmd_ready_i  - </pre>
<pre> * </pre>
<pre style="background-color: #FF0000;"> *   data_o         - The calculated result of a load </pre>
<pre>module bp_be_pipe_mem </pre>
<pre>   `declare_bp_proc_params(cfg_p)</pre>
<pre style="background-color: #FF0000;">   // Generated parameters</pre>
<pre>   , localparam decode_width_lp        = `bp_be_decode_width</pre>
<pre>   , localparam exception_width_lp     = `bp_be_exception_width</pre>
<pre>   , localparam mmu_cmd_width_lp       = `bp_be_mmu_cmd_width(vaddr_width_p)</pre>
<pre>   , localparam csr_cmd_width_lp       = `bp_be_csr_cmd_width</pre>
<pre>   , localparam mem_resp_width_lp      = `bp_be_mem_resp_width(vaddr_width_p)</pre>
<pre>   )</pre>
<pre>   , input                                reset_i</pre>
<pre></pre>
<pre>   , input                                kill_ex2_i</pre>
<pre>   , input                                kill_ex3_i</pre>
<pre></pre>
<pre>   , input [vaddr_width_p-1:0]            pc_i</pre>
<pre>   , input [rv64_instr_width_gp-1:0]      instr_i</pre>
<pre>   , input [reg_data_width_lp-1:0]        rs1_i</pre>
<pre>   , input [reg_data_width_lp-1:0]        rs2_i</pre>
<pre>   , input [reg_data_width_lp-1:0]        imm_i</pre>
<pre></pre>
<pre>   , output                               mmu_cmd_v_o</pre>
<pre>   , input                                mmu_cmd_ready_i</pre>
<pre></pre>
<pre>   , output                               csr_cmd_v_o</pre>
<pre>   , input                                csr_cmd_ready_i</pre>
<pre></pre>
<pre>   , input                                mem_resp_v_i</pre>
<pre>   , output                               mem_resp_ready_o</pre>
<pre></pre>
<pre>   , output logic                              miss_v_o</pre>
<pre>   , output logic [reg_data_width_lp-1:0]      data_o</pre>
<pre>   );</pre>
<pre></pre>
<pre>`declare_bp_be_mmu_structs(vaddr_width_p, ppn_width_p, lce_sets_p, cce_block_width_p/8)</pre>
<pre></pre>
<pre>// Cast input and output ports </pre>
<pre>bp_be_mmu_cmd_s   mem1_cmd, mem3_cmd_li, mem3_cmd_lo, mem3_cmd;</pre>
<pre>bp_be_csr_cmd_s   csr_cmd_li, csr_cmd_lo;</pre>
<pre>bp_be_mem_resp_s  mem_resp;</pre>
<pre>rv64_instr_s      instr;</pre>
<pre></pre>
<pre>assign decode = decode_i;</pre>
<pre>assign mem_resp = mem_resp_i;</pre>
<pre>assign csr_cmd_o = csr_cmd_lo;</pre>
<pre>assign instr = instr_i;</pre>
<pre></pre>
<pre>// Suppress unused signal warnings</pre>
<pre>wire unused0 = kill_ex2_i;</pre>
<pre></pre>
<pre>logic csr_cmd_v_lo, mem1_cmd_v;</pre>
<pre></pre>
<pre>// Suppress unused signal warnings</pre>
<pre>wire unused2 = mmu_cmd_ready_i;</pre>
<pre>wire unused3 = csr_cmd_ready_i;</pre>
<pre></pre>
<pre>assign data_o = mem_resp.data;</pre>
<pre></pre>
<pre>bsg_shift_reg</pre>
<pre> #(.width_p(csr_cmd_width_lp)</pre>
<pre>   ,.stages_p(2)</pre>
<pre>   )</pre>
<pre> csr_shift_reg</pre>
<pre>  (.clk(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>   ,.valid_i(decode.csr_v)</pre>
<pre>   ,.data_i(csr_cmd_li)</pre>
<pre></pre>
<pre>   ,.valid_o(csr_cmd_v_lo)</pre>
<pre>   ,.data_o(csr_cmd_lo)</pre>
<pre>   );</pre>
<pre></pre>
<pre>logic [reg_data_width_lp-1:0] offset;</pre>
<pre></pre>
<pre></pre>
<pre>assign mem1_cmd_v = decode.mem_v & ~kill_ex1_i;</pre>
<pre>always_comb </pre>
<pre>  begin</pre>
<pre>    mem1_cmd.mem_op   = decode.fu_op;</pre>
<pre>    mem1_cmd.data     = rs2_i;</pre>
<pre>    mem1_cmd.vaddr    = (mem1_cmd.mem_op == e_itlb_fill) ? pc_i : (rs1_i + offset);</pre>
<pre>  end</pre>
<pre>assign csr_cmd_v_o = csr_cmd_v_lo & ~kill_ex3_i;</pre>
<pre>wire csr_imm_op = (decode.fu_op == e_csrrwi) </pre>
<pre>                  | (decode.fu_op == e_csrrsi) </pre>
<pre>                  | (decode.fu_op == e_csrrci);</pre>
<pre>always_comb</pre>
<pre>  begin</pre>
<pre>    csr_cmd_li.csr_op   = decode.fu_op;</pre>
<pre>    csr_cmd_li.csr_addr = instr.fields.itype.imm12;</pre>
<pre>    csr_cmd_li.data     = csr_imm_op ? imm_i : rs1_i;</pre>
<pre>  end</pre>
<pre>// Output results of memory op</pre>
<pre>assign exc_v_o            = mem_resp_v_i & mem_resp.exc_v;</pre>
<pre>assign miss_v_o           = mem_resp_v_i & mem_resp.miss_v;</pre>
<pre>assign mem_resp_ready_o   = 1'b1;</pre>
<pre></pre>
<pre>assign mmu_cmd_o = mem1_cmd;</pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<h3>./bp_be/src/v/bp_be_calculator/bp_be_pipe_mul.v</h3>
<pre>module bp_be_pipe_mul</pre>
<pre>   localparam decode_width_lp      = `bp_be_decode_width</pre>
<pre>   )</pre>
<pre>   , input                          reset_i</pre>
<pre></pre>
<pre>   , input                          kill_ex2_i</pre>
<pre></pre>
<pre>   , input [reg_data_width_lp-1:0]  rs1_i</pre>
<pre>   , input [reg_data_width_lp-1:0]  rs2_i</pre>
<pre></pre>
<pre>   );</pre>
<pre></pre>
<pre></pre>
<pre>wire unused1 = reset_i;</pre>
<pre>wire unused2 = kill_ex1_i;</pre>
<pre>wire unused3 = kill_ex2_i;</pre>
<pre></pre>
<pre>wire [reg_data_width_lp-1:0]  unused5 = rs1_i;</pre>
<pre>wire [reg_data_width_lp-1:0]  unused6 = rs2_i;</pre>
<pre></pre>
<pre></pre>
<pre>  begin : runtime_assertions</pre>
<pre>    // Fires immediately after reset</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<h3>./bp_be/src/v/bp_be_mem/bp_be_dcache/bp_be_dcache_lce.v</h3>
<pre> *</pre>
<pre> *      This module handles coherency protocols with CCE, acting as LCE.</pre>
<pre> *    This involves reading or writing data_mem, tag_mem, and stat_mem,</pre>
<pre> *      LCE sends miss request to CCE through lce_cce_req. load_miss_i and</pre>
<pre> *    store_miss_i indicates that miss occured in the fast path of data</pre>
<pre> *    cache. cache_miss_o is raised immediately once load_miss_i or</pre>
<pre> *    store_miss_i is raised. cache_miss_o remains asserted until the miss</pre>
<pre> *    is resolved.</pre>
<pre> *     </pre>
<pre> *      LCE could be asked to writeback locally-cached data via lce_cce_data_resp.</pre>
<pre> *    Only lce_cmd modules uses this channel.</pre>
<pre> *</pre>
<pre> *      LCE could be asked by CCE to write data to data_mem. When data_cmd</pre>
<pre> *    is processed, it raises cce_data_received signal to lce_req module.</pre>
<pre> *</pre>
<pre> *      LCE could receive data transfer from another LCE or could be commanded</pre>
<pre>module bp_be_dcache_lce</pre>
<pre>  import bp_be_dcache_pkg::*;</pre>
<pre> #(parameter bp_cfg_e cfg_p = e_bp_inv_cfg</pre>
<pre>   `declare_bp_proc_params(cfg_p)</pre>
<pre>    </pre>
<pre>    , parameter timeout_max_limit_p=4</pre>
<pre>   </pre>
<pre>    , localparam data_mask_width_lp=(dword_width_p>>3)</pre>
<pre>    , localparam byte_offset_width_lp=`BSG_SAFE_CLOG2(dword_width_p>>3)</pre>
<pre>    , localparam word_offset_width_lp=`BSG_SAFE_CLOG2(block_size_in_words_lp)</pre>
<pre>    , localparam block_offset_width_lp=(word_offset_width_lp+byte_offset_width_lp)</pre>
<pre>    , localparam index_width_lp=`BSG_SAFE_CLOG2(lce_sets_p)</pre>
<pre>    , localparam tag_width_lp=(paddr_width_p-index_width_lp-block_offset_width_lp)</pre>
<pre>    , localparam way_id_width_lp=`BSG_SAFE_CLOG2(lce_assoc_p)</pre>
<pre>    , localparam lce_id_width_lp=`BSG_SAFE_CLOG2(num_lce_p)</pre>
<pre>  </pre>
<pre>      `bp_be_dcache_lce_data_mem_pkt_width(lce_sets_p, lce_assoc_p, cce_block_width_p)</pre>
<pre>      `bp_be_dcache_lce_tag_mem_pkt_width(lce_sets_p, lce_assoc_p, tag_width_lp)</pre>
<pre>    , localparam dcache_lce_stat_mem_pkt_width_lp=</pre>
<pre>      `bp_be_dcache_lce_stat_mem_pkt_width(lce_sets_p, lce_assoc_p)</pre>
<pre>  )</pre>
<pre>  (</pre>
<pre>    input clk_i</pre>
<pre>    , input reset_i</pre>
<pre>    , input freeze_i</pre>
<pre></pre>
<pre>    // Config channel</pre>
<pre>    , input [cfg_addr_width_p-1:0] cfg_addr_i</pre>
<pre>    , input [cfg_data_width_p-1:0] cfg_data_i</pre>
<pre>    , input [lce_id_width_lp-1:0] lce_id_i</pre>
<pre></pre>
<pre>    , output logic cache_miss_o</pre>
<pre></pre>
<pre>    , input load_miss_i</pre>
<pre>    , input store_miss_i</pre>
<pre>    , input lr_miss_i</pre>
<pre>    , input uncached_load_req_i</pre>
<pre>    , input uncached_store_req_i</pre>
<pre></pre>
<pre>    , input [paddr_width_p-1:0] miss_addr_i</pre>
<pre>    , input [dword_width_p-1:0] store_data_i</pre>
<pre>    , input [1:0] size_op_i</pre>
<pre></pre>
<pre>    // data_mem</pre>
<pre>    , output logic [dcache_lce_data_mem_pkt_width_lp-1:0] data_mem_pkt_o</pre>
<pre>    , input [cce_block_width_p-1:0] data_mem_data_i</pre>
<pre>    , input data_mem_pkt_yumi_i</pre>
<pre>  </pre>
<pre>    // tag_mem</pre>
<pre>    , output logic tag_mem_pkt_v_o</pre>
<pre>    , output logic [dcache_lce_tag_mem_pkt_width_lp-1:0] tag_mem_pkt_o</pre>
<pre>    , input tag_mem_pkt_yumi_i</pre>
<pre>    </pre>
<pre>    // stat_mem</pre>
<pre>    , output logic stat_mem_pkt_v_o</pre>
<pre>    , output logic [dcache_lce_stat_mem_pkt_width_lp-1:0] stat_mem_pkt_o</pre>
<pre>    , input [way_id_width_lp-1:0] lru_way_i</pre>
<pre>    , input [lce_assoc_p-1:0] dirty_i</pre>
<pre>    , input stat_mem_pkt_yumi_i</pre>
<pre></pre>
<pre>    // LCE-CCE interface</pre>
<pre>    , output logic [lce_cce_req_width_lp-1:0] lce_req_o</pre>
<pre>    , output logic lce_req_v_o</pre>
<pre>    , input lce_req_ready_i</pre>
<pre></pre>
<pre>    , output logic [lce_cce_resp_width_lp-1:0] lce_resp_o</pre>
<pre>    , output logic lce_resp_v_o</pre>
<pre>    , input lce_resp_ready_i</pre>
<pre></pre>
<pre>    // CCE-LCE interface</pre>
<pre>    , input [lce_cmd_width_lp-1:0] lce_cmd_i</pre>
<pre>    , input lce_cmd_v_i</pre>
<pre>    , output logic lce_cmd_ready_o</pre>
<pre></pre>
<pre>    // LCE-LCE interface</pre>
<pre>    , output logic [lce_cmd_width_lp-1:0] lce_cmd_o</pre>
<pre>    , output logic lce_cmd_v_o</pre>
<pre>    , input lce_cmd_ready_i</pre>
<pre></pre>
<pre>    , output credits_full_o</pre>
<pre>    , output credits_empty_o</pre>
<pre></pre>
<pre>    // LCE Mode</pre>
<pre>    , output bp_be_dcache_lce_mode_e              lce_mode_o</pre>
<pre>  );</pre>
<pre></pre>
<pre>  // LCE Mode control</pre>
<pre>  bp_be_dcache_lce_mode_e lce_mode_r, lce_mode_n;</pre>
<pre>  assign lce_mode_o = lce_mode_r;</pre>
<pre></pre>
<pre>  // The LCE has a single config register, thus the unit is always ready. Writes should only</pre>
<pre>  // happen when reset_i is low and freeze_i is high. If these conditions are true, the LCE</pre>
<pre>  // simply snoops the config link and writes the mode register when targeted by a valid write</pre>
<pre>  // command on the link.</pre>
<pre style="background-color: #FF0000;">  logic lce_mode_w_v, lce_mode_addr_v;</pre>
<pre>  assign lce_mode_addr_v = (cfg_addr_i == bp_cfg_reg_dcache_mode_gp);</pre>
<pre>  assign lce_mode_w_v = freeze_i & cfg_w_v_i & lce_mode_addr_v;</pre>
<pre>  assign lce_mode_n = bp_be_dcache_lce_mode_e'(cfg_data_i[0+:`bp_be_dcache_lce_mode_bits]);</pre>
<pre></pre>
<pre>  always_ff @(posedge clk_i) begin</pre>
<pre>    if (reset_i) begin</pre>
<pre>      lce_mode_r <= e_dcache_lce_mode_uncached;</pre>
<pre>    end else begin</pre>
<pre>      if (lce_mode_w_v) begin</pre>
<pre>        lce_mode_r <= lce_mode_n;</pre>
<pre>      end</pre>
<pre>    end</pre>
<pre style="background-color: #FF0000;">  `declare_bp_lce_cce_if(num_cce_p, num_lce_p, paddr_width_p, lce_assoc_p, dword_width_p, cce_block_width_p)</pre>
<pre style="background-color: #FF0000;">  `declare_bp_be_dcache_lce_data_mem_pkt_s(lce_sets_p, lce_assoc_p, cce_block_width_p);</pre>
<pre style="background-color: #FF0000;">  `declare_bp_be_dcache_lce_tag_mem_pkt_s(lce_sets_p, lce_assoc_p, tag_width_lp);</pre>
<pre style="background-color: #FF0000;">  `declare_bp_be_dcache_lce_stat_mem_pkt_s(lce_sets_p, lce_assoc_p);</pre>
<pre>  bp_lce_cce_resp_s lce_resp;</pre>
<pre>  bp_lce_cmd_s lce_cmd_in, lce_cmd_out;</pre>
<pre></pre>
<pre>  bp_be_dcache_lce_tag_mem_pkt_s tag_mem_pkt;</pre>
<pre>  bp_be_dcache_lce_stat_mem_pkt_s stat_mem_pkt;</pre>
<pre></pre>
<pre>  assign lce_resp_o = lce_resp;</pre>
<pre>  assign lce_cmd_in = lce_cmd_i;</pre>
<pre>  assign lce_cmd_o = lce_cmd_out;</pre>
<pre></pre>
<pre>  assign tag_mem_pkt_o = tag_mem_pkt;</pre>
<pre>  assign stat_mem_pkt_o = stat_mem_pkt;</pre>
<pre></pre>
<pre>  logic lce_req_uncached_store_lo;</pre>
<pre>  logic [`BSG_WIDTH(mem_noc_max_credits_p)-1:0] credit_count_lo;</pre>
<pre>  logic credit_v_li, credit_ready_li;</pre>
<pre>  assign credit_v_li = lce_req_uncached_store_lo & lce_req_v_o & lce_req_ready_i;</pre>
<pre>  assign credit_ready_li = lce_req_ready_i;</pre>
<pre>  bsg_flow_counter</pre>
<pre>    #(.els_p(mem_noc_max_credits_p))</pre>
<pre>    uncached_store_counter</pre>
<pre style="background-color: #FF0000;">      (.clk_i(clk_i)</pre>
<pre>      ,.reset_i(reset_i)</pre>
<pre>      // incremenent, when uncached store req is sent on LCE REQ</pre>
<pre>      ,.ready_i(credit_ready_li)</pre>
<pre>      // decrement, when LCE CMD processes UC_ST_DONE_CMD</pre>
<pre>      ,.count_o(credit_count_lo)</pre>
<pre>      );</pre>
<pre>  assign credits_empty_o = (credit_count_lo == 0);</pre>
<pre></pre>
<pre>  logic uncached_data_received;</pre>
<pre>  logic set_tag_received;</pre>
<pre>  logic set_tag_wakeup_received;</pre>
<pre></pre>
<pre>  logic lce_req_to_lce_resp_v_lo;</pre>
<pre>  logic lce_req_to_lce_resp_yumi_li;</pre>
<pre></pre>
<pre></pre>
<pre>    #(.dword_width_p(dword_width_p)</pre>
<pre>      ,.paddr_width_p(paddr_width_p)</pre>
<pre>      ,.num_cce_p(num_cce_p)</pre>
<pre>      ,.num_lce_p(num_lce_p)</pre>
<pre>      ,.ways_p(lce_assoc_p)</pre>
<pre>      ,.cce_block_width_p(cce_block_width_p)</pre>
<pre>      )</pre>
<pre style="background-color: #FF0000;">      (.clk_i(clk_i)</pre>
<pre>      ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>  </pre>
<pre>      ,.store_miss_i(store_miss_i)</pre>
<pre>      ,.lr_miss_i(lr_miss_i)</pre>
<pre>      ,.uncached_load_req_i(uncached_load_req_i)</pre>
<pre>      ,.uncached_store_req_i(uncached_store_req_i)</pre>
<pre></pre>
<pre>      ,.lru_way_i(lru_way_i)</pre>
<pre>      ,.dirty_i(dirty_i)</pre>
<pre>      ,.store_data_i(store_data_i)</pre>
<pre>      ,.size_op_i(size_op_i)</pre>
<pre></pre>
<pre>      ,.miss_addr_o(miss_addr_lo)</pre>
<pre></pre>
<pre>      ,.uncached_data_received_i(uncached_data_received)</pre>
<pre>      ,.set_tag_received_i(set_tag_received)</pre>
<pre>      ,.set_tag_wakeup_received_i(set_tag_wakeup_received)</pre>
<pre></pre>
<pre>      ,.lce_req_o(lce_req)</pre>
<pre>      ,.lce_req_v_o(lce_req_v_o)</pre>
<pre>      ,.lce_req_ready_i(lce_req_ready_i)</pre>
<pre></pre>
<pre>      ,.lce_resp_v_o(lce_req_to_lce_resp_v_lo)</pre>
<pre>      ,.lce_resp_yumi_i(lce_req_to_lce_resp_yumi_li)</pre>
<pre></pre>
<pre>      );</pre>
<pre></pre>
<pre>  logic lce_cmd_to_lce_resp_v_lo;</pre>
<pre>  logic lce_cmd_to_lce_resp_yumi_li;</pre>
<pre></pre>
<pre>    #(.num_cce_p(num_cce_p)</pre>
<pre>      ,.num_lce_p(num_lce_p)</pre>
<pre>      ,.paddr_width_p(paddr_width_p)</pre>
<pre>      ,.lce_data_width_p(cce_block_width_p)</pre>
<pre>      ,.ways_p(lce_assoc_p)</pre>
<pre>      ,.sets_p(lce_sets_p)</pre>
<pre>      ,.data_width_p(dword_width_p)</pre>
<pre>      )</pre>
<pre style="background-color: #FF0000;">      (.clk_i(clk_i)</pre>
<pre>      ,.reset_i(reset_i)</pre>
<pre>      ,.freeze_i(freeze_i)</pre>
<pre></pre>
<pre>      ,.lce_mode_i(lce_mode_r)</pre>
<pre></pre>
<pre></pre>
<pre>      ,.set_tag_received_o(set_tag_received)</pre>
<pre>      ,.set_tag_wakeup_received_o(set_tag_wakeup_received)</pre>
<pre>      ,.uncached_store_done_received_o(uncached_store_done_received)</pre>
<pre>      ,.cce_data_received_o(cce_data_received)</pre>
<pre>      ,.uncached_data_received_o(uncached_data_received)</pre>
<pre></pre>
<pre style="background-color: #FF0000;">      ,.lce_cmd_i(lce_cmd_in)</pre>
<pre>      ,.lce_cmd_v_i(lce_cmd_v_i)</pre>
<pre>      ,.lce_cmd_ready_o(lce_cmd_ready_o)</pre>
<pre></pre>
<pre style="background-color: #FF0000;">      ,.lce_resp_o(lce_cmd_to_lce_resp_lo)</pre>
<pre>      ,.lce_resp_v_o(lce_cmd_to_lce_resp_v_lo)</pre>
<pre>      ,.lce_resp_yumi_i(lce_cmd_to_lce_resp_yumi_li)</pre>
<pre></pre>
<pre>      ,.lce_cmd_v_o(lce_cmd_v_o)</pre>
<pre>      ,.lce_cmd_ready_i(lce_cmd_ready_i)</pre>
<pre></pre>
<pre>      ,.data_mem_pkt_v_o(data_mem_pkt_v_o)</pre>
<pre>      ,.data_mem_pkt_yumi_i(data_mem_pkt_yumi_i)</pre>
<pre>      ,.data_mem_data_i(data_mem_data_i)</pre>
<pre></pre>
<pre style="background-color: #FF0000;">      ,.tag_mem_pkt_o(tag_mem_pkt)</pre>
<pre>      ,.tag_mem_pkt_v_o(tag_mem_pkt_v_o)</pre>
<pre>      ,.tag_mem_pkt_yumi_i(tag_mem_pkt_yumi_i)</pre>
<pre></pre>
<pre>      ,.stat_mem_pkt_v_o(stat_mem_pkt_v_o)</pre>
<pre>      ,.stat_mem_pkt_yumi_i(stat_mem_pkt_yumi_i)</pre>
<pre>      ,.dirty_i(dirty_i)</pre>
<pre>      );</pre>
<pre style="background-color: #FF0000;">  // LCE_CCE_resp arbiter</pre>
<pre>    lce_req_to_lce_resp_yumi_li = 1'b0;</pre>
<pre>    lce_cmd_to_lce_resp_yumi_li = 1'b0;</pre>
<pre></pre>
<pre>      lce_resp_v_o = 1'b1;</pre>
<pre>      lce_resp = lce_req_to_lce_resp_lo;</pre>
<pre>      lce_req_to_lce_resp_yumi_li = lce_resp_ready_i;</pre>
<pre>    end</pre>
<pre>      lce_resp_v_o = lce_cmd_to_lce_resp_v_lo;</pre>
<pre>      lce_resp = lce_cmd_to_lce_resp_lo;</pre>
<pre>      lce_cmd_to_lce_resp_yumi_li = lce_cmd_to_lce_resp_v_lo & lce_resp_ready_i;</pre>
<pre>    end</pre>
<pre>  logic timeout;</pre>
<pre></pre>
<pre>    if (timeout_count_r == timeout_max_limit_p) begin</pre>
<pre>      timeout = 1'b1;</pre>
<pre>      timeout_count_n = '0;</pre>
<pre>    end</pre>
<pre>      timeout = 1'b0;</pre>
<pre>      if (data_mem_pkt_v_o | tag_mem_pkt_v_o | stat_mem_pkt_v_o) begin</pre>
<pre>        timeout_count_n = (~data_mem_pkt_yumi_i & ~tag_mem_pkt_yumi_i & ~stat_mem_pkt_yumi_i)</pre>
<pre>          ? timeout_count_r + 1</pre>
<pre>          : '0;</pre>
<pre>      end</pre>
<pre>        timeout_count_n = '0;</pre>
<pre>      end </pre>
<pre>    if (reset_i) begin</pre>
<pre>      timeout_count_r <= '0;</pre>
<pre>    end</pre>
<pre>      timeout_count_r <= timeout_count_n;</pre>
<pre>    end</pre>
<pre>  assign lce_ready = (lce_mode_r == e_dcache_lce_mode_uncached) ? ~freeze_i : lce_sync_done_lo;</pre>
<pre>  assign ready_o = lce_ready & ~timeout & ~cache_miss_o; </pre>
<pre></pre>
<h3>./bp_fe/src/v/bp_fe_mem.v</h3>
<pre>module bp_fe_mem</pre>
<pre> import bp_common_aviary_pkg::*;</pre>
<pre style="background-color: #FF0000;"> import bp_fe_pkg::*;</pre>
<pre> #(parameter bp_cfg_e cfg_p = e_bp_inv_cfg</pre>
<pre>   `declare_bp_proc_params(cfg_p)</pre>
<pre>   `declare_bp_lce_cce_if_widths(num_cce_p, num_lce_p, paddr_width_p, lce_assoc_p, dword_width_p, cce_block_width_p)</pre>
<pre style="background-color: #FF0000;"></pre>
<pre>   , localparam mem_cmd_width_lp  = `bp_fe_mem_cmd_width(vaddr_width_p, vtag_width_p, ptag_width_p)</pre>
<pre>   , localparam mem_resp_width_lp = `bp_fe_mem_resp_width</pre>
<pre>   , localparam lce_id_width_lp = `BSG_SAFE_CLOG2(num_lce_p)</pre>
<pre>   )</pre>
<pre>   , input                                            reset_i</pre>
<pre>   , input                                            freeze_i</pre>
<pre></pre>
<pre>   , input [lce_id_width_lp-1:0]                      lce_id_i</pre>
<pre></pre>
<pre style="background-color: #FF0000;">   , input                                            cfg_w_v_i</pre>
<pre>   , input [cfg_addr_width_p-1:0]                     cfg_addr_i</pre>
<pre>   , input [cfg_data_width_p-1:0]                     cfg_data_i</pre>
<pre></pre>
<pre>   , input [mem_cmd_width_lp-1:0]                     mem_cmd_i</pre>
<pre>   , input                                            mem_cmd_v_i</pre>
<pre>   , output                                           mem_cmd_ready_o</pre>
<pre></pre>
<pre>   , input                                            mem_poison_i</pre>
<pre></pre>
<pre>   , output [mem_resp_width_lp-1:0]                   mem_resp_o</pre>
<pre>   , output                                           mem_resp_v_o</pre>
<pre>   , input                                            mem_resp_ready_i</pre>
<pre></pre>
<pre>   , output [lce_cce_req_width_lp-1:0]                lce_req_o</pre>
<pre>   , output                                           lce_req_v_o</pre>
<pre>   , input                                            lce_req_ready_i</pre>
<pre></pre>
<pre style="background-color: #FF0000;">   , input [lce_cmd_width_lp-1:0]                     lce_cmd_i</pre>
<pre>   , input                                            lce_cmd_v_i</pre>
<pre>   , output                                           lce_cmd_ready_o</pre>
<pre></pre>
<pre>   , output [lce_cmd_width_lp-1:0]                    lce_cmd_o</pre>
<pre>   , output                                           lce_cmd_v_o</pre>
<pre>   , input                                            lce_cmd_ready_i</pre>
<pre></pre>
<pre>   , output [lce_cce_resp_width_lp-1:0]               lce_resp_o</pre>
<pre>   , output                                           lce_resp_v_o</pre>
<pre>   , input                                            lce_resp_ready_i</pre>
<pre>   );</pre>
<pre></pre>
<pre>`declare_bp_fe_mem_structs(vaddr_width_p, lce_sets_p, cce_block_width_p, vtag_width_p, ptag_width_p)</pre>
<pre>bp_fe_mem_cmd_s  mem_cmd_cast_i;</pre>
<pre>bp_fe_mem_resp_s mem_resp_cast_o;</pre>
<pre></pre>
<pre>assign mem_cmd_cast_i = mem_cmd_i;</pre>
<pre>assign mem_resp_o     = mem_resp_cast_o;</pre>
<pre></pre>
<pre>logic itlb_ready_lo;</pre>
<pre></pre>
<pre>wire itlb_fence_v = mem_cmd_v_i & (mem_cmd_cast_i.op == e_fe_op_tlb_fence);</pre>
<pre>wire itlb_fill_v  = mem_cmd_v_i & (mem_cmd_cast_i.op == e_fe_op_tlb_fill);</pre>
<pre>wire fetch_v      = mem_cmd_v_i & (mem_cmd_cast_i.op == e_fe_op_fetch);</pre>
<pre></pre>
<pre>logic itlb_r_v_lo;</pre>
<pre>bp_tlb</pre>
<pre> #(.cfg_p(cfg_p), .tlb_els_p(itlb_els_p))</pre>
<pre> itlb</pre>
<pre>  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre>   ,.flush_i(itlb_fence_v)</pre>
<pre>	       </pre>
<pre>   ,.w_i(itlb_fill_v)</pre>
<pre>   ,.vtag_i(itlb_fill_v ? mem_cmd_cast_i.operands.fill.vtag : mem_cmd_cast_i.operands.fetch.vaddr.tag)</pre>
<pre>	 ,.entry_i(mem_cmd_cast_i.operands.fill.entry)</pre>
<pre>	   </pre>
<pre>   ,.entry_o(itlb_r_entry)</pre>
<pre></pre>
<pre style="background-color: #FF0000;">	 ,.miss_v_o(itlb_miss_lo)</pre>
<pre>	 ,.miss_vtag_o()</pre>
<pre>	 );</pre>
<pre>wire [ptag_width_p-1:0] ptag_li     = itlb_r_entry.ptag;</pre>
<pre>wire                    ptag_v_li   = itlb_r_v_lo;</pre>
<pre></pre>
<pre>logic                     icache_ready_lo;</pre>
<pre>logic [instr_width_p-1:0] icache_data_lo;</pre>
<pre>logic                     icache_data_v_lo;</pre>
<pre>bp_fe_icache </pre>
<pre> #(.cfg_p(cfg_p)) </pre>
<pre> icache</pre>
<pre>  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre>   ,.freeze_i(freeze_i)</pre>
<pre></pre>
<pre>   ,.lce_id_i(lce_id_i)</pre>
<pre></pre>
<pre>   ,.cfg_w_v_i(cfg_w_v_i)</pre>
<pre>   ,.cfg_addr_i(cfg_addr_i)</pre>
<pre>   ,.cfg_data_i(cfg_data_i)</pre>
<pre></pre>
<pre>   ,.vaddr_i(mem_cmd_cast_i.operands.fetch.vaddr)</pre>
<pre>   ,.vaddr_v_i(fetch_v)</pre>
<pre>   ,.vaddr_ready_o(icache_ready_lo)</pre>
<pre></pre>
<pre>   ,.uncached_i(uncached_li)</pre>
<pre>   ,.ptag_i(ptag_li)</pre>
<pre>   ,.ptag_v_i(ptag_v_li)</pre>
<pre>   ,.poison_tl_i(mem_poison_i)</pre>
<pre></pre>
<pre>   ,.data_o(icache_data_lo)</pre>
<pre>   ,.data_v_o(icache_data_v_lo)</pre>
<pre>   ,.instr_access_fault_o(instr_access_fault_lo)</pre>
<pre>   ,.cache_miss_o(icache_miss_lo)</pre>
<pre>  </pre>
<pre>   ,.lce_req_o(lce_req_o)</pre>
<pre>   ,.lce_req_v_o(lce_req_v_o)</pre>
<pre>   ,.lce_req_ready_i(lce_req_ready_i)</pre>
<pre>         </pre>
<pre>   ,.lce_cmd_i(lce_cmd_i)</pre>
<pre>   ,.lce_cmd_v_i(lce_cmd_v_i)</pre>
<pre>   ,.lce_cmd_ready_o(lce_cmd_ready_o)</pre>
<pre>         </pre>
<pre>   ,.lce_cmd_o(lce_cmd_o)</pre>
<pre>   ,.lce_cmd_v_o(lce_cmd_v_o)</pre>
<pre>   ,.lce_cmd_ready_i(lce_cmd_ready_i)</pre>
<pre></pre>
<pre>   ,.lce_resp_o(lce_resp_o)</pre>
<pre>   ,.lce_resp_v_o(lce_resp_v_o)</pre>
<pre>   ,.lce_resp_ready_i(lce_resp_ready_i)</pre>
<pre>   );</pre>
<pre></pre>
<pre>// We don't need to check itlb ready, because it is only ready when not writing.  </pre>
<pre>//   Reads and writes to itlb are mutually exclusive by construction</pre>
<pre>assign mem_cmd_ready_o = icache_ready_lo;</pre>
<pre></pre>
<pre>always_ff @(negedge clk_i)</pre>
<pre>  begin</pre>
<pre>    assert(mem_cmd_ready_o || ~mem_cmd_v_i);</pre>
<pre>  end</pre>
<pre>logic mem_cmd_v_r, mem_cmd_v_rr;</pre>
<pre>logic itlb_miss_r;</pre>
<pre>always_ff @(posedge clk_i)</pre>
<pre>  begin</pre>
<pre>    itlb_miss_r  <= itlb_miss_lo;</pre>
<pre>    mem_cmd_v_r  <= mem_cmd_v_i;</pre>
<pre>    mem_cmd_v_rr <= mem_cmd_v_r & ~mem_poison_i;</pre>
<pre>  end</pre>
<pre>assign mem_resp_v_o    = mem_resp_ready_i & mem_cmd_v_rr;</pre>
<pre>assign mem_resp_cast_o = '{instr_access_fault: instr_access_fault_lo</pre>
<pre>                           ,itlb_miss        : itlb_miss_r</pre>
<pre>                           ,icache_miss      : icache_miss_lo</pre>
<pre>                           ,data             : icache_data_lo</pre>
<pre>                           };</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./bp_fe/src/v/bp_fe_lce_req.v</h3>
<pre> *</pre>
<pre style="background-color: #FF0000;"> * Parameters:</pre>
<pre style="background-color: #FF0000;"> *</pre>
<pre style="background-color: #FF0000;"> * Inputs:</pre>
<pre>module bp_fe_lce_req</pre>
<pre>   `declare_bp_proc_params(cfg_p)</pre>
<pre>    , input reset_i</pre>
<pre></pre>
<pre> </pre>
<pre>    , input [paddr_width_p-1:0] miss_addr_i</pre>
<pre>    , input [way_id_width_lp-1:0] lru_way_i</pre>
<pre>    , input uncached_req_i</pre>
<pre></pre>
<pre>    , output logic [paddr_width_p-1:0] miss_addr_o</pre>
<pre>          </pre>
<pre>    , input uncached_data_received_i</pre>
<pre>    , input set_tag_received_i</pre>
<pre>    , input set_tag_wakeup_received_i</pre>
<pre>          </pre>
<pre>    , output logic lce_req_v_o</pre>
<pre>    , input lce_req_ready_i</pre>
<pre>          </pre>
<pre>    , output logic lce_resp_v_o</pre>
<pre>    , input lce_resp_yumi_i</pre>
<pre>   );</pre>
<pre style="background-color: #FF0000;">  `declare_bp_lce_cce_if(num_cce_p, num_lce_p, paddr_width_p, lce_assoc_p, dword_width_p, cce_block_width_p);</pre>
<pre>  </pre>
<pre>  bp_lce_cce_req_s lce_req;</pre>
<pre></pre>
<pre>  assign lce_req_o = lce_req;</pre>
<pre>  assign lce_resp_o = lce_resp;</pre>
<pre>  </pre>
<pre style="background-color: #FF0000;">  // states </pre>
<pre>  logic [paddr_width_p-1:0] miss_addr_r, miss_addr_n;</pre>
<pre>  logic cce_data_received_r, cce_data_received_n, cce_data_received;</pre>
<pre>  logic set_tag_received_r, set_tag_received_n, set_tag_received;</pre>
<pre>  logic [way_id_width_lp-1:0] lru_way_r, lru_way_n;</pre>
<pre>  logic lru_flopped_r, lru_flopped_n;</pre>
<pre></pre>
<pre>    // This part of the code is written using zero_r register to overcome a bug in vcs 2017</pre>
<pre>    logic zero_r;</pre>
<pre>      zero_r <= 1'b0; </pre>
<pre>    assign lce_resp.dst_id = zero_r;</pre>
<pre>    assign lce_req.dst_id = zero_r;</pre>
<pre>  end</pre>
<pre>    assign lce_resp.dst_id = miss_addr_r[block_offset_width_lp+:cce_id_width_lp];</pre>
<pre>    assign lce_req.dst_id = miss_addr_r[block_offset_width_lp+:cce_id_width_lp];</pre>
<pre>  end</pre>
<pre>  assign miss_addr_o = miss_addr_r;</pre>
<pre>   </pre>
<pre>  // lce_req fsm</pre>
<pre>  always_comb begin</pre>
<pre></pre>
<pre>    state_n               = state_r;</pre>
<pre>    miss_addr_n           = miss_addr_r;</pre>
<pre>    cce_data_received_n   = cce_data_received_r;</pre>
<pre>    set_tag_received_n             = set_tag_received_r;</pre>
<pre>    lru_way_n             = lru_way_r;</pre>
<pre>    lru_flopped_n         = lru_flopped_r;</pre>
<pre></pre>
<pre>    cce_data_received     = cce_data_received_r | cce_data_received_i;</pre>
<pre>    set_tag_received      = set_tag_received_r | set_tag_received_i;</pre>
<pre></pre>
<pre>    lce_req_v_o           = 1'b0;</pre>
<pre></pre>
<pre>    lce_req.dst_id        = (num_cce_p > 1) ? miss_addr_r[block_offset_width_lp+:cce_id_width_lp] : 1'b0;</pre>
<pre>    lce_req.src_id        = lce_id_i;</pre>
<pre>    lce_req.msg_type      = e_lce_req_type_rd;</pre>
<pre>    lce_req.addr          = miss_addr_r;</pre>
<pre></pre>
<pre>    lce_req.msg.req.non_exclusive = e_lce_req_non_excl;</pre>
<pre>    lce_req.msg.req.lru_dirty     = e_lce_req_lru_clean;</pre>
<pre>    lce_req.msg.req.lru_way_id    = lru_flopped_r</pre>
<pre>                                    ? lru_way_r</pre>
<pre>                                    : lru_way_i;</pre>
<pre>    lce_req.msg.req.pad    = '0;</pre>
<pre></pre>
<pre></pre>
<pre>    lce_resp_v_o          = 1'b0;</pre>
<pre></pre>
<pre>    lce_resp.dst_id       = (num_cce_p > 1) ? miss_addr_r[block_offset_width_lp+:cce_id_width_lp] : 1'b0;</pre>
<pre>    lce_resp.src_id       = lce_id_i;</pre>
<pre>    lce_resp.msg_type     = bp_lce_cce_resp_type_e'('0);</pre>
<pre>    lce_resp.addr         = miss_addr_r;</pre>
<pre>    lce_resp.data         = '0;</pre>
<pre>  </pre>
<pre>    cache_miss_o = 1'b0;</pre>
<pre>     </pre>
<pre>    case (state_r)</pre>
<pre>      e_lce_req_ready: begin</pre>
<pre>        if (miss_i) begin</pre>
<pre>          miss_addr_n = miss_addr_i;</pre>
<pre>          cce_data_received_n = 1'b0;</pre>
<pre>          set_tag_received_n = 1'b0;</pre>
<pre>          lru_flopped_n = 1'b0;</pre>
<pre>          state_n = e_lce_req_send_miss_req;</pre>
<pre>          cache_miss_o = 1'b1;</pre>
<pre>        end</pre>
<pre>          miss_addr_n = miss_addr_i;</pre>
<pre>          cce_data_received_n = 1'b0;</pre>
<pre>          set_tag_received_n = 1'b0;</pre>
<pre>          lru_flopped_n = 1'b0;</pre>
<pre>          cache_miss_o = 1'b1;</pre>
<pre>          state_n = e_lce_req_send_uncached_load_req;</pre>
<pre>        end</pre>
<pre>      e_lce_req_send_miss_req: begin</pre>
<pre>        lru_flopped_n = 1'b1;</pre>
<pre>        lru_way_n = lru_flopped_r ? lru_way_r : lru_way_i;</pre>
<pre></pre>
<pre>        cache_miss_o          = 1'b1;</pre>
<pre>        state_n = lce_req_ready_i</pre>
<pre>          ? e_lce_req_sleep </pre>
<pre>          : e_lce_req_send_miss_req;</pre>
<pre>      end</pre>
<pre>        lce_req_v_o = 1'b1;</pre>
<pre>        cache_miss_o = 1'b1;</pre>
<pre></pre>
<pre>        // TODO: this may need to change depending on what the LCE and CCE behavior spec is</pre>
<pre>                        , {byte_offset_width_lp{1'b0}}};</pre>
<pre>        lce_req.msg.uc_req.uc_size = e_lce_uc_req_8;</pre>
<pre>        lce_req.msg.uc_req.data = '0;</pre>
<pre></pre>
<pre>          ? e_lce_req_sleep </pre>
<pre>          : e_lce_req_send_uncached_load_req;</pre>
<pre>      end</pre>
<pre>        cce_data_received_n = cce_data_received_i ? 1'b1 : cce_data_received_r;</pre>
<pre>        set_tag_received_n = set_tag_received_i ? 1'b1 : set_tag_received_r;</pre>
<pre></pre>
<pre></pre>
<pre>          state_n = e_lce_req_ready;</pre>
<pre>        end</pre>
<pre>          state_n = e_lce_req_ready;</pre>
<pre>        end</pre>
<pre>          if (cce_data_received) begin</pre>
<pre>            state_n = e_lce_req_ready;</pre>
<pre>          end</pre>
<pre>            state_n = e_lce_req_sleep;</pre>
<pre>          end</pre>
<pre>          state_n = e_lce_req_sleep;</pre>
<pre>        end</pre>
<pre>        lce_resp_v_o = 1'b1;</pre>
<pre>        lce_resp.msg_type = e_lce_cce_coh_ack;</pre>
<pre>        cache_miss_o = 1'b1;</pre>
<pre>        state_n = lce_resp_yumi_i</pre>
<pre>          ? e_lce_req_ready</pre>
<pre>          : e_lce_req_send_coh_ack;</pre>
<pre>      end</pre>
<pre>        state_n = e_lce_req_ready;</pre>
<pre>      end</pre>
<pre>    if (reset_i) begin</pre>
<pre>      state_r              <= e_lce_req_ready;</pre>
<pre>      lru_flopped_r        <= 1'b0;</pre>
<pre>      cce_data_received_r  <= 1'b0;</pre>
<pre>      set_tag_received_r   <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      state_r              <= state_n;</pre>
<pre>      miss_addr_r          <= miss_addr_n;</pre>
<pre>      cce_data_received_r  <= cce_data_received_n;</pre>
<pre>      set_tag_received_r   <= set_tag_received_n;</pre>
<pre>      lru_way_r            <= lru_way_n;</pre>
<pre>      lru_flopped_r        <= lru_flopped_n;</pre>
<pre>    end</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./bp_be/src/v/bp_be_mem/bp_be_dcache/bp_be_dcache_lce_req.v</h3>
<pre>module bp_be_dcache_lce_req</pre>
<pre>  #(parameter dword_width_p="inv"</pre>
<pre>    , parameter paddr_width_p="inv"</pre>
<pre>    , parameter num_cce_p="inv"</pre>
<pre>    , parameter num_lce_p="inv"</pre>
<pre>    , parameter ways_p="inv"</pre>
<pre>    , parameter cce_block_width_p="inv"</pre>
<pre>    , localparam byte_offset_width_lp=`BSG_SAFE_CLOG2(dword_width_p>>3)</pre>
<pre>    , localparam word_offset_width_lp=`BSG_SAFE_CLOG2(block_size_in_words_lp)</pre>
<pre>    , localparam block_offset_width_lp=(word_offset_width_lp+byte_offset_width_lp)</pre>
<pre>    , localparam way_id_width_lp=`BSG_SAFE_CLOG2(ways_p)</pre>
<pre>    , localparam lce_id_width_lp=`BSG_SAFE_CLOG2(num_lce_p)</pre>
<pre>    , localparam cce_id_width_lp=`BSG_SAFE_CLOG2(num_cce_p)</pre>
<pre>  </pre>
<pre>      `bp_lce_cce_resp_width(num_cce_p, num_lce_p, paddr_width_p, cce_block_width_p)</pre>
<pre>    , input reset_i</pre>
<pre></pre>
<pre></pre>
<pre>    , input store_miss_i</pre>
<pre>    , input lr_miss_i</pre>
<pre>    , input [paddr_width_p-1:0] miss_addr_i</pre>
<pre>    , input [way_id_width_lp-1:0] lru_way_i</pre>
<pre>    , input [ways_p-1:0] dirty_i</pre>
<pre></pre>
<pre>    , input uncached_store_req_i</pre>
<pre>    , input [dword_width_p-1:0] store_data_i</pre>
<pre>    , input [1:0] size_op_i</pre>
<pre></pre>
<pre>    , output logic [paddr_width_p-1:0] miss_addr_o</pre>
<pre></pre>
<pre>    , input uncached_data_received_i</pre>
<pre>    , input set_tag_received_i</pre>
<pre>    , input set_tag_wakeup_received_i</pre>
<pre></pre>
<pre>    , output logic [lce_cce_req_width_lp-1:0] lce_req_o</pre>
<pre>    , output logic lce_req_v_o</pre>
<pre>    , input lce_req_ready_i</pre>
<pre></pre>
<pre style="background-color: #FF0000;">    , output logic [lce_cce_resp_width_lp-1:0] lce_resp_o</pre>
<pre>    , output logic lce_resp_v_o</pre>
<pre>    , input lce_resp_yumi_i</pre>
<pre></pre>
<pre>    , input credits_full_i</pre>
<pre>  );</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">  `declare_bp_lce_cce_if(num_cce_p, num_lce_p, paddr_width_p, ways_p, dword_width_p, cce_block_width_p)</pre>
<pre>  bp_lce_cce_resp_s lce_resp;</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre>  //</pre>
<pre>    e_READY</pre>
<pre>    ,e_SEND_CACHED_REQ</pre>
<pre>    ,e_SEND_UNCACHED_LOAD_REQ</pre>
<pre>    ,e_SEND_COH_ACK</pre>
<pre>    ,e_SLEEP</pre>
<pre>  } lce_req_state_e; </pre>
<pre></pre>
<pre>  lce_req_state_e state_r, state_n;</pre>
<pre>  logic load_not_store_r, load_not_store_n;</pre>
<pre>  logic [way_id_width_lp-1:0] lru_way_r, lru_way_n;</pre>
<pre>  logic dirty_r, dirty_n;</pre>
<pre>  logic [paddr_width_p-1:0] miss_addr_r, miss_addr_n;</pre>
<pre>  logic dirty_lru_flopped_r, dirty_lru_flopped_n;</pre>
<pre>  logic [1:0] size_op_r, size_op_n;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">  logic cce_data_received_r, cce_data_received_n, cce_data_received;</pre>
<pre>  logic set_tag_received_r, set_tag_received_n, set_tag_received;</pre>
<pre></pre>
<pre>  // comb logic</pre>
<pre>  //</pre>
<pre>  assign cce_data_received = cce_data_received_r | cce_data_received_i;</pre>
<pre>  assign set_tag_received = set_tag_received_r | set_tag_received_i;</pre>
<pre>  assign miss_addr_o = miss_addr_r;</pre>
<pre></pre>
<pre>    cache_miss_o = 1'b0;</pre>
<pre></pre>
<pre>    load_not_store_n = load_not_store_r;</pre>
<pre>    lru_way_n = lru_way_r;</pre>
<pre>    dirty_n = dirty_r;</pre>
<pre>    miss_addr_n = miss_addr_r;</pre>
<pre>    dirty_lru_flopped_n = dirty_lru_flopped_r;</pre>
<pre>    size_op_n = size_op_r;</pre>
<pre>    </pre>
<pre>    set_tag_received_n = set_tag_received_r;</pre>
<pre></pre>
<pre></pre>
<pre>    lce_req.dst_id = (num_cce_p > 1) ? miss_addr_r[block_offset_width_lp+:cce_id_width_lp] : 1'b0;</pre>
<pre>    lce_req.src_id = lce_id_i;</pre>
<pre>    lce_req.msg_type = e_lce_req_type_rd;</pre>
<pre>    lce_req.addr = miss_addr_r;</pre>
<pre>    lce_req.msg = '0;</pre>
<pre></pre>
<pre>    lce_resp_v_o = 1'b0;</pre>
<pre></pre>
<pre>    lce_resp.dst_id = (num_cce_p > 1) ? miss_addr_r[block_offset_width_lp+:cce_id_width_lp] : 1'b0;</pre>
<pre>    lce_resp.src_id = lce_id_i;</pre>
<pre>    lce_resp.msg_type = bp_lce_cce_resp_type_e'('0);</pre>
<pre>    lce_resp.addr = miss_addr_r;</pre>
<pre>    lce_resp.data = '0;</pre>
<pre></pre>
<pre></pre>
<pre>      // READY</pre>
<pre>      e_READY: begin</pre>
<pre>        if (load_miss_i | store_miss_i) begin</pre>
<pre>          miss_addr_n = miss_addr_i;</pre>
<pre>          dirty_lru_flopped_n = 1'b0;</pre>
<pre>          load_not_store_n = load_miss_i;</pre>
<pre>          cce_data_received_n = 1'b0;</pre>
<pre>          set_tag_received_n = 1'b0;</pre>
<pre></pre>
<pre>          state_n = e_SEND_CACHED_REQ;</pre>
<pre>        end</pre>
<pre>          miss_addr_n = miss_addr_i;</pre>
<pre>          dirty_lru_flopped_n = 1'b0;</pre>
<pre>          load_not_store_n = 1'b0; // We force a store miss to upgrade the block to exclusive</pre>
<pre>          cce_data_received_n = 1'b0;</pre>
<pre>          set_tag_received_n = 1'b0;</pre>
<pre></pre>
<pre>          state_n = e_SEND_CACHED_REQ;</pre>
<pre>        end</pre>
<pre>          miss_addr_n = miss_addr_i;</pre>
<pre>          size_op_n = bp_lce_cce_uc_req_size_e'(size_op_i);</pre>
<pre>          cce_data_received_n = 1'b0;</pre>
<pre>          set_tag_received_n = 1'b0;</pre>
<pre></pre>
<pre>          state_n = e_SEND_UNCACHED_LOAD_REQ;</pre>
<pre>        end</pre>
<pre>          lce_req_v_lo = ~credits_full_i & lce_req_ready_li;</pre>
<pre></pre>
<pre>          lce_req.msg.uc_req.uc_size = bp_lce_cce_uc_req_size_e'(size_op_i);</pre>
<pre>          lce_req.addr = miss_addr_i;</pre>
<pre>          lce_req.msg_type = e_lce_req_type_uc_wr;</pre>
<pre>          lce_req.src_id = lce_id_i;</pre>
<pre>          lce_req.dst_id = (num_cce_p > 1) ? miss_addr_i[block_offset_width_lp+:cce_id_width_lp] : 1'b0;</pre>
<pre></pre>
<pre>          state_n = e_READY;</pre>
<pre>        end</pre>
<pre>          cache_miss_o = 1'b0;</pre>
<pre>          state_n = e_READY;</pre>
<pre>        end</pre>
<pre>        dirty_lru_flopped_n = 1'b1;</pre>
<pre>        lru_way_n = dirty_lru_flopped_r ? lru_way_r : lru_way_i;</pre>
<pre>        dirty_n = dirty_lru_flopped_r ? dirty_r : dirty_i[lru_way_i];</pre>
<pre></pre>
<pre></pre>
<pre>        lce_req.msg.req.lru_dirty = dirty_lru_flopped_r</pre>
<pre>          ? bp_lce_cce_lru_dirty_e'(dirty_r)</pre>
<pre>          : bp_lce_cce_lru_dirty_e'(dirty_i[lru_way_i]);</pre>
<pre>        lce_req.msg.req.lru_way_id = dirty_lru_flopped_r</pre>
<pre>          ? lru_way_r</pre>
<pre>          : lru_way_i;</pre>
<pre>        lce_req.msg.req.non_exclusive = e_lce_req_excl;</pre>
<pre></pre>
<pre>        lce_req.msg_type = load_not_store_r </pre>
<pre>          ? e_lce_req_type_rd</pre>
<pre>          : e_lce_req_type_wr;</pre>
<pre>        lce_req.src_id = lce_id_i;</pre>
<pre>        lce_req.dst_id = (num_cce_p > 1) ? miss_addr_r[block_offset_width_lp+:cce_id_width_lp] : 1'b0;</pre>
<pre></pre>
<pre>        state_n = lce_req_ready_li</pre>
<pre>          ? e_SLEEP</pre>
<pre>          : e_SEND_CACHED_REQ;</pre>
<pre>      end</pre>
<pre>        lce_req_v_lo = 1'b1;</pre>
<pre></pre>
<pre>        lce_req.msg.uc_req.uc_size = bp_lce_cce_uc_req_size_e'(size_op_r);</pre>
<pre>        lce_req.addr = miss_addr_r;</pre>
<pre>        lce_req.msg_type = e_lce_req_type_uc_rd;</pre>
<pre>        lce_req.src_id = lce_id_i;</pre>
<pre>        lce_req.dst_id = (num_cce_p > 1) ? miss_addr_r[block_offset_width_lp+:cce_id_width_lp] : 1'b0;</pre>
<pre></pre>
<pre>        state_n = lce_req_ready_li</pre>
<pre>          ? e_SLEEP</pre>
<pre>          : e_SEND_UNCACHED_LOAD_REQ;</pre>
<pre>      end</pre>
<pre>        cache_miss_o = 1'b1;</pre>
<pre>        cce_data_received_n = cce_data_received_i ? 1'b1 : cce_data_received_r;</pre>
<pre>        set_tag_received_n = set_tag_received_i ? 1'b1 : set_tag_received_r;</pre>
<pre></pre>
<pre>          state_n = e_READY;</pre>
<pre>        end</pre>
<pre>          state_n = e_READY;</pre>
<pre>        end</pre>
<pre>          if (cce_data_received) begin</pre>
<pre>            state_n = e_READY;</pre>
<pre>          end</pre>
<pre>            state_n = e_SLEEP;</pre>
<pre>          end</pre>
<pre>          state_n = e_SLEEP;</pre>
<pre>        end</pre>
<pre>        lce_resp_v_o = 1'b1;</pre>
<pre>        lce_resp.msg_type = e_lce_cce_coh_ack;</pre>
<pre></pre>
<pre>        state_n = lce_resp_yumi_i</pre>
<pre>          ? e_READY</pre>
<pre>          : e_SEND_COH_ACK;</pre>
<pre>      end</pre>
<pre>        state_n = e_READY;</pre>
<pre>      end</pre>
<pre>   #(.width_p(lce_cce_req_width_lp+1))</pre>
<pre>   rv_adapter</pre>
<pre style="background-color: #FF0000;">    (.clk_i(clk_i)</pre>
<pre>     ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>     ,.v_i(lce_req_v_lo)</pre>
<pre>     ,.ready_o(lce_req_ready_li)</pre>
<pre></pre>
<pre style="background-color: #FF0000;">     ,.data_o({lce_req_uncached_store_o, lce_req_o})</pre>
<pre>     ,.v_o(lce_req_v_o)</pre>
<pre>     ,.yumi_i(lce_req_ready_i & lce_req_v_o)</pre>
<pre>     );</pre>
<pre style="background-color: #FF0000;">  // sequential</pre>
<pre style="background-color: #FF0000;">  //</pre>
<pre>    if (reset_i) begin</pre>
<pre>      state_r <= e_READY;</pre>
<pre>      dirty_lru_flopped_r <= 1'b0;</pre>
<pre>      cce_data_received_r <= 1'b0;</pre>
<pre>      set_tag_received_r <= 1'b0;</pre>
<pre>    end</pre>
<pre>      state_r <= state_n;</pre>
<pre>      load_not_store_r <= load_not_store_n;</pre>
<pre>      lru_way_r <= lru_way_n;</pre>
<pre>      dirty_r <= dirty_n;</pre>
<pre>      miss_addr_r <= miss_addr_n;</pre>
<pre>      dirty_lru_flopped_r <= dirty_lru_flopped_n;</pre>
<pre>      cce_data_received_r <= cce_data_received_n;</pre>
<pre>      set_tag_received_r <= set_tag_received_n;</pre>
<pre>      size_op_r <= size_op_n;</pre>
<pre>    end</pre>
<pre>    if (state_r == e_READY) begin</pre>
<pre>      assert(~cce_data_received_i)</pre>
<pre>        else $error("id: %0d, data_cmd received while no cache miss.", lce_id_i);</pre>
<pre>      assert(~set_tag_received_i)</pre>
<pre>        else $error("id: %0d, set_tag_cmd received while no cache miss.", lce_id_i);</pre>
<pre>      assert(~set_tag_wakeup_received_i)</pre>
<pre>        else $error("id: %0d, set_tag_wakeup_cmd received while no cache miss.", lce_id_i);</pre>
<pre>    end</pre>
<h3>./bp_be/src/v/bp_be_mem/bp_be_dcache/bp_be_dcache_wbuf.v</h3>
<pre>module bp_be_dcache_wbuf</pre>
<pre>  #(parameter data_width_p="inv"</pre>
<pre>    , parameter paddr_width_p="inv"</pre>
<pre>    , parameter ways_p="inv"</pre>
<pre>    , parameter sets_p="inv"</pre>
<pre></pre>
<pre>    , localparam block_size_in_words_lp=ways_p</pre>
<pre>    , localparam word_offset_width_lp=`BSG_SAFE_CLOG2(block_size_in_words_lp)</pre>
<pre>    , localparam data_mask_width_lp=(data_width_p>>3)</pre>
<pre>    , localparam byte_offset_width_lp=`BSG_SAFE_CLOG2(data_width_p>>3)</pre>
<pre>    , localparam block_offset_width_lp=(word_offset_width_lp+byte_offset_width_lp)</pre>
<pre>    , localparam way_id_width_lp=`BSG_SAFE_CLOG2(ways_p)</pre>
<pre>    , localparam index_width_lp=`BSG_SAFE_CLOG2(sets_p)</pre>
<pre></pre>
<pre>      `bp_be_dcache_wbuf_entry_width(paddr_width_p,data_width_p,ways_p)</pre>
<pre>    , input reset_i</pre>
<pre>    </pre>
<pre>    , input [wbuf_entry_width_lp-1:0] wbuf_entry_i</pre>
<pre></pre>
<pre>    , output logic v_o</pre>
<pre>    , output logic [wbuf_entry_width_lp-1:0] wbuf_entry_o</pre>
<pre></pre>
<pre>    </pre>
<pre>    , input bypass_v_i</pre>
<pre>    , output logic [data_width_p-1:0] bypass_data_o</pre>
<pre>    , output logic [data_mask_width_lp-1:0] bypass_mask_o</pre>
<pre></pre>
<pre>    , input [way_id_width_lp-1:0] lce_snoop_way_i</pre>
<pre>    , output logic lce_snoop_match_o</pre>
<pre>  );</pre>
<pre style="background-color: #FF0000;">  `declare_bp_be_dcache_wbuf_entry_s(paddr_width_p, data_width_p, ways_p);</pre>
<pre>  assign wbuf_entry_in = wbuf_entry_i;</pre>
<pre>  </pre>
<pre>  bp_be_dcache_wbuf_entry_s wbuf_entry_el1;</pre>
<pre></pre>
<pre></pre>
<pre>  logic el1_valid;</pre>
<pre>  logic mux1_sel;</pre>
<pre>  logic mux0_sel;</pre>
<pre>  logic el0_enable;</pre>
<pre>  logic el1_enable;</pre>
<pre></pre>
<pre>    case (num_els_r) </pre>
<pre>      2'd0: begin</pre>
<pre>        v_o = v_i;</pre>
<pre>        empty_o = 1'b1;</pre>
<pre>        el0_valid = 1'b0;</pre>
<pre>        el1_valid = 1'b0;</pre>
<pre>        el0_enable = 1'b0;</pre>
<pre>        el1_enable = v_i & ~yumi_i;</pre>
<pre>        mux0_sel = 1'b0;</pre>
<pre>        mux1_sel = 1'b0;</pre>
<pre>      end</pre>
<pre>        v_o = 1'b1;</pre>
<pre>        empty_o = 1'b0;</pre>
<pre>        el0_valid = 1'b0;</pre>
<pre>        el1_valid = 1'b1;</pre>
<pre>        el0_enable = v_i & ~yumi_i;</pre>
<pre>        el1_enable = v_i & yumi_i;</pre>
<pre>        mux0_sel = 1'b0;</pre>
<pre>        mux1_sel = 1'b1;</pre>
<pre>      end</pre>
<pre>        v_o = 1'b1;</pre>
<pre>        empty_o = 1'b0;</pre>
<pre>        el0_valid = 1'b1;</pre>
<pre>        el1_valid = 1'b1;</pre>
<pre>        el0_enable = v_i & yumi_i;</pre>
<pre>        el1_enable = yumi_i;</pre>
<pre>        mux0_sel = 1'b1;</pre>
<pre>        mux1_sel = 1'b1;</pre>
<pre>      end</pre>
<pre>        v_o = 1'b0;</pre>
<pre>        empty_o = 1'b0;</pre>
<pre>        el0_valid = 1'b0;</pre>
<pre>        el1_valid = 1'b0;</pre>
<pre>        el0_enable = 1'b0;</pre>
<pre>        el1_enable = 1'b0;</pre>
<pre>        mux0_sel = 1'b0;</pre>
<pre>        mux1_sel = 1'b0;</pre>
<pre>      end</pre>
<pre>    if (reset_i) begin</pre>
<pre>      num_els_r <= 2'b0;</pre>
<pre>    end</pre>
<pre>      num_els_r <= num_els_r + 2'(v_i) - 2'(v_o & yumi_i);</pre>
<pre>    end</pre>
<pre>    #(.width_p(wbuf_entry_width_lp))</pre>
<pre>    wbq</pre>
<pre style="background-color: #FF0000;">      (.clk_i(clk_i)</pre>
<pre>      ,.data_i(wbuf_entry_in)</pre>
<pre>      ,.el0_en_i(el0_enable)</pre>
<pre>      ,.el1_en_i(el1_enable)</pre>
<pre>      ,.mux0_sel_i(mux0_sel)</pre>
<pre>      ,.mux1_sel_i(mux1_sel)</pre>
<pre>      ,.el0_snoop_o(wbuf_entry_el0)</pre>
<pre>      ,.el1_snoop_o(wbuf_entry_el1)</pre>
<pre>      ,.data_o(wbuf_entry_o)</pre>
<pre>      );</pre>
<pre>  logic tag_hit1, tag_hit1_n;</pre>
<pre>  logic tag_hit2, tag_hit2_n;</pre>
<pre>  logic [paddr_width_p-byte_offset_width_lp-1:0] bypass_word_addr;</pre>
<pre></pre>
<pre>  assign tag_hit0_n = bypass_word_addr == wbuf_entry_el0.paddr[paddr_width_p-1:byte_offset_width_lp]; </pre>
<pre>  assign tag_hit1_n = bypass_word_addr == wbuf_entry_el1.paddr[paddr_width_p-1:byte_offset_width_lp]; </pre>
<pre>  assign tag_hit2_n = bypass_word_addr == wbuf_entry_in.paddr[paddr_width_p-1:byte_offset_width_lp]; </pre>
<pre></pre>
<pre>  assign tag_hit1 = tag_hit1_n & el1_valid;</pre>
<pre>  assign tag_hit2 = tag_hit2_n & v_i;</pre>
<pre></pre>
<pre>  logic [data_mask_width_lp-1:0] tag_hit1x4;</pre>
<pre>  logic [data_mask_width_lp-1:0] tag_hit2x4;</pre>
<pre>  </pre>
<pre>  assign tag_hit1x4 = {data_mask_width_lp{tag_hit1}};</pre>
<pre>  assign tag_hit2x4 = {data_mask_width_lp{tag_hit2}};</pre>
<pre>   </pre>
<pre>  logic [data_width_p-1:0] bypass_data_n;</pre>
<pre>  logic [data_mask_width_lp-1:0] bypass_mask_n;</pre>
<pre></pre>
<pre>    | (tag_hit1x4 & wbuf_entry_el1.mask)</pre>
<pre>    | (tag_hit2x4 & wbuf_entry_in.mask);</pre>
<pre></pre>
<pre>    .segments_p(data_mask_width_lp)</pre>
<pre>    ,.segment_width_p(8) </pre>
<pre>  ) mux_segmented_merge0 (</pre>
<pre style="background-color: #FF0000;">    .data0_i(wbuf_entry_el1.data)</pre>
<pre>    ,.data1_i(wbuf_entry_el0.data)</pre>
<pre>    ,.sel_i(tag_hit0x4 & wbuf_entry_el0.mask)</pre>
<pre>    ,.data_o(el0or1_data)</pre>
<pre>  );</pre>
<pre>    .segments_p(data_mask_width_lp)</pre>
<pre>    ,.segment_width_p(8) </pre>
<pre>  ) mux_segmented_merge1 (</pre>
<pre style="background-color: #FF0000;">    .data0_i(el0or1_data)</pre>
<pre>    ,.data1_i(wbuf_entry_in.data)</pre>
<pre>    ,.sel_i(tag_hit2x4 & wbuf_entry_in.mask)</pre>
<pre>    ,.data_o(bypass_data_n)</pre>
<pre>  );</pre>
<pre>    if (reset_i) begin</pre>
<pre>      bypass_mask_o <= '0;</pre>
<pre>      bypass_data_o <= '0;</pre>
<pre>    end</pre>
<pre>      if (bypass_v_i) begin</pre>
<pre>        bypass_mask_o <= bypass_mask_n;</pre>
<pre>        bypass_data_o <= bypass_data_n; </pre>
<pre>      end</pre>
<pre>  logic lce_snoop_el0_match;</pre>
<pre>  logic lce_snoop_el1_match;</pre>
<pre></pre>
<pre>    & (lce_snoop_index_i == wbuf_entry_in.paddr[block_offset_width_lp+:index_width_lp])</pre>
<pre>    & (lce_snoop_way_i == wbuf_entry_in.way_id);</pre>
<pre></pre>
<pre>    & (lce_snoop_index_i == wbuf_entry_el0.paddr[block_offset_width_lp+:index_width_lp])</pre>
<pre>    & (lce_snoop_way_i == wbuf_entry_el0.way_id);</pre>
<pre></pre>
<pre>    & (lce_snoop_index_i == wbuf_entry_el1.paddr[block_offset_width_lp+:index_width_lp])</pre>
<pre>    & (lce_snoop_way_i == wbuf_entry_el1.way_id);</pre>
<pre></pre>
<pre></pre>
<h3>./bp_be/src/v/bp_be_mem/bp_be_dcache/bp_be_dcache_wbuf_queue.v</h3>
<pre>module bp_be_dcache_wbuf_queue</pre>
<pre>  #(parameter width_p="inv")</pre>
<pre>    input clk_i</pre>
<pre>    , input [width_p-1:0] data_i</pre>
<pre>    , input el0_en_i</pre>
<pre>    , input el1_en_i</pre>
<pre>    , input mux0_sel_i</pre>
<pre>    , input mux1_sel_i</pre>
<pre>    , output logic [width_p-1:0] el0_snoop_o</pre>
<pre>    , output logic [width_p-1:0] el1_snoop_o</pre>
<pre>    , output logic [width_p-1:0] data_o</pre>
<pre>  logic [width_p-1:0] el0_r, el1_r;</pre>
<pre>  always_ff @ (posedge clk_i) begin</pre>
<pre>    if (el0_en_i) begin</pre>
<pre>      el0_r <= data_i;</pre>
<pre>    if (el1_en_i) begin</pre>
<pre>      el1_r <= mux0_sel_i ? el0_r : data_i;</pre>
<pre>  assign data_o = mux1_sel_i ? el1_r : data_i;</pre>
<pre>  assign el0_snoop_o = el0_r;</pre>
<pre>  assign el1_snoop_o = el1_r;</pre>
<h3>./bp_fe/src/v/bp_fe_bht.v</h3>
<pre>module bp_fe_bht</pre>
<pre> #(parameter bht_idx_width_p = "inv"</pre>
<pre>   , localparam els_lp             = 2**bht_idx_width_p</pre>
<pre>   , localparam saturation_size_lp = 2</pre>
<pre>  (input                         clk_i</pre>
<pre>   , input                       reset_i</pre>
<pre>   , input                       w_v_i</pre>
<pre>   , input [bht_idx_width_p-1:0] idx_w_i</pre>
<pre>   , input                       correct_i</pre>
<pre>   , input                       r_v_i   </pre>
<pre>   , input [bht_idx_width_p-1:0] idx_r_i</pre>
<pre>   , output                      predict_o</pre>
<pre>logic [els_lp-1:0][saturation_size_lp-1:0] mem;</pre>
<pre>assign predict_o = r_v_i ? mem[idx_r_i][1] : 1'b0;</pre>
<pre>always_ff @(posedge clk_i) </pre>
<pre>  if (reset_i) </pre>
<pre>    mem <= '{default:2'b01};</pre>
<pre>  else if (w_v_i) </pre>
<pre>    begin</pre>
<pre>      case ({correct_i, mem[idx_w_i][1], mem[idx_w_i][0]})</pre>
<pre>        3'b000: mem[idx_w_i] <= {mem[idx_w_i][1]^mem[idx_w_i][0], 1'b1};//2'b01</pre>
<pre>        3'b001: mem[idx_w_i] <= {mem[idx_w_i][1]^mem[idx_w_i][0], 1'b1};//2'b11</pre>
<pre>        3'b010: mem[idx_w_i] <= {mem[idx_w_i][1]^mem[idx_w_i][0], 1'b1};//2'b11</pre>
<pre>        3'b011: mem[idx_w_i] <= {mem[idx_w_i][1]^mem[idx_w_i][0], 1'b1};//2'b01</pre>
<pre>        3'b100: mem[idx_w_i] <= mem[idx_w_i];//2'b00</pre>
<pre>        3'b101: mem[idx_w_i] <= {mem[idx_w_i][1], ~mem[idx_w_i][0]};//2'b00</pre>
<pre>        3'b110: mem[idx_w_i] <= mem[idx_w_i];//2'b10</pre>
<pre>        3'b111: mem[idx_w_i] <= {mem[idx_w_i][1], ~mem[idx_w_i][0]};//2'b10</pre>
<h3>./bp_fe/src/v/bp_fe_btb.v</h3>
<pre>module bp_fe_btb</pre>
<pre> #(parameter vaddr_width_p = "inv"</pre>
<pre>   , parameter btb_tag_width_p = "inv"</pre>
<pre>   , parameter btb_idx_width_p = "inv"</pre>
<pre>   , localparam btb_offset_width_lp = 2 // bottom 2 bits are unused without compressed branches</pre>
<pre>   , localparam eaddr_width_lp = rv64_eaddr_width_gp</pre>
<pre>  (input                          clk_i</pre>
<pre>   , input                        reset_i </pre>
<pre>   , input [vaddr_width_p-1:0]    r_addr_i</pre>
<pre>   , input                        r_v_i</pre>
<pre>   , output [vaddr_width_p-1:0]   br_tgt_o</pre>
<pre>   , output                       br_tgt_v_o</pre>
<pre>   , input [btb_tag_width_p-1:0]  w_tag_i</pre>
<pre>   , input [btb_idx_width_p-1:0]  w_idx_i</pre>
<pre>   , input                        w_v_i</pre>
<pre>   , input [vaddr_width_p-1:0]    br_tgt_i</pre>
<pre>localparam btb_els_lp = 2**btb_idx_width_p;</pre>
<pre>logic [btb_tag_width_p-1:0] tag_mem_li, tag_mem_lo;</pre>
<pre>logic [btb_idx_width_p-1:0] tag_mem_addr_li;</pre>
<pre>logic                       tag_mem_v_lo;</pre>
<pre>logic [vaddr_width_p-1:0]   tgt_mem_li, tgt_mem_lo;</pre>
<pre>logic [btb_idx_width_p-1:0] tgt_mem_addr_li;</pre>
<pre>logic [btb_tag_width_p-1:0] w_tag_n, w_tag_r;</pre>
<pre>logic [btb_tag_width_p-1:0] r_tag_n, r_tag_r;</pre>
<pre>logic [btb_idx_width_p-1:0] r_idx_n, r_idx_r;</pre>
<pre>logic                       r_v_r;</pre>
<pre>assign tag_mem_li      = w_tag_i; </pre>
<pre>assign tgt_mem_li      = br_tgt_i[0+:vaddr_width_p];</pre>
<pre>assign tag_mem_addr_li = w_v_i</pre>
<pre>                         ? w_idx_i</pre>
<pre>                         : r_addr_i[btb_offset_width_lp+:btb_idx_width_p];</pre>
<pre>logic [btb_els_lp-1:0] v_r, v_n;</pre>
<pre>bsg_mem_1rw_sync</pre>
<pre> #(.width_p(btb_tag_width_p+vaddr_width_p)</pre>
<pre>   ,.els_p(btb_els_lp)</pre>
<pre style="background-color: #FF0000;"> tag_mem</pre>
<pre>  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre>   ,.v_i(r_v_i | w_v_i)</pre>
<pre>   ,.w_i(w_v_i)</pre>
<pre>   ,.data_i({tag_mem_li, tgt_mem_li})</pre>
<pre>   ,.addr_i(tag_mem_addr_li)</pre>
<pre>   ,.data_o({tag_mem_lo, tgt_mem_lo})</pre>
<pre>assign tag_mem_v_lo = v_r[r_idx_r];</pre>
<pre>assign br_tgt_o   = tgt_mem_lo;</pre>
<pre>assign br_tgt_v_o = tag_mem_v_lo & r_v_r & (tag_mem_lo == r_tag_r);</pre>
<pre>always_ff @(posedge clk_i)</pre>
<pre>  begin</pre>
<pre>    if (reset_i)</pre>
<pre>      begin</pre>
<pre>        r_v_r <= '0;</pre>
<pre>        r_tag_r <= '0;</pre>
<pre>        r_idx_r <= '0;</pre>
<pre>      begin</pre>
<pre>        r_v_r <= r_v_i & ~w_v_i;</pre>
<pre>        r_tag_r <= r_addr_i[btb_offset_width_lp+btb_idx_width_p+:btb_tag_width_p];</pre>
<pre>        r_idx_r <= r_addr_i[btb_offset_width_lp+:btb_idx_width_p];</pre>
<pre>      if (reset_i)</pre>
<pre>        v_r <= '0;</pre>
<pre>      else if (w_v_i)</pre>
<pre>        v_r[tag_mem_addr_li] <= 1'b1;</pre>
<pre>        v_r <= v_r;</pre>
<h3>./bp_fe/src/v/bp_fe_lce_cmd.v</h3>
<pre> *</pre>
<pre style="background-color: #FF0000;"> * Parameters:</pre>
<pre style="background-color: #FF0000;"> *</pre>
<pre>module bp_fe_lce_cmd</pre>
<pre>   `declare_bp_proc_params(cfg_p)</pre>
<pre>    , input                                                      reset_i</pre>
<pre>    , input [lce_id_width_lp-1:0]                                lce_id_i</pre>
<pre></pre>
<pre></pre>
<pre>    , output logic                                               set_tag_received_o</pre>
<pre>    , output logic                                               set_tag_wakeup_received_o</pre>
<pre>    , output logic                                               cce_data_received_o</pre>
<pre>    , output logic                                               uncached_data_received_o</pre>
<pre></pre>
<pre>    , output logic [data_mem_pkt_width_lp-1:0]                   data_mem_pkt_o</pre>
<pre>    , output logic                                               data_mem_pkt_v_o</pre>
<pre>    , input                                                      data_mem_pkt_yumi_i</pre>
<pre></pre>
<pre>    , output logic                                               tag_mem_pkt_v_o</pre>
<pre>    , input                                                      tag_mem_pkt_yumi_i</pre>
<pre></pre>
<pre>    , output logic [stat_mem_pkt_width_lp-1:0]                   stat_mem_pkt_o</pre>
<pre>    , input                                                      stat_mem_pkt_yumi_i</pre>
<pre></pre>
<pre>    , output logic                                               lce_resp_v_o</pre>
<pre>    , input                                                      lce_resp_yumi_i</pre>
<pre></pre>
<pre>    , input                                                      lce_cmd_v_i</pre>
<pre>    , output logic                                               lce_cmd_ready_o</pre>
<pre>    </pre>
<pre>    , output logic                                               lce_cmd_v_o</pre>
<pre>    , input                                                      lce_cmd_ready_i </pre>
<pre>  );</pre>
<pre>  // lce interface</pre>
<pre>  //</pre>
<pre>  `declare_bp_lce_cce_if(num_cce_p, num_lce_p, paddr_width_p, lce_assoc_p, dword_width_p, cce_block_width_p);</pre>
<pre></pre>
<pre style="background-color: #FF0000;">  bp_lce_cmd_s lce_cmd_li;</pre>
<pre>  logic lce_cmd_v_li, lce_cmd_yumi_lo;</pre>
<pre>  bp_lce_cce_resp_s lce_resp;</pre>
<pre>  bp_lce_cmd_s lce_cmd_out;</pre>
<pre></pre>
<pre>  assign lce_resp_o    = lce_resp;</pre>
<pre>  assign lce_cmd_o     = lce_cmd_out;</pre>
<pre> </pre>
<pre>  logic [tag_width_lp-1:0] lce_cmd_addr_tag;</pre>
<pre>  assign lce_cmd_addr_index = lce_cmd_li.msg.cmd.addr[block_offset_width_lp+:index_width_lp];</pre>
<pre>  assign lce_cmd_addr_tag = lce_cmd_li.msg.cmd.addr[block_offset_width_lp+index_width_lp+:tag_width_lp];</pre>
<pre> </pre>
<pre>  // lce pkt</pre>
<pre>  `declare_bp_fe_icache_lce_data_mem_pkt_s(lce_sets_p, lce_assoc_p, lce_data_width_lp);</pre>
<pre>  `declare_bp_fe_icache_lce_tag_mem_pkt_s(lce_sets_p, lce_assoc_p, tag_width_lp);</pre>
<pre>  `declare_bp_fe_icache_lce_stat_mem_pkt_s(lce_sets_p, lce_assoc_p);</pre>
<pre></pre>
<pre>  bp_fe_icache_lce_data_mem_pkt_s data_mem_pkt;</pre>
<pre>  bp_fe_icache_lce_tag_mem_pkt_s tag_mem_pkt;</pre>
<pre>  bp_fe_icache_lce_stat_mem_pkt_s stat_mem_pkt;</pre>
<pre></pre>
<pre>  assign data_mem_pkt_o     = data_mem_pkt;</pre>
<pre>  assign tag_mem_pkt_o      = tag_mem_pkt;</pre>
<pre>  assign stat_mem_pkt_o = stat_mem_pkt;</pre>
<pre></pre>
<pre>  // states</pre>
<pre>  //</pre>
<pre>  logic [cce_id_width_lp-1:0] syn_ack_cnt_r, syn_ack_cnt_n;</pre>
<pre>  logic [lce_data_width_lp-1:0] data_r, data_n;</pre>
<pre>  logic flag_data_buffered_r, flag_data_buffered_n;</pre>
<pre>  logic flag_invalidate_r, flag_invalidate_n;</pre>
<pre></pre>
<pre>  bp_fe_lce_cmd_state_e state_r, state_n;</pre>
<pre></pre>
<pre> </pre>
<pre>  // lce_cmd fsm</pre>
<pre>  always_comb begin</pre>
<pre></pre>
<pre>    lce_cmd_yumi_lo = 1'b0;</pre>
<pre></pre>
<pre>    lce_resp = '0;</pre>
<pre>    lce_resp.src_id = lce_id_i;</pre>
<pre>    lce_resp_v_o = 1'b0;</pre>
<pre></pre>
<pre>    lce_cmd_out = '0;</pre>
<pre>    lce_cmd_v_o = 1'b0;</pre>
<pre></pre>
<pre>    data_mem_pkt = '0;</pre>
<pre>    data_mem_pkt_v_o = 1'b0;</pre>
<pre>    tag_mem_pkt = '0;</pre>
<pre>    tag_mem_pkt_v_o = 1'b0;</pre>
<pre>    stat_mem_pkt = '0;</pre>
<pre>    stat_mem_pkt_v_o = 1'b0;</pre>
<pre></pre>
<pre>    lce_ready_o             = (state_r != e_lce_cmd_reset);</pre>
<pre>    set_tag_received_o               = 1'b0;</pre>
<pre>    set_tag_wakeup_received_o        = 1'b0;</pre>
<pre>    cce_data_received_o              = 1'b0;</pre>
<pre>    uncached_data_received_o         = 1'b0;</pre>
<pre></pre>
<pre>    state_n = state_r;</pre>
<pre>    data_n = data_r;</pre>
<pre>    syn_ack_cnt_n = syn_ack_cnt_r;</pre>
<pre>    flag_data_buffered_n = flag_data_buffered_r;</pre>
<pre>    flag_invalidate_n = flag_invalidate_r;</pre>
<pre>           </pre>
<pre>    case (state_r)</pre>
<pre>      e_lce_cmd_ready: begin</pre>
<pre>        if (lce_cmd_li.msg_type == e_lce_cmd_transfer) begin</pre>
<pre>          data_mem_pkt.index  = lce_cmd_addr_index;</pre>
<pre>          data_mem_pkt.way_id = lce_cmd_li.way_id;</pre>
<pre>          data_mem_pkt.opcode = e_icache_lce_data_mem_read;</pre>
<pre>          data_mem_pkt_v_o    = lce_cmd_v_li;</pre>
<pre>          state_n             = data_mem_pkt_yumi_i ? e_lce_cmd_transfer_tmp : e_lce_cmd_ready;</pre>
<pre></pre>
<pre>        end else if (lce_cmd_li.msg_type == e_lce_cmd_writeback) begin</pre>
<pre>          lce_resp.dst_id   = lce_cmd_li.msg.cmd.src_id;</pre>
<pre>          lce_resp.msg_type = e_lce_cce_resp_null_wb;</pre>
<pre>          lce_resp.addr     = lce_cmd_li.msg.cmd.addr;</pre>
<pre>          lce_resp_v_o      = lce_cmd_v_li;</pre>
<pre>          lce_cmd_yumi_lo   = lce_resp_yumi_i;</pre>
<pre></pre>
<pre>        end else if (lce_cmd_li.msg_type == e_lce_cmd_set_tag) begin</pre>
<pre>          tag_mem_pkt.index  = lce_cmd_addr_index;</pre>
<pre>          tag_mem_pkt.way_id = lce_cmd_li.way_id;</pre>
<pre>          tag_mem_pkt.state  = lce_cmd_li.msg.cmd.state;</pre>
<pre>          tag_mem_pkt.tag    = lce_cmd_addr_tag;</pre>
<pre>          tag_mem_pkt.opcode = e_tag_mem_set_tag;</pre>
<pre>          tag_mem_pkt_v_o    = lce_cmd_v_li;</pre>
<pre></pre>
<pre>          set_tag_received_o          = tag_mem_pkt_yumi_i;</pre>
<pre></pre>
<pre>          tag_mem_pkt.index  = lce_cmd_addr_index;</pre>
<pre>          tag_mem_pkt.way_id = lce_cmd_li.way_id;</pre>
<pre>          tag_mem_pkt.state  = lce_cmd_li.msg.cmd.state;</pre>
<pre>          tag_mem_pkt.tag    = lce_cmd_addr_tag;</pre>
<pre>          tag_mem_pkt.opcode = e_tag_mem_set_tag;</pre>
<pre>          tag_mem_pkt_v_o    = lce_cmd_v_li;</pre>
<pre></pre>
<pre>          set_tag_wakeup_received_o   = tag_mem_pkt_yumi_i;</pre>
<pre></pre>
<pre>          tag_mem_pkt.index = lce_cmd_addr_index;</pre>
<pre>          tag_mem_pkt.way_id = lce_cmd_li.way_id;</pre>
<pre>          tag_mem_pkt.state = e_COH_I;</pre>
<pre>          tag_mem_pkt.opcode = e_tag_mem_invalidate;</pre>
<pre>          tag_mem_pkt_v_o = flag_invalidate_r</pre>
<pre>            ? 1'b0</pre>
<pre>            : lce_cmd_v_li;</pre>
<pre>          flag_invalidate_n = lce_resp_yumi_i</pre>
<pre>            ? 1'b0</pre>
<pre>            : (flag_invalidate_r</pre>
<pre>                ? 1'b1  </pre>
<pre>                : tag_mem_pkt_yumi_i);</pre>
<pre></pre>
<pre>          lce_resp.msg_type = e_lce_cce_inv_ack;</pre>
<pre>          lce_resp.addr = lce_cmd_li.msg.cmd.addr;</pre>
<pre>          lce_resp_v_o = (flag_invalidate_r | tag_mem_pkt_yumi_i);</pre>
<pre>          lce_cmd_yumi_lo = lce_resp_yumi_i;</pre>
<pre></pre>
<pre>          data_mem_pkt.index = miss_addr_i[block_offset_width_lp+:index_width_lp];</pre>
<pre>          data_mem_pkt.way_id = lce_cmd_li.way_id;</pre>
<pre>          data_mem_pkt.data = lce_cmd_li.msg.dt_cmd.data;</pre>
<pre>          data_mem_pkt.opcode = e_icache_lce_data_mem_write;</pre>
<pre>          data_mem_pkt_v_o = lce_cmd_v_li;</pre>
<pre></pre>
<pre>          tag_mem_pkt.way_id = lce_cmd_li.way_id;</pre>
<pre>          tag_mem_pkt.state  = lce_cmd_li.msg.dt_cmd.state;</pre>
<pre>          tag_mem_pkt.tag    = lce_cmd_li.msg.dt_cmd.addr[block_offset_width_lp+index_width_lp+:tag_width_lp];</pre>
<pre>          tag_mem_pkt.opcode = e_tag_mem_set_tag;</pre>
<pre>          tag_mem_pkt_v_o    = lce_cmd_v_li;</pre>
<pre></pre>
<pre></pre>
<pre>          set_tag_received_o  = tag_mem_pkt_yumi_i & data_mem_pkt_yumi_i;</pre>
<pre></pre>
<pre>              data_mem_pkt.index = miss_addr_i[block_offset_width_lp+:index_width_lp];</pre>
<pre>              data_mem_pkt.way_id = lce_cmd_li.way_id;</pre>
<pre>              data_mem_pkt.data = lce_cmd_li.msg.dt_cmd.data;</pre>
<pre>              data_mem_pkt.opcode = e_icache_lce_data_mem_uncached;</pre>
<pre>              data_mem_pkt_v_o = lce_cmd_v_li;</pre>
<pre>              lce_cmd_yumi_lo = data_mem_pkt_yumi_i;</pre>
<pre></pre>
<pre>            end</pre>
<pre>        flag_data_buffered_n = ~lce_cmd_ready_i;</pre>
<pre>        data_n               = flag_data_buffered_r ? data_r : data_mem_data_i;</pre>
<pre>        lce_cmd_out.msg.dt_cmd.data = flag_data_buffered_r ? data_r : data_mem_data_i;</pre>
<pre>        lce_cmd_out.msg.dt_cmd.addr = lce_cmd_li.msg.cmd.addr;</pre>
<pre>        lce_cmd_out.msg.dt_cmd.state = lce_cmd_li.msg.cmd.state;</pre>
<pre>        lce_cmd_out.way_id   = lce_cmd_li.msg.cmd.target_way_id;</pre>
<pre>        lce_cmd_out.msg_type = e_lce_cmd_data;</pre>
<pre>        lce_cmd_out.dst_id   = lce_cmd_li.msg.cmd.target;</pre>
<pre>        lce_cmd_yumi_lo      = lce_cmd_ready_i;</pre>
<pre>        lce_cmd_v_o          = 1'b1;</pre>
<pre>        state_n              = lce_cmd_ready_i ? e_lce_cmd_ready : e_lce_cmd_transfer_tmp;</pre>
<pre>      end</pre>
<pre>        if (lce_cmd_li.msg_type == e_lce_cmd_set_clear) begin</pre>
<pre>          tag_mem_pkt.index        = lce_cmd_addr_index;</pre>
<pre>          tag_mem_pkt.state        = e_COH_I;</pre>
<pre>          tag_mem_pkt.tag          = '0;</pre>
<pre>          tag_mem_pkt.opcode       = e_tag_mem_set_clear;</pre>
<pre>          tag_mem_pkt_v_o          = lce_cmd_v_li;</pre>
<pre>          stat_mem_pkt.index       = lce_cmd_addr_index;</pre>
<pre>          stat_mem_pkt.opcode      = e_stat_mem_set_clear;</pre>
<pre>          stat_mem_pkt_v_o         = lce_cmd_v_li;</pre>
<pre>          lce_cmd_yumi_lo          = tag_mem_pkt_yumi_i & stat_mem_pkt_yumi_i;</pre>
<pre></pre>
<pre>          lce_resp.dst_id = lce_cmd_li.msg.cmd.src_id;</pre>
<pre>          lce_resp.msg_type = e_lce_cce_sync_ack;</pre>
<pre>          lce_resp_v_o = lce_cmd_v_li;</pre>
<pre>          lce_cmd_yumi_lo = lce_resp_yumi_i;</pre>
<pre>          syn_ack_cnt_n = lce_resp_yumi_i</pre>
<pre>            ? syn_ack_cnt_r + 1</pre>
<pre>            : syn_ack_cnt_r;</pre>
<pre>          state_n = (syn_ack_cnt_r == cce_id_width_lp'(num_cce_p-1)) & lce_resp_yumi_i</pre>
<pre>            ? e_lce_cmd_ready</pre>
<pre>            : e_lce_cmd_reset;</pre>
<pre>        end</pre>
<pre></pre>
<pre>    if (reset_i) begin</pre>
<pre>      state_r              <= e_lce_cmd_reset;</pre>
<pre>      syn_ack_cnt_r        <= '0;</pre>
<pre>      flag_data_buffered_r <= 1'b0;</pre>
<pre>      flag_invalidate_r    <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      state_r              <= state_n;</pre>
<pre>      syn_ack_cnt_r        <= syn_ack_cnt_n;</pre>
<pre>      data_r               <= data_n;</pre>
<pre>      flag_data_buffered_r <= flag_data_buffered_n;</pre>
<pre>      flag_invalidate_r    <= flag_invalidate_n;</pre>
<pre>    end</pre>
<pre>   #(.width_p(lce_cmd_width_lp))</pre>
<pre>   rv_adapter</pre>
<pre style="background-color: #FF0000;">    (.clk_i(clk_i)</pre>
<pre>     ,.reset_i(reset_i)</pre>
<pre></pre>
<pre style="background-color: #FF0000;">     ,.data_i(lce_cmd_i)</pre>
<pre>     ,.v_i(lce_cmd_v_i)</pre>
<pre>     ,.ready_o(lce_cmd_ready_o)</pre>
<pre></pre>
<pre>     ,.v_o(lce_cmd_v_li)</pre>
<pre>     ,.yumi_i(lce_cmd_yumi_lo)</pre>
<pre>     );</pre>
<pre style="background-color: #FF0000;">endmodule</pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./bp_fe/src/v/bp_fe_icache.v</h3>
<pre> * The icache module implements a virtually-indexed physically-tagged cache. Although the cache</pre>
<pre style="background-color: #FF0000;"> * design is parameterized, our default icache configuration is a 4-way set associative cache. Our</pre>
<pre> * icache has an LCE as part of the cache controller that communicates with the CCE. For replacement</pre>
<pre>module bp_fe_icache</pre>
<pre>   `declare_bp_proc_params(cfg_p)</pre>
<pre>    )</pre>
<pre>    , input                                            reset_i</pre>
<pre>    , input                                            freeze_i</pre>
<pre></pre>
<pre></pre>
<pre>    , input [cfg_addr_width_p-1:0]                     cfg_addr_i</pre>
<pre>    , input [cfg_data_width_p-1:0]                     cfg_data_i</pre>
<pre></pre>
<pre>    , input                                            vaddr_v_i</pre>
<pre>    , output                                           vaddr_ready_o</pre>
<pre></pre>
<pre>    , input                                            ptag_v_i</pre>
<pre>    , input                                            uncached_i</pre>
<pre>    , input                                            poison_tl_i</pre>
<pre>    </pre>
<pre>    , output                                           data_v_o</pre>
<pre>    , output                                           instr_access_fault_o</pre>
<pre>    , output                                           cache_miss_o</pre>
<pre></pre>
<pre>    , output                                           lce_req_v_o</pre>
<pre>    , input                                            lce_req_ready_i</pre>
<pre></pre>
<pre>    , output [lce_cce_resp_width_lp-1:0]               lce_resp_o</pre>
<pre>    , output                                           lce_resp_v_o</pre>
<pre>    , input                                            lce_resp_ready_i</pre>
<pre></pre>
<pre>    , input                                            lce_cmd_v_i</pre>
<pre>    , output                                           lce_cmd_ready_o</pre>
<pre></pre>
<pre>    , output                                           lce_cmd_v_o</pre>
<pre>    , input                                            lce_cmd_ready_i </pre>
<pre> );</pre>
<pre></pre>
<pre></pre>
<pre>  logic [way_id_width_lp-1:0]           way_invalid_index; // first invalid way</pre>
<pre>  logic                                 invalid_exist;</pre>
<pre></pre>
<pre>  logic                                 invalidate_cmd_v; // an invalidate command from CCE</pre>
<pre></pre>
<pre>  assign vaddr_index      = vaddr_i[word_offset_width_lp</pre>
<pre>                                       +byte_offset_width_lp</pre>
<pre>                                       +:index_width_lp];</pre>
<pre>  assign vaddr_offset     = vaddr_i[byte_offset_width_lp+:word_offset_width_lp];</pre>
<pre>   </pre>
<pre>  // TL stage</pre>
<pre>  logic tl_we;</pre>
<pre>  logic [bp_page_offset_width_gp-1:0] page_offset_tl_r;</pre>
<pre>  logic [vaddr_width_p-1:0]           vaddr_tl_r;</pre>
<pre></pre>
<pre>  assign tl_we = vaddr_v_i; </pre>
<pre></pre>
<pre>  always_ff @ (posedge clk_i) begin</pre>
<pre>    if (reset_i) begin</pre>
<pre>      v_tl_r       <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      v_tl_r       <= tl_we;</pre>
<pre>      if (tl_we) begin</pre>
<pre>        page_offset_tl_r <= vaddr_i[bp_page_offset_width_gp-1:0];</pre>
<pre>        vaddr_tl_r       <= vaddr_i;</pre>
<pre>      end</pre>
<pre></pre>
<pre>  logic                                     tag_mem_v_li;</pre>
<pre>  logic                                     tag_mem_w_li;</pre>
<pre>  logic [index_width_lp-1:0]                tag_mem_addr_li;</pre>
<pre>  logic [lce_assoc_p-1:0][`bp_coh_bits+tag_width_lp-1:0] tag_mem_data_li;</pre>
<pre>  logic [lce_assoc_p-1:0][`bp_coh_bits+tag_width_lp-1:0] tag_mem_w_mask_li;</pre>
<pre>  logic [lce_assoc_p-1:0][`bp_coh_bits+tag_width_lp-1:0] tag_mem_data_lo;</pre>
<pre></pre>
<pre>    .width_p(lce_assoc_p*(`bp_coh_bits+tag_width_lp))</pre>
<pre>    ,.els_p(lce_sets_p)</pre>
<pre>  ) tag_mem (</pre>
<pre>    .clk_i(clk_i)</pre>
<pre>    ,.reset_i(reset_i)</pre>
<pre>    ,.data_i(tag_mem_data_li)</pre>
<pre>    ,.addr_i(tag_mem_addr_li)</pre>
<pre>    ,.v_i(~reset_i & tag_mem_v_li)</pre>
<pre>    ,.w_mask_i(tag_mem_w_mask_li)</pre>
<pre>    ,.w_i(tag_mem_w_li)</pre>
<pre>    ,.data_o(tag_mem_data_lo)</pre>
<pre>  );</pre>
<pre style="background-color: #FF0000;"></pre>
<pre>  logic [lce_assoc_p-1:0][tag_width_lp-1:0] tag_tl;</pre>
<pre></pre>
<pre>  for (genvar i = 0; i < lce_assoc_p; i++) begin</pre>
<pre>    assign state_tl[i] = tag_mem_data_lo[i][tag_width_lp+:`bp_coh_bits];</pre>
<pre>    assign tag_tl[i]   = tag_mem_data_lo[i][0+:tag_width_lp];</pre>
<pre>  end</pre>
<pre>  // data memory</pre>
<pre>  logic [lce_assoc_p-1:0]                                           data_mem_v_li;</pre>
<pre>  logic                                                             data_mem_w_li;</pre>
<pre>  logic [lce_assoc_p-1:0][index_width_lp+word_offset_width_lp-1:0]  data_mem_addr_li;</pre>
<pre>  logic [lce_assoc_p-1:0][dword_width_p-1:0]                        data_mem_data_li;</pre>
<pre>  logic [lce_assoc_p-1:0][data_mask_width_lp-1:0]                   data_mem_w_mask_li;</pre>
<pre>  logic [lce_assoc_p-1:0][dword_width_p-1:0]                        data_mem_data_lo;</pre>
<pre></pre>
<pre>  // data memory: banks</pre>
<pre>  for (genvar bank = 0; bank < lce_assoc_p; bank++)</pre>
<pre>  begin: data_mems</pre>
<pre>    bsg_mem_1rw_sync_mask_write_byte #(</pre>
<pre>      .data_width_p(dword_width_p)</pre>
<pre>      ,.els_p(lce_sets_p*lce_assoc_p) // same number of blocks and ways</pre>
<pre>    ) data_mem (</pre>
<pre style="background-color: #FF0000;">      .clk_i(clk_i)</pre>
<pre>      ,.reset_i(reset_i)</pre>
<pre>      ,.data_i(data_mem_data_li[bank])</pre>
<pre>      ,.addr_i(data_mem_addr_li[bank])</pre>
<pre>      ,.v_i(~reset_i & data_mem_v_li[bank])</pre>
<pre>      ,.write_mask_i(data_mem_w_mask_li[bank])</pre>
<pre>      ,.w_i(data_mem_w_li)</pre>
<pre>      ,.data_o(data_mem_data_lo[bank])</pre>
<pre>    );</pre>
<pre>  logic tv_we;</pre>
<pre>  logic uncached_tv_r;</pre>
<pre>  logic [paddr_width_p-1:0]                     addr_tv_r;</pre>
<pre>  logic [vaddr_width_p-1:0]                     vaddr_tv_r; </pre>
<pre>  logic [lce_assoc_p-1:0][tag_width_lp-1:0]     tag_tv_r;</pre>
<pre>  logic [lce_assoc_p-1:0][`bp_coh_bits-1:0]     state_tv_r;</pre>
<pre>  logic [lce_assoc_p-1:0][dword_width_p-1:0]    ld_data_tv_r;</pre>
<pre>  logic [tag_width_lp-1:0]                      addr_tag_tv;</pre>
<pre>  logic [index_width_lp-1:0]                    addr_index_tv;</pre>
<pre>  logic [word_offset_width_lp-1:0]              addr_word_offset_tv;</pre>
<pre></pre>
<pre></pre>
<pre>    if (reset_i) begin</pre>
<pre>      v_tv_r       <= 1'b0;</pre>
<pre>    end</pre>
<pre>      v_tv_r <= tv_we;</pre>
<pre>      if (tv_we) begin</pre>
<pre>        addr_tv_r    <= {ptag_i, vaddr_tl_r[0+:bp_page_offset_width_gp]};</pre>
<pre>        vaddr_tv_r   <= vaddr_tl_r;</pre>
<pre>        tag_tv_r     <= tag_tl;</pre>
<pre>        state_tv_r   <= state_tl;</pre>
<pre>        ld_data_tv_r <= data_mem_data_lo;</pre>
<pre>        uncached_tv_r <= uncached_i;</pre>
<pre>      end</pre>
<pre>  assign addr_index_tv = addr_tv_r[block_offset_width_lp+:index_width_lp];</pre>
<pre>  assign addr_word_offset_tv = addr_tv_r[byte_offset_width_lp+:word_offset_width_lp];</pre>
<pre></pre>
<pre>  logic [way_id_width_lp-1:0] hit_index;</pre>
<pre>  logic                       hit;</pre>
<pre>  logic                       miss_tv;</pre>
<pre></pre>
<pre>    assign hit_v[i]   = (tag_tv_r[i] == addr_tag_tv) && (state_tv_r[i] != e_COH_I);</pre>
<pre>    assign way_v[i]   = (state_tv_r[i] != e_COH_I);</pre>
<pre>  end</pre>
<pre>    .width_p(lce_assoc_p)</pre>
<pre>    ,.lo_to_hi_p(1)</pre>
<pre>  ) pe_load_hit (</pre>
<pre style="background-color: #FF0000;">    .i(hit_v)</pre>
<pre>    ,.v_o(hit)</pre>
<pre>    ,.addr_o(hit_index)</pre>
<pre>  );</pre>
<pre></pre>
<pre>  logic uncached_load_data_v_r;</pre>
<pre>  logic [dword_width_p-1:0] uncached_load_data_r;</pre>
<pre></pre>
<pre></pre>
<pre>  logic                                       stat_mem_w_li;</pre>
<pre>  logic [index_width_lp-1:0]                  stat_mem_addr_li;</pre>
<pre>  logic [bp_fe_icache_stat_width_lp-1:0]      stat_mem_data_li;</pre>
<pre>  logic [bp_fe_icache_stat_width_lp-1:0]      stat_mem_mask_li;</pre>
<pre>  logic [bp_fe_icache_stat_width_lp-1:0]      stat_mem_data_lo;</pre>
<pre></pre>
<pre>    .width_p(bp_fe_icache_stat_width_lp)</pre>
<pre>    ,.els_p(lce_sets_p)</pre>
<pre>  ) stat_mem (</pre>
<pre style="background-color: #FF0000;">    .clk_i(clk_i)</pre>
<pre>    ,.reset_i(reset_i)</pre>
<pre>    ,.data_i(stat_mem_data_li)</pre>
<pre>    ,.addr_i(stat_mem_addr_li)</pre>
<pre>    ,.v_i(~reset_i & stat_mem_v_li)</pre>
<pre>    ,.w_mask_i(stat_mem_mask_li)</pre>
<pre>    ,.w_i(stat_mem_w_li)</pre>
<pre>    ,.data_o(stat_mem_data_lo)</pre>
<pre>  );</pre>
<pre></pre>
<pre>    .ways_p(lce_assoc_p)</pre>
<pre>  ) lru_encoder (</pre>
<pre style="background-color: #FF0000;">    .lru_i(stat_mem_data_lo)</pre>
<pre>    ,.way_id_o(lru_encode)</pre>
<pre>  );</pre>
<pre>    .width_p(lce_assoc_p)</pre>
<pre>    ,.lo_to_hi_p(1)</pre>
<pre>  ) pe_invalid (</pre>
<pre style="background-color: #FF0000;">    .i(~way_v)</pre>
<pre>    ,.v_o(invalid_exist)</pre>
<pre>    ,.addr_o(way_invalid_index)</pre>
<pre> );</pre>
<pre>  assign lru_way_li = invalid_exist ? way_invalid_index : lru_encode;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">  `declare_bp_fe_icache_lce_data_mem_pkt_s(lce_sets_p, lce_assoc_p, lce_data_width_lp);</pre>
<pre style="background-color: #FF0000;">  `declare_bp_fe_icache_lce_tag_mem_pkt_s(lce_sets_p, lce_assoc_p, tag_width_lp);</pre>
<pre style="background-color: #FF0000;">  `declare_bp_fe_icache_lce_stat_mem_pkt_s(lce_sets_p, lce_assoc_p);</pre>
<pre style="background-color: #FF0000;"></pre>
<pre>  bp_fe_icache_lce_tag_mem_pkt_s tag_mem_pkt;</pre>
<pre>  bp_fe_icache_lce_stat_mem_pkt_s stat_mem_pkt;</pre>
<pre></pre>
<pre>  logic                                      lce_data_mem_pkt_v_lo;</pre>
<pre>  logic                                      lce_data_mem_pkt_yumi_li;</pre>
<pre></pre>
<pre>  logic                                      tag_mem_pkt_yumi_li;</pre>
<pre></pre>
<pre>  logic                                      stat_mem_pkt_yumi_li;</pre>
<pre></pre>
<pre></pre>
<pre>    #(.cfg_p(cfg_p))</pre>
<pre>  lce</pre>
<pre style="background-color: #FF0000;">    (.clk_i(clk_i)</pre>
<pre>     ,.reset_i(reset_i)</pre>
<pre>     ,.freeze_i(freeze_i)</pre>
<pre></pre>
<pre>     ,.cfg_addr_i(cfg_addr_i)</pre>
<pre>     ,.cfg_data_i(cfg_data_i)</pre>
<pre></pre>
<pre style="background-color: #FF0000;">     ,.lce_id_i(lce_id_i)</pre>
<pre></pre>
<pre style="background-color: #FF0000;">     ,.ready_o(vaddr_ready_o)</pre>
<pre>     ,.cache_miss_o(cache_miss_o)</pre>
<pre></pre>
<pre>     ,.miss_addr_i(addr_tv_r)</pre>
<pre></pre>
<pre style="background-color: #FF0000;">     ,.uncached_req_i(uncached_req)</pre>
<pre></pre>
<pre>     ,.data_mem_pkt_o(lce_data_mem_pkt)</pre>
<pre>     ,.data_mem_pkt_v_o(lce_data_mem_pkt_v_lo)</pre>
<pre>     ,.data_mem_pkt_yumi_i(lce_data_mem_pkt_yumi_li)</pre>
<pre></pre>
<pre>     ,.tag_mem_pkt_v_o(tag_mem_pkt_v_lo)</pre>
<pre>     ,.tag_mem_pkt_yumi_i(tag_mem_pkt_yumi_li)</pre>
<pre></pre>
<pre style="background-color: #FF0000;">     ,.stat_mem_pkt_v_o(stat_mem_pkt_v_lo)</pre>
<pre>     ,.stat_mem_pkt_o(stat_mem_pkt)</pre>
<pre>     ,.lru_way_i(lru_way_li)</pre>
<pre>     ,.stat_mem_pkt_yumi_i(stat_mem_pkt_yumi_li)</pre>
<pre></pre>
<pre>     ,.lce_req_v_o(lce_req_v_o)</pre>
<pre>     ,.lce_req_ready_i(lce_req_ready_i)</pre>
<pre></pre>
<pre>     ,.lce_resp_v_o(lce_resp_v_o)</pre>
<pre>     ,.lce_resp_ready_i(lce_resp_ready_i)</pre>
<pre></pre>
<pre>     ,.lce_cmd_v_i(lce_cmd_v_i)</pre>
<pre>     ,.lce_cmd_ready_o(lce_cmd_ready_o)</pre>
<pre></pre>
<pre>     ,.lce_cmd_v_o(lce_cmd_v_o)</pre>
<pre>     ,.lce_cmd_ready_i(lce_cmd_ready_i)</pre>
<pre></pre>
<pre>     ); </pre>
<pre>    ? ~uncached_tv_r</pre>
<pre>    : 1'b0;</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre>    .width_p(dword_width_p)</pre>
<pre>    ,.els_p(lce_assoc_p)</pre>
<pre>  ) data_set_select_mux (</pre>
<pre style="background-color: #FF0000;">    .data_i(ld_data_tv_r)</pre>
<pre>    ,.sel_i(hit_index ^ addr_word_offset_tv)</pre>
<pre>    ,.data_o(ld_data_way_picked)</pre>
<pre>  );</pre>
<pre>  bsg_mux #(</pre>
<pre>    .width_p(dword_width_p)</pre>
<pre>    ,.els_p(2)</pre>
<pre>  ) final_data_mux (</pre>
<pre style="background-color: #FF0000;">    .data_i({uncached_load_data_r, ld_data_way_picked})</pre>
<pre>    ,.sel_i(uncached_load_data_v_r)</pre>
<pre>    ,.data_o(final_data)</pre>
<pre>  );</pre>
<pre></pre>
<pre>  assign data_o = lower_upper_sel</pre>
<pre>    ? final_data[instr_width_p+:instr_width_p]</pre>
<pre>    : final_data[instr_width_p-1:0];</pre>
<pre></pre>
<pre>  assign lce_data_mem_v = (lce_data_mem_pkt.opcode != e_icache_lce_data_mem_uncached)</pre>
<pre>    & lce_data_mem_pkt_yumi_li;</pre>
<pre></pre>
<pre>    ? {lce_assoc_p{1'b1}}</pre>
<pre>    : {lce_assoc_p{lce_data_mem_v}};</pre>
<pre></pre>
<pre>    & (lce_data_mem_pkt.opcode == e_icache_lce_data_mem_write);   </pre>
<pre></pre>
<pre></pre>
<pre>    assign data_mem_addr_li[i] = tl_we</pre>
<pre>      ? {vaddr_index, vaddr_offset}</pre>
<pre>      : {lce_data_mem_pkt.index, lce_data_mem_pkt.way_id ^ ((word_offset_width_lp)'(i))};</pre>
<pre></pre>
<pre>    assign data_mem_w_mask_li[i] = {data_mask_width_lp{1'b1}};</pre>
<pre>  end</pre>
<pre>    .width_p(dword_width_p)</pre>
<pre>    ,.els_p(lce_assoc_p)</pre>
<pre>  ) write_mux_butterfly (</pre>
<pre style="background-color: #FF0000;">    .data_i(lce_data_mem_pkt.data)</pre>
<pre>    ,.sel_i(lce_data_mem_pkt.way_id)</pre>
<pre>    ,.data_o(lce_data_mem_write_data)</pre>
<pre>  );</pre>
<pre>  assign tag_mem_w_li = ~tl_we & tag_mem_pkt_v_lo;</pre>
<pre>  assign tag_mem_addr_li = tl_we</pre>
<pre>    ? vaddr_index</pre>
<pre>    : tag_mem_pkt.index;</pre>
<pre></pre>
<pre>  bsg_decode #(</pre>
<pre>    .num_out_p(lce_assoc_p)</pre>
<pre>  ) lce_tag_mem_way_decode (</pre>
<pre style="background-color: #FF0000;">    .i(tag_mem_pkt.way_id)</pre>
<pre>    ,.o(lce_tag_mem_way_one_hot)</pre>
<pre>  );</pre>
<pre>    case (tag_mem_pkt.opcode)</pre>
<pre>      e_tag_mem_set_clear: begin</pre>
<pre>        for (integer i = 0 ; i < lce_assoc_p; i++) begin</pre>
<pre>          tag_mem_data_li[i]    = '0;</pre>
<pre>          tag_mem_w_mask_li[i]  = {(`bp_coh_bits+tag_width_lp){1'b1}};</pre>
<pre>        end</pre>
<pre>        for (integer i = 0; i < lce_assoc_p; i++) begin</pre>
<pre>          tag_mem_data_li[i]    = '0;</pre>
<pre>          tag_mem_w_mask_li[i] = {{`bp_coh_bits{lce_tag_mem_way_one_hot[i]}}, {tag_width_lp{1'b0}}};</pre>
<pre>        end</pre>
<pre>        for (integer i = 0; i < lce_assoc_p; i++) begin</pre>
<pre>          tag_mem_data_li[i]   = {tag_mem_pkt.state, tag_mem_pkt.tag};</pre>
<pre>          tag_mem_w_mask_li[i] = {(`bp_coh_bits+tag_width_lp){lce_tag_mem_way_one_hot[i]}};</pre>
<pre>        end</pre>
<pre>        tag_mem_data_li   = '0;</pre>
<pre>        tag_mem_w_mask_li = '0;</pre>
<pre>      end</pre>
<pre>  assign stat_mem_w_li = v_tv_r</pre>
<pre>    ? ~miss_tv</pre>
<pre>    : stat_mem_pkt_yumi_li & (stat_mem_pkt.opcode != e_stat_mem_read);</pre>
<pre>  assign stat_mem_addr_li = v_tv_r</pre>
<pre>    ? addr_index_tv </pre>
<pre>    : stat_mem_pkt.index;</pre>
<pre></pre>
<pre>  logic [lce_assoc_p-2:0] lru_decode_mask_lo;</pre>
<pre></pre>
<pre>     .ways_p(lce_assoc_p)</pre>
<pre>  ) lru_decode (</pre>
<pre style="background-color: #FF0000;">     .way_id_i(hit_index)</pre>
<pre>     ,.data_o(lru_decode_data_lo)</pre>
<pre>     ,.mask_o(lru_decode_mask_lo)</pre>
<pre>  );</pre>
<pre>    if (v_tv_r) begin</pre>
<pre>      stat_mem_data_li = lru_decode_data_lo;</pre>
<pre>      stat_mem_mask_li = lru_decode_mask_lo;</pre>
<pre>    end else begin</pre>
<pre>      stat_mem_data_li = {(lce_assoc_p-1){1'b0}};</pre>
<pre>      stat_mem_mask_li = {(lce_assoc_p-1){1'b1}};</pre>
<pre>    end</pre>
<pre></pre>
<pre>    if (lce_data_mem_pkt_yumi_li & (lce_data_mem_pkt.opcode == e_icache_lce_data_mem_read)) begin</pre>
<pre>      lce_data_mem_pkt_way_r <= lce_data_mem_pkt.way_id;</pre>
<pre>    end</pre>
<pre>    .width_p(dword_width_p)</pre>
<pre>    ,.els_p(lce_assoc_p)</pre>
<pre>  ) read_mux_butterfly (</pre>
<pre style="background-color: #FF0000;">    .data_i(data_mem_data_lo)</pre>
<pre>    ,.sel_i(lce_data_mem_pkt_way_r)</pre>
<pre>    ,.data_o(lce_data_mem_data_li)</pre>
<pre>  );</pre>
<pre>    ? lce_data_mem_pkt_v_lo</pre>
<pre>    : lce_data_mem_pkt_v_lo & ~tl_we;</pre>
<pre></pre>
<pre>    if (reset_i) begin</pre>
<pre>      uncached_load_data_v_r <= 1'b0;</pre>
<pre>    end</pre>
<pre>      if (lce_data_mem_pkt_yumi_li & (lce_data_mem_pkt.opcode == e_icache_lce_data_mem_uncached)) begin</pre>
<pre>        uncached_load_data_r <= lce_data_mem_pkt.data[0+:dword_width_p];</pre>
<pre>        uncached_load_data_v_r <= 1'b1;</pre>
<pre>      end</pre>
<pre>        // once the uncached load is replayed, and v_o goes high, clear the valid bit</pre>
<pre>          uncached_load_data_v_r <= 1'b0;</pre>
<pre>        end</pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;">    bp_fe_icache_axe_trace_gen #(</pre>
<pre style="background-color: #FF0000;">      .addr_width_p(paddr_width_p)</pre>
<pre style="background-color: #FF0000;">      ,.dword_width_p(instr_width_p)</pre>
<pre style="background-color: #FF0000;">    ) cc (</pre>
<pre style="background-color: #FF0000;">      .clk_i(clk_i)</pre>
<pre style="background-color: #FF0000;">      ,.id_i(lce_id_i)</pre>
<pre style="background-color: #FF0000;">      ,.v_i(icache_pc_gen_data_v_o)</pre>
<pre style="background-color: #FF0000;">      ,.addr_i(addr_tv_r)</pre>
<pre style="background-color: #FF0000;">      ,.data_i(data_o)</pre>
<pre style="background-color: #FF0000;">    );</pre>
<h3>./bp_me/src/v/cce/bp_cce.v</h3>
<pre> */</pre>
<pre style="background-color: #FF0000;"></pre>
<pre>module bp_cce</pre>
<pre>    `declare_bp_proc_params(cfg_p)</pre>
<pre>    , localparam lg_num_lce_lp             = `BSG_SAFE_CLOG2(num_lce_p)</pre>
<pre>    , localparam lg_num_cce_lp             = `BSG_SAFE_CLOG2(num_cce_p)</pre>
<pre>    , localparam lg_block_size_in_bytes_lp = `BSG_SAFE_CLOG2(block_size_in_bytes_lp)</pre>
<pre>    , localparam lg_lce_assoc_lp           = `BSG_SAFE_CLOG2(lce_assoc_p)</pre>
<pre>    , localparam lg_lce_sets_lp            = `BSG_SAFE_CLOG2(lce_sets_p)</pre>
<pre>    , localparam tag_width_lp              = (paddr_width_p-lg_lce_sets_lp</pre>
<pre>                                              -lg_block_size_in_bytes_lp)</pre>
<pre>    , localparam entry_width_lp            = (tag_width_lp+`bp_coh_bits)</pre>
<pre>    , localparam tag_set_width_lp          = (entry_width_lp*lce_assoc_p)</pre>
<pre>    , localparam way_group_width_lp        = (tag_set_width_lp*num_lce_p)</pre>
<pre>    , localparam way_group_offset_high_lp  = (lg_block_size_in_bytes_lp+lg_lce_sets_lp)</pre>
<pre>    , localparam num_way_groups_lp         = (lce_sets_p/num_cce_p)</pre>
<pre>    , localparam lg_num_way_groups_lp      = `BSG_SAFE_CLOG2(num_way_groups_lp)</pre>
<pre>    , localparam inst_ram_addr_width_lp    = `BSG_SAFE_CLOG2(num_cce_instr_ram_els_p)</pre>
<pre></pre>
<pre>    // interface widths</pre>
<pre>    `declare_bp_lce_cce_if_widths(num_cce_p, num_lce_p, paddr_width_p, lce_assoc_p, dword_width_p, cce_block_width_p)</pre>
<pre>    `declare_bp_me_if_widths(paddr_width_p, cce_block_width_p, num_lce_p, lce_assoc_p)</pre>
<pre>  )</pre>
<pre>  (input                                               clk_i</pre>
<pre>   , input                                             reset_i</pre>
<pre>   , input                                             freeze_i</pre>
<pre></pre>
<pre>   // Config channel</pre>
<pre>   , input [cfg_addr_width_p-1:0]                      cfg_addr_i</pre>
<pre>   , input [cfg_data_width_p-1:0]                      cfg_data_i</pre>
<pre></pre>
<pre>   , input                                             lce_req_v_i</pre>
<pre>   , output logic                                      lce_req_yumi_o</pre>
<pre></pre>
<pre>   , input                                             lce_resp_v_i</pre>
<pre>   , output logic                                      lce_resp_yumi_o</pre>
<pre></pre>
<pre>   , output logic                                      lce_cmd_v_o</pre>
<pre>   , input                                             lce_cmd_ready_i</pre>
<pre></pre>
<pre style="background-color: #FF0000;">   , input [cce_mem_msg_width_lp-1:0]                  mem_resp_i</pre>
<pre>   , input                                             mem_resp_v_i</pre>
<pre>   , output logic                                      mem_resp_yumi_o</pre>
<pre></pre>
<pre>   , input                                             mem_cmd_v_i</pre>
<pre>   , output logic                                      mem_cmd_yumi_o</pre>
<pre></pre>
<pre>   , output logic [cce_mem_msg_width_lp-1:0]           mem_cmd_o</pre>
<pre>   , output logic                                      mem_cmd_v_o</pre>
<pre>   , input                                             mem_cmd_ready_i</pre>
<pre></pre>
<pre>   , output logic [cce_mem_msg_width_lp-1:0]           mem_resp_o</pre>
<pre>   , output logic                                      mem_resp_v_o</pre>
<pre>   , input                                             mem_resp_ready_i</pre>
<pre></pre>
<pre>   , input [lg_num_cce_lp-1:0]                         cce_id_i</pre>
<pre>  );</pre>
<pre>    assert (lce_sets_p > 1) else $error("Number of LCE sets must be greater than 1");</pre>
<pre>    assert (num_cce_p >= 1 && `BSG_IS_POW2(num_cce_p))</pre>
<pre>      else $error("Number of CCE must be power of two");</pre>
<pre>  end</pre>
<pre></pre>
<pre>  // Define structure variables for output queues</pre>
<pre>  `declare_bp_me_if(paddr_width_p, cce_block_width_p, num_lce_p, lce_assoc_p);</pre>
<pre>  `declare_bp_lce_cce_if(num_cce_p, num_lce_p, paddr_width_p, lce_assoc_p, dword_width_p, cce_block_width_p);</pre>
<pre></pre>
<pre>  bp_lce_cce_req_s  lce_req_li;</pre>
<pre>  bp_lce_cce_resp_s lce_resp_li;</pre>
<pre>  bp_lce_cmd_s      lce_cmd_lo;</pre>
<pre></pre>
<pre>  bp_cce_mem_msg_s  mem_cmd_li, mem_cmd_lo, mem_resp_li, mem_resp_lo;</pre>
<pre></pre>
<pre>  // assign output queue ports to structure variables</pre>
<pre>  assign lce_cmd_o = lce_cmd_lo;</pre>
<pre>  assign mem_cmd_o = mem_cmd_lo;</pre>
<pre>  assign mem_resp_o = mem_resp_lo;</pre>
<pre></pre>
<pre>  // cast input messages with data</pre>
<pre>  assign mem_resp_li = mem_resp_i;</pre>
<pre>  assign mem_cmd_li = mem_cmd_i;</pre>
<pre>  assign lce_resp_li = lce_resp_i;</pre>
<pre>  assign lce_req_li = lce_req_i;</pre>
<pre></pre>
<pre>  // PC to Decode signals</pre>
<pre>  logic [`bp_cce_inst_width-1:0] pc_inst_lo;</pre>
<pre>  logic pc_inst_v_lo;</pre>
<pre></pre>
<pre>  // Decode to PC signals</pre>
<pre>  logic pc_stall_lo;</pre>
<pre>  logic [inst_ram_addr_width_lp-1:0] pc_branch_target_lo;</pre>
<pre></pre>
<pre>  // PC output signals</pre>
<pre>  bp_cce_mode_e cce_mode_lo;</pre>
<pre></pre>
<pre>  // ALU signals</pre>
<pre>  logic alu_branch_res_lo;</pre>
<pre>  logic [`bp_cce_inst_gpr_width-1:0] src_a, src_b, alu_res_lo;</pre>
<pre></pre>
<pre>  // Instruction Decode signals</pre>
<pre>  bp_cce_inst_decoded_s decoded_inst_lo;</pre>
<pre>  logic decoded_inst_v_lo;</pre>
<pre></pre>
<pre>  // Directory signals</pre>
<pre>  logic sharers_v_lo;</pre>
<pre>  logic [num_lce_p-1:0] sharers_hits_lo;</pre>
<pre>  logic [num_lce_p-1:0][lg_lce_assoc_lp-1:0] sharers_ways_lo;</pre>
<pre>  logic [num_lce_p-1:0][`bp_coh_bits-1:0] sharers_coh_states_lo;</pre>
<pre>  logic dir_lru_v_lo;</pre>
<pre>  logic dir_lru_cached_excl_lo;</pre>
<pre>  logic [tag_width_lp-1:0] dir_lru_tag_lo, dir_tag_lo;</pre>
<pre>  logic dir_busy_lo;</pre>
<pre></pre>
<pre>  logic [lg_num_way_groups_lp-1:0] dir_way_group_li;</pre>
<pre>  logic [lg_num_lce_lp-1:0] dir_lce_li;</pre>
<pre>  logic [lg_lce_assoc_lp-1:0] dir_way_li;</pre>
<pre>  logic [tag_width_lp-1:0] dir_tag_li;</pre>
<pre>  logic [`bp_coh_bits-1:0] dir_coh_state_li;</pre>
<pre></pre>
<pre>  // Pending Bit Signals</pre>
<pre>  logic pending_lo;</pre>
<pre>  logic pending_v_lo;</pre>
<pre>  logic pending_li, pending_from_msg;</pre>
<pre>  logic pending_w_v_li, pending_w_v_from_msg;</pre>
<pre>  logic [lg_num_way_groups_lp-1:0] pending_w_way_group_li, pending_r_way_group_li, pending_w_way_group_from_msg;</pre>
<pre>  assign pending_r_way_group_li = dir_way_group_li;</pre>
<pre></pre>
<pre>  // WDP write is valid if instruction pending_w_v is set (WDP op) and decoder is not stalling</pre>
<pre>  // the instruction (due to mem data resp writing pending bit)</pre>
<pre>  logic wdp_pending_w_v;</pre>
<pre>  assign wdp_pending_w_v = decoded_inst_lo.pending_w_v & ~pc_stall_lo;</pre>
<pre>  assign pending_li = (wdp_pending_w_v) ? decoded_inst_lo.imm[0] : pending_from_msg;</pre>
<pre>  assign pending_w_v_li = (wdp_pending_w_v) ? decoded_inst_lo.pending_w_v : pending_w_v_from_msg;</pre>
<pre>  assign pending_w_way_group_li = (wdp_pending_w_v) ? dir_way_group_li : pending_w_way_group_from_msg;</pre>
<pre></pre>
<pre></pre>
<pre>  logic [lg_num_lce_lp-1:0] gad_transfer_lce_lo;</pre>
<pre>  logic [lg_lce_assoc_lp-1:0] gad_transfer_lce_way_lo;</pre>
<pre>  logic gad_transfer_flag_lo;</pre>
<pre>  logic gad_replacement_flag_lo;</pre>
<pre>  logic gad_upgrade_flag_lo;</pre>
<pre>  logic gad_invalidate_flag_lo;</pre>
<pre>  logic gad_cached_flag_lo;</pre>
<pre>  logic gad_cached_exclusive_flag_lo;</pre>
<pre>  logic gad_cached_owned_flag_lo;</pre>
<pre>  logic gad_cached_dirty_flag_lo;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">  `declare_bp_cce_mshr_s(num_lce_p, lce_assoc_p, paddr_width_p);</pre>
<pre></pre>
<pre>  assign null_wb_flag_li = (lce_resp_v_i & (lce_resp_li.msg_type == e_lce_cce_resp_null_wb));</pre>
<pre></pre>
<pre>  logic [dword_width_p-1:0] nc_data_r_lo;</pre>
<pre>  logic [lg_num_lce_lp-1:0] num_lce_r_lo;</pre>
<pre></pre>
<pre>  logic                                          pending_w_busy_from_msg;</pre>
<pre>  logic                                          lce_cmd_busy_from_msg;</pre>
<pre></pre>
<pre>    #(.inst_ram_els_p(num_cce_instr_ram_els_p)</pre>
<pre>      ,.cfg_link_addr_width_p(cfg_addr_width_p)</pre>
<pre>      ,.cfg_link_data_width_p(cfg_data_width_p)</pre>
<pre>      )</pre>
<pre style="background-color: #FF0000;">     (.clk_i(clk_i)</pre>
<pre>      ,.reset_i(reset_i)</pre>
<pre>      ,.freeze_i(freeze_i)</pre>
<pre></pre>
<pre>      ,.cfg_addr_i(cfg_addr_i)</pre>
<pre>      ,.cfg_data_i(cfg_data_i)</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre>      ,.pc_branch_target_i(pc_branch_target_lo)</pre>
<pre></pre>
<pre>      ,.inst_v_o(pc_inst_v_lo)</pre>
<pre></pre>
<pre>      );</pre>
<pre>    #(.inst_width_p(`bp_cce_inst_width)</pre>
<pre>      ,.inst_addr_width_p(inst_ram_addr_width_lp)</pre>
<pre>      )</pre>
<pre style="background-color: #FF0000;">     (.clk_i(clk_i)</pre>
<pre>      ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>      ,.inst_v_i(pc_inst_v_lo)</pre>
<pre></pre>
<pre>      ,.lce_cmd_busy_i(lce_cmd_busy_from_msg)</pre>
<pre></pre>
<pre>      ,.lce_resp_v_i(lce_resp_v_i)</pre>
<pre>      ,.lce_resp_type_i(lce_resp_li.msg_type)</pre>
<pre>      ,.mem_resp_v_i(mem_resp_v_i)</pre>
<pre>      ,.mem_cmd_v_i(mem_cmd_v_i)</pre>
<pre>      ,.pending_v_i('0)</pre>
<pre></pre>
<pre>      ,.mem_cmd_ready_i(mem_cmd_ready_i)</pre>
<pre>      ,.mem_resp_ready_i(mem_resp_ready_i)</pre>
<pre></pre>
<pre></pre>
<pre>      ,.decoded_inst_v_o(decoded_inst_v_lo)</pre>
<pre></pre>
<pre>      ,.pc_branch_target_o(pc_branch_target_lo)</pre>
<pre>      );</pre>
<pre>    #(.width_p(`bp_cce_inst_gpr_width)</pre>
<pre>      )</pre>
<pre style="background-color: #FF0000;">     (.v_i(decoded_inst_lo.alu_v)</pre>
<pre>      ,.br_v_i(decoded_inst_lo.branch_v)</pre>
<pre>      ,.opd_a_i(src_a)</pre>
<pre>      ,.opd_b_i(src_b)</pre>
<pre>      ,.alu_op_i(decoded_inst_lo.minor_op_u.alu_minor_op)</pre>
<pre>      ,.br_op_i(decoded_inst_lo.minor_op_u.branch_minor_op)</pre>
<pre>      ,.res_o(alu_res_lo)</pre>
<pre>      ,.branch_res_o(alu_branch_res_lo)</pre>
<pre>      );</pre>
<pre>    #(.num_way_groups_p(num_way_groups_lp)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">     (.clk_i(clk_i)</pre>
<pre>      ,.reset_i(reset_i)</pre>
<pre>      ,.w_v_i(pending_w_v_li)</pre>
<pre>      ,.w_way_group_i(pending_w_way_group_li)</pre>
<pre>      ,.pending_i(pending_li)</pre>
<pre>      ,.r_v_i(decoded_inst_lo.pending_r_v)</pre>
<pre>      ,.r_way_group_i(pending_r_way_group_li)</pre>
<pre>      ,.pending_o(pending_lo)</pre>
<pre>      ,.pending_v_o(pending_v_lo)</pre>
<pre>      );</pre>
<pre>    #(.num_way_groups_p(num_way_groups_lp)</pre>
<pre>      ,.num_lce_p(num_lce_p)</pre>
<pre>      ,.num_cce_p(num_cce_p)</pre>
<pre>      ,.lce_assoc_p(lce_assoc_p)</pre>
<pre>      ,.tag_width_p(tag_width_lp)</pre>
<pre>      )</pre>
<pre style="background-color: #FF0000;">     (.clk_i(clk_i)</pre>
<pre>      ,.reset_i(reset_i)</pre>
<pre></pre>
<pre style="background-color: #FF0000;">      ,.way_group_i(dir_way_group_li)</pre>
<pre>      ,.lce_i(dir_lce_li)</pre>
<pre>      ,.way_i(dir_way_li)</pre>
<pre>      ,.lru_way_i(mshr.lru_way_id)</pre>
<pre></pre>
<pre>      ,.r_v_i(decoded_inst_lo.dir_r_v)</pre>
<pre></pre>
<pre>      ,.coh_state_i(dir_coh_state_li)</pre>
<pre></pre>
<pre>      ,.w_v_i(decoded_inst_lo.dir_w_v)</pre>
<pre>      ,.w_clr_wg_i('0)</pre>
<pre></pre>
<pre>      ,.sharers_hits_o(sharers_hits_lo)</pre>
<pre>      ,.sharers_ways_o(sharers_ways_lo)</pre>
<pre>      ,.sharers_coh_states_o(sharers_coh_states_lo)</pre>
<pre></pre>
<pre style="background-color: #FF0000;">      ,.lru_v_o(dir_lru_v_lo)</pre>
<pre>      ,.lru_cached_excl_o(dir_lru_cached_excl_lo)</pre>
<pre>      ,.lru_tag_o(dir_lru_tag_lo)</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;">  // GAD logic - auxiliary directory information logic</pre>
<pre>    #(.num_lce_p(num_lce_p)</pre>
<pre>      ,.lce_assoc_p(lce_assoc_p)</pre>
<pre>      )</pre>
<pre style="background-color: #FF0000;">    gad</pre>
<pre style="background-color: #FF0000;">     (.clk_i(clk_i)</pre>
<pre>      ,.reset_i(reset_i)</pre>
<pre>      ,.gad_v_i(decoded_inst_lo.gad_v)</pre>
<pre></pre>
<pre style="background-color: #FF0000;">      ,.sharers_v_i(sharers_v_lo)</pre>
<pre>      ,.sharers_hits_i(sharers_hits_lo)</pre>
<pre>      ,.sharers_ways_i(sharers_ways_lo)</pre>
<pre>      ,.sharers_coh_states_i(sharers_coh_states_lo)</pre>
<pre></pre>
<pre>      ,.req_type_flag_i(mshr.flags[e_flag_sel_rqf])</pre>
<pre>      ,.lru_dirty_flag_i(mshr.flags[e_flag_sel_ldf])</pre>
<pre>      ,.lru_cached_excl_flag_i(mshr.flags[e_flag_sel_lef])</pre>
<pre></pre>
<pre></pre>
<pre>      ,.transfer_lce_o(gad_transfer_lce_lo)</pre>
<pre>      ,.transfer_way_o(gad_transfer_lce_way_lo)</pre>
<pre>      ,.replacement_flag_o(gad_replacement_flag_lo)</pre>
<pre>      ,.upgrade_flag_o(gad_upgrade_flag_lo)</pre>
<pre>      ,.invalidate_flag_o(gad_invalidate_flag_lo)</pre>
<pre>      ,.cached_flag_o(gad_cached_flag_lo)</pre>
<pre>      ,.cached_exclusive_flag_o(gad_cached_exclusive_flag_lo)</pre>
<pre>      ,.cached_owned_flag_o(gad_cached_owned_flag_lo)</pre>
<pre>      ,.cached_dirty_flag_o(gad_cached_dirty_flag_lo)</pre>
<pre>      );</pre>
<pre>    #(.num_lce_p(num_lce_p)</pre>
<pre>      ,.num_cce_p(num_cce_p)</pre>
<pre>      ,.paddr_width_p(paddr_width_p)</pre>
<pre>      ,.lce_assoc_p(lce_assoc_p)</pre>
<pre>      ,.lce_sets_p(lce_sets_p)</pre>
<pre>      ,.block_size_in_bytes_p(block_size_in_bytes_lp)</pre>
<pre>      ,.lce_req_data_width_p(dword_width_p)</pre>
<pre>      ,.cfg_addr_width_p(cfg_addr_width_p)</pre>
<pre>      ,.cfg_data_width_p(cfg_data_width_p)</pre>
<pre>      )</pre>
<pre style="background-color: #FF0000;">     (.clk_i(clk_i)</pre>
<pre>      ,.reset_i(reset_i)</pre>
<pre>      ,.decoded_inst_i(decoded_inst_lo)</pre>
<pre>      ,.lce_req_i(lce_req_li)</pre>
<pre>      ,.null_wb_flag_i(null_wb_flag_li)</pre>
<pre>      ,.lce_resp_type_i(lce_resp_li.msg_type)</pre>
<pre>      ,.mem_resp_type_i(mem_resp_li.msg_type.cce_mem_cmd)</pre>
<pre>      ,.mem_cmd_i(mem_cmd_li)</pre>
<pre>      ,.alu_res_i(alu_res_lo)</pre>
<pre>      ,.mov_src_i(src_a)</pre>
<pre></pre>
<pre>      ,.pending_v_o_i(pending_v_lo)</pre>
<pre>      ,.dir_lru_v_i(dir_lru_v_lo)</pre>
<pre>      ,.dir_lru_cached_excl_i(dir_lru_cached_excl_lo)</pre>
<pre>      ,.dir_lru_tag_i(dir_lru_tag_lo)</pre>
<pre>      ,.dir_tag_i(dir_tag_lo)</pre>
<pre></pre>
<pre>      ,.gad_transfer_lce_i(gad_transfer_lce_lo)</pre>
<pre>      ,.gad_transfer_lce_way_i(gad_transfer_lce_way_lo)</pre>
<pre>      ,.gad_transfer_flag_i(gad_transfer_flag_lo)</pre>
<pre>      ,.gad_replacement_flag_i(gad_replacement_flag_lo)</pre>
<pre>      ,.gad_upgrade_flag_i(gad_upgrade_flag_lo)</pre>
<pre>      ,.gad_invalidate_flag_i(gad_invalidate_flag_lo)</pre>
<pre>      ,.gad_cached_flag_i(gad_cached_flag_lo)</pre>
<pre>      ,.gad_cached_exclusive_flag_i(gad_cached_exclusive_flag_lo)</pre>
<pre>      ,.gad_cached_owned_flag_i(gad_cached_owned_flag_lo)</pre>
<pre>      ,.gad_cached_dirty_flag_i(gad_cached_dirty_flag_lo)</pre>
<pre></pre>
<pre>      ,.cfg_addr_i(cfg_addr_i)</pre>
<pre>      ,.cfg_data_i(cfg_data_i)</pre>
<pre></pre>
<pre>      ,.gpr_o(gpr_r_lo)</pre>
<pre>      ,.nc_data_o(nc_data_r_lo)</pre>
<pre>      ,.num_lce_o(num_lce_r_lo)</pre>
<pre>      );</pre>
<pre>    #(.cfg_p(cfg_p)</pre>
<pre>      )</pre>
<pre style="background-color: #FF0000;">     (.clk_i(clk_i)</pre>
<pre>      ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>      ,.cce_mode_i(cce_mode_lo)</pre>
<pre></pre>
<pre>      ,.lce_req_v_i(lce_req_v_i)</pre>
<pre>      ,.lce_req_yumi_o(lce_req_yumi_o)</pre>
<pre></pre>
<pre>      ,.lce_resp_v_i(lce_resp_v_i)</pre>
<pre>      ,.lce_resp_yumi_o(lce_resp_yumi_o)</pre>
<pre></pre>
<pre>      ,.lce_cmd_v_o(lce_cmd_v_o)</pre>
<pre>      ,.lce_cmd_ready_i(lce_cmd_ready_i)</pre>
<pre></pre>
<pre>      ,.mem_resp_v_i(mem_resp_v_i)</pre>
<pre>      ,.mem_resp_yumi_o(mem_resp_yumi_o)</pre>
<pre>      ,.mem_cmd_i(mem_cmd_i)</pre>
<pre>      ,.mem_cmd_v_i(mem_cmd_v_i)</pre>
<pre>      ,.mem_cmd_yumi_o(mem_cmd_yumi_o)</pre>
<pre></pre>
<pre>      ,.mem_cmd_v_o(mem_cmd_v_o)</pre>
<pre>      ,.mem_cmd_ready_i(mem_cmd_ready_i)</pre>
<pre>      ,.mem_resp_o(mem_resp_lo)</pre>
<pre>      ,.mem_resp_v_o(mem_resp_v_o)</pre>
<pre>      ,.mem_resp_ready_i(mem_resp_ready_i)</pre>
<pre></pre>
<pre>      ,.decoded_inst_i(decoded_inst_lo)</pre>
<pre></pre>
<pre>      ,.pending_w_way_group_o(pending_w_way_group_from_msg)</pre>
<pre>      ,.pending_o(pending_from_msg)</pre>
<pre></pre>
<pre>      ,.lce_cmd_busy_o(lce_cmd_busy_from_msg)</pre>
<pre></pre>
<pre>      ,.sharers_ways_i(sharers_ways_lo)</pre>
<pre>      ,.nc_data_i(nc_data_r_lo)</pre>
<pre></pre>
<pre>      );</pre>
<pre>  begin</pre>
<pre>    case (decoded_inst_lo.dir_way_group_sel)</pre>
<pre>      e_dir_wg_sel_r0: begin</pre>
<pre>        dir_way_group_li = gpr_r_lo[e_gpr_r0][lg_num_way_groups_lp-1:0];</pre>
<pre>      end</pre>
<pre>        dir_way_group_li = gpr_r_lo[e_gpr_r1][lg_num_way_groups_lp-1:0];</pre>
<pre>      end</pre>
<pre>        dir_way_group_li = gpr_r_lo[e_gpr_r2][lg_num_way_groups_lp-1:0];</pre>
<pre>      end</pre>
<pre>        dir_way_group_li = gpr_r_lo[e_gpr_r3][lg_num_way_groups_lp-1:0];</pre>
<pre>      end</pre>
<pre>        dir_way_group_li = gpr_r_lo[e_gpr_r4][lg_num_way_groups_lp-1:0];</pre>
<pre>      end</pre>
<pre>        dir_way_group_li = gpr_r_lo[e_gpr_r5][lg_num_way_groups_lp-1:0];</pre>
<pre>      end</pre>
<pre>        dir_way_group_li = gpr_r_lo[e_gpr_r6][lg_num_way_groups_lp-1:0];</pre>
<pre>      end</pre>
<pre>        dir_way_group_li = gpr_r_lo[e_gpr_r7][lg_num_way_groups_lp-1:0];</pre>
<pre>      end</pre>
<pre>        dir_way_group_li = mshr.paddr[way_group_offset_high_lp-1 -: lg_num_way_groups_lp];</pre>
<pre>      end</pre>
<pre>        dir_way_group_li = mshr.lru_paddr[way_group_offset_high_lp-1 -: lg_num_way_groups_lp];</pre>
<pre>      end</pre>
<pre>        dir_way_group_li = '0;</pre>
<pre>      end</pre>
<pre>      e_dir_lce_sel_r0: dir_lce_li = gpr_r_lo[e_gpr_r0][lg_num_lce_lp-1:0];</pre>
<pre>      e_dir_lce_sel_r1: dir_lce_li = gpr_r_lo[e_gpr_r1][lg_num_lce_lp-1:0];</pre>
<pre>      e_dir_lce_sel_r2: dir_lce_li = gpr_r_lo[e_gpr_r2][lg_num_lce_lp-1:0];</pre>
<pre>      e_dir_lce_sel_r3: dir_lce_li = gpr_r_lo[e_gpr_r3][lg_num_lce_lp-1:0];</pre>
<pre>      e_dir_lce_sel_r4: dir_lce_li = gpr_r_lo[e_gpr_r4][lg_num_lce_lp-1:0];</pre>
<pre>      e_dir_lce_sel_r5: dir_lce_li = gpr_r_lo[e_gpr_r5][lg_num_lce_lp-1:0];</pre>
<pre>      e_dir_lce_sel_r6: dir_lce_li = gpr_r_lo[e_gpr_r6][lg_num_lce_lp-1:0];</pre>
<pre>      e_dir_lce_sel_r7: dir_lce_li = gpr_r_lo[e_gpr_r7][lg_num_lce_lp-1:0];</pre>
<pre>      e_dir_lce_sel_req_lce: dir_lce_li = mshr.lce_id;</pre>
<pre>      e_dir_lce_sel_transfer_lce: dir_lce_li = mshr.tr_lce_id;</pre>
<pre>      default: dir_lce_li = '0;</pre>
<pre>    endcase</pre>
<pre>      e_dir_way_sel_r0: dir_way_li = gpr_r_lo[e_gpr_r0][lg_lce_assoc_lp-1:0];</pre>
<pre>      e_dir_way_sel_r1: dir_way_li = gpr_r_lo[e_gpr_r1][lg_lce_assoc_lp-1:0];</pre>
<pre>      e_dir_way_sel_r2: dir_way_li = gpr_r_lo[e_gpr_r2][lg_lce_assoc_lp-1:0];</pre>
<pre>      e_dir_way_sel_r3: dir_way_li = gpr_r_lo[e_gpr_r3][lg_lce_assoc_lp-1:0];</pre>
<pre>      e_dir_way_sel_r4: dir_way_li = gpr_r_lo[e_gpr_r4][lg_lce_assoc_lp-1:0];</pre>
<pre>      e_dir_way_sel_r5: dir_way_li = gpr_r_lo[e_gpr_r5][lg_lce_assoc_lp-1:0];</pre>
<pre>      e_dir_way_sel_r6: dir_way_li = gpr_r_lo[e_gpr_r6][lg_lce_assoc_lp-1:0];</pre>
<pre>      e_dir_way_sel_r7: dir_way_li = gpr_r_lo[e_gpr_r7][lg_lce_assoc_lp-1:0];</pre>
<pre>      e_dir_way_sel_req_addr_way: dir_way_li = mshr.way_id;</pre>
<pre>      e_dir_way_sel_lru_way_addr_way: dir_way_li = mshr.lru_way_id;</pre>
<pre>      e_dir_way_sel_sh_way_r0: dir_way_li = sharers_ways_lo[gpr_r_lo[e_gpr_r0][lg_num_lce_lp-1:0]];</pre>
<pre>      default: dir_way_li = '0;</pre>
<pre>    endcase</pre>
<pre>      e_dir_coh_sel_r0: dir_coh_state_li = gpr_r_lo[e_gpr_r0][`bp_coh_bits-1:0];</pre>
<pre>      e_dir_coh_sel_r1: dir_coh_state_li = gpr_r_lo[e_gpr_r1][`bp_coh_bits-1:0];</pre>
<pre>      e_dir_coh_sel_r2: dir_coh_state_li = gpr_r_lo[e_gpr_r2][`bp_coh_bits-1:0];</pre>
<pre>      e_dir_coh_sel_r3: dir_coh_state_li = gpr_r_lo[e_gpr_r3][`bp_coh_bits-1:0];</pre>
<pre>      e_dir_coh_sel_r4: dir_coh_state_li = gpr_r_lo[e_gpr_r4][`bp_coh_bits-1:0];</pre>
<pre>      e_dir_coh_sel_r5: dir_coh_state_li = gpr_r_lo[e_gpr_r5][`bp_coh_bits-1:0];</pre>
<pre>      e_dir_coh_sel_r6: dir_coh_state_li = gpr_r_lo[e_gpr_r6][`bp_coh_bits-1:0];</pre>
<pre>      e_dir_coh_sel_r7: dir_coh_state_li = gpr_r_lo[e_gpr_r7][`bp_coh_bits-1:0];</pre>
<pre>      e_dir_coh_sel_next_coh_st: dir_coh_state_li = mshr.next_coh_state;</pre>
<pre>      e_dir_coh_sel_inst_imm: dir_coh_state_li = decoded_inst_lo.imm[`bp_coh_bits-1:0];</pre>
<pre>      default: dir_coh_state_li = '0;</pre>
<pre>    endcase</pre>
<pre>      e_dir_tag_sel_r0: dir_tag_li = gpr_r_lo[e_gpr_r0][paddr_width_p-1 -: tag_width_lp];</pre>
<pre>      e_dir_tag_sel_r1: dir_tag_li = gpr_r_lo[e_gpr_r1][paddr_width_p-1 -: tag_width_lp];</pre>
<pre>      e_dir_tag_sel_r2: dir_tag_li = gpr_r_lo[e_gpr_r2][paddr_width_p-1 -: tag_width_lp];</pre>
<pre>      e_dir_tag_sel_r3: dir_tag_li = gpr_r_lo[e_gpr_r3][paddr_width_p-1 -: tag_width_lp];</pre>
<pre>      e_dir_tag_sel_r4: dir_tag_li = gpr_r_lo[e_gpr_r4][paddr_width_p-1 -: tag_width_lp];</pre>
<pre>      e_dir_tag_sel_r5: dir_tag_li = gpr_r_lo[e_gpr_r5][paddr_width_p-1 -: tag_width_lp];</pre>
<pre>      e_dir_tag_sel_r6: dir_tag_li = gpr_r_lo[e_gpr_r6][paddr_width_p-1 -: tag_width_lp];</pre>
<pre>      e_dir_tag_sel_r7: dir_tag_li = gpr_r_lo[e_gpr_r7][paddr_width_p-1 -: tag_width_lp];</pre>
<pre>      e_dir_tag_sel_req_addr: dir_tag_li = mshr.paddr[paddr_width_p-1 -: tag_width_lp];</pre>
<pre>      e_dir_tag_sel_lru_way_addr: dir_tag_li = mshr.lru_paddr[paddr_width_p-1 -: tag_width_lp];</pre>
<pre>      e_dir_tag_sel_const_0: dir_tag_li = '0;</pre>
<pre>      default: dir_tag_li = '0;</pre>
<pre>    endcase</pre>
<pre>  assign sharers_hits_r0 = sharers_hits_lo[gpr_r_lo[e_gpr_r0][lg_num_lce_lp-1:0]];</pre>
<pre>  logic [lg_lce_assoc_lp-1:0] sharers_ways_r0;</pre>
<pre>  assign sharers_ways_r0 = sharers_ways_lo[gpr_r_lo[e_gpr_r0][lg_num_lce_lp-1:0]];</pre>
<pre>  logic [`bp_coh_bits-1:0] sharers_coh_states_r0;</pre>
<pre>  assign sharers_coh_states_r0 = sharers_coh_states_lo[gpr_r_lo[e_gpr_r0][lg_num_lce_lp-1:0]];</pre>
<pre></pre>
<pre>  begin</pre>
<pre></pre>
<pre>    case (decoded_inst_lo.src_a_sel)</pre>
<pre>      e_src_sel_gpr: begin</pre>
<pre>        case (decoded_inst_lo.src_a.gpr)</pre>
<pre>          e_src_r0: src_a = gpr_r_lo[e_gpr_r0];</pre>
<pre>          e_src_r1: src_a = gpr_r_lo[e_gpr_r1];</pre>
<pre>          e_src_r2: src_a = gpr_r_lo[e_gpr_r2];</pre>
<pre>          e_src_r3: src_a = gpr_r_lo[e_gpr_r3];</pre>
<pre>          e_src_r4: src_a = gpr_r_lo[e_gpr_r4];</pre>
<pre>          e_src_r5: src_a = gpr_r_lo[e_gpr_r5];</pre>
<pre>          e_src_r6: src_a = gpr_r_lo[e_gpr_r6];</pre>
<pre>          e_src_r7: src_a = gpr_r_lo[e_gpr_r7];</pre>
<pre>          e_src_gpr_imm: src_a = decoded_inst_lo.imm;</pre>
<pre>          default: src_a = '0;</pre>
<pre>        endcase</pre>
<pre>        case (decoded_inst_lo.src_a.flag)</pre>
<pre>          e_src_rqf: src_a[0] = mshr.flags[e_flag_sel_rqf];</pre>
<pre>          e_src_ucf: src_a[0] = mshr.flags[e_flag_sel_ucf];</pre>
<pre>          e_src_nerf: src_a[0] = mshr.flags[e_flag_sel_nerf];</pre>
<pre>          e_src_ldf: src_a[0] = mshr.flags[e_flag_sel_ldf];</pre>
<pre>          e_src_pf: src_a[0] = mshr.flags[e_flag_sel_pf];</pre>
<pre>          e_src_lef: src_a[0] = mshr.flags[e_flag_sel_lef];</pre>
<pre>          e_src_cf: src_a[0] = mshr.flags[e_flag_sel_cf];</pre>
<pre>          e_src_cef: src_a[0] = mshr.flags[e_flag_sel_cef];</pre>
<pre>          e_src_cof: src_a[0] = mshr.flags[e_flag_sel_cof];</pre>
<pre>          e_src_cdf: src_a[0] = mshr.flags[e_flag_sel_cdf];</pre>
<pre>          e_src_tf: src_a[0] = mshr.flags[e_flag_sel_tf];</pre>
<pre>          e_src_rf: src_a[0] = mshr.flags[e_flag_sel_rf];</pre>
<pre>          e_src_uf: src_a[0] = mshr.flags[e_flag_sel_uf];</pre>
<pre>          e_src_if: src_a[0] = mshr.flags[e_flag_sel_if];</pre>
<pre>          e_src_nwbf: src_a[0] = mshr.flags[e_flag_sel_nwbf];</pre>
<pre>          e_src_flag_imm: src_a = decoded_inst_lo.imm;</pre>
<pre>          default: src_a = '0;</pre>
<pre>        endcase</pre>
<pre>        case (decoded_inst_lo.src_a.special)</pre>
<pre>          e_src_sharers_hit_r0: src_a[0] = sharers_hits_r0;</pre>
<pre>          e_src_sharers_way_r0: src_a[0+:lg_lce_assoc_lp] = sharers_ways_r0;</pre>
<pre>          e_src_sharers_state_r0: src_a[0+:`bp_coh_bits] = sharers_coh_states_r0;</pre>
<pre>          e_src_req_lce: src_a[0+:lg_num_lce_lp] = mshr.lce_id;</pre>
<pre>          e_src_next_coh_state: src_a[0+:`bp_coh_bits] = mshr.next_coh_state;</pre>
<pre>          e_src_lce_req_v: src_a[0] = lce_req_v_i;</pre>
<pre>          e_src_mem_resp_v: src_a[0] = mem_resp_v_i;</pre>
<pre>          e_src_pending_v: src_a = '0; // TODO: v2</pre>
<pre>          e_src_lce_resp_v: src_a[0] = lce_resp_v_i;</pre>
<pre>          e_src_mem_cmd_v: src_a[0] = mem_cmd_v_i;</pre>
<pre>          e_src_lce_resp_type: src_a[0+:$bits(bp_lce_cce_resp_type_e)] = lce_resp_li.msg_type;</pre>
<pre>          e_src_special_imm: src_a = decoded_inst_lo.imm;</pre>
<pre>          default: src_a = '0;</pre>
<pre>        endcase</pre>
<pre>    endcase // src_a</pre>
<pre>    case (decoded_inst_lo.src_b_sel)</pre>
<pre>      e_src_sel_gpr: begin</pre>
<pre>        case (decoded_inst_lo.src_b.gpr)</pre>
<pre>          e_src_r0: src_b = gpr_r_lo[e_gpr_r0];</pre>
<pre>          e_src_r1: src_b = gpr_r_lo[e_gpr_r1];</pre>
<pre>          e_src_r2: src_b = gpr_r_lo[e_gpr_r2];</pre>
<pre>          e_src_r3: src_b = gpr_r_lo[e_gpr_r3];</pre>
<pre>          e_src_r4: src_b = gpr_r_lo[e_gpr_r4];</pre>
<pre>          e_src_r5: src_b = gpr_r_lo[e_gpr_r5];</pre>
<pre>          e_src_r6: src_b = gpr_r_lo[e_gpr_r6];</pre>
<pre>          e_src_r7: src_b = gpr_r_lo[e_gpr_r7];</pre>
<pre>          e_src_gpr_imm: src_b = decoded_inst_lo.imm;</pre>
<pre>          default: src_b = '0;</pre>
<pre>        endcase</pre>
<pre>        case (decoded_inst_lo.src_b.flag)</pre>
<pre>          e_src_rqf: src_b[0] = mshr.flags[e_flag_sel_rqf];</pre>
<pre>          e_src_ucf: src_b[0] = mshr.flags[e_flag_sel_ucf];</pre>
<pre>          e_src_nerf: src_b[0] = mshr.flags[e_flag_sel_nerf];</pre>
<pre>          e_src_ldf: src_b[0] = mshr.flags[e_flag_sel_ldf];</pre>
<pre>          e_src_pf: src_b[0] = mshr.flags[e_flag_sel_pf];</pre>
<pre>          e_src_lef: src_b[0] = mshr.flags[e_flag_sel_lef];</pre>
<pre>          e_src_cf: src_b[0] = mshr.flags[e_flag_sel_cf];</pre>
<pre>          e_src_cef: src_b[0] = mshr.flags[e_flag_sel_cef];</pre>
<pre>          e_src_cof: src_b[0] = mshr.flags[e_flag_sel_cof];</pre>
<pre>          e_src_cdf: src_b[0] = mshr.flags[e_flag_sel_cdf];</pre>
<pre>          e_src_tf: src_b[0] = mshr.flags[e_flag_sel_tf];</pre>
<pre>          e_src_rf: src_b[0] = mshr.flags[e_flag_sel_rf];</pre>
<pre>          e_src_uf: src_b[0] = mshr.flags[e_flag_sel_uf];</pre>
<pre>          e_src_if: src_b[0] = mshr.flags[e_flag_sel_if];</pre>
<pre>          e_src_nwbf: src_b[0] = mshr.flags[e_flag_sel_nwbf];</pre>
<pre>          e_src_flag_imm: src_b = decoded_inst_lo.imm;</pre>
<pre>          default: src_b = '0;</pre>
<pre>        endcase</pre>
<pre>        case (decoded_inst_lo.src_b.special)</pre>
<pre>          e_src_sharers_hit_r0: src_b[0] = sharers_hits_r0;</pre>
<pre>          e_src_sharers_way_r0: src_b[0+:lg_lce_assoc_lp] = sharers_ways_r0;</pre>
<pre>          e_src_sharers_state_r0: src_b[0+:`bp_coh_bits] = sharers_coh_states_r0;</pre>
<pre>          e_src_req_lce: src_b[0+:lg_num_lce_lp] = mshr.lce_id;</pre>
<pre>          e_src_next_coh_state: src_b[0+:`bp_coh_bits] = mshr.next_coh_state;</pre>
<pre>          e_src_lce_req_v: src_b[0] = lce_req_v_i;</pre>
<pre>          e_src_mem_resp_v: src_b[0] = mem_resp_v_i;</pre>
<pre>          e_src_pending_v: src_b = '0; // TODO: v2</pre>
<pre>          e_src_lce_resp_v: src_b[0] = lce_resp_v_i;</pre>
<pre>          e_src_mem_cmd_v: src_b[0] = mem_cmd_v_i;</pre>
<pre>          e_src_lce_resp_type: src_b[0+:$bits(bp_lce_cce_resp_type_e)] = lce_resp_li.msg_type;</pre>
<pre>          e_src_special_imm: src_b = decoded_inst_lo.imm;</pre>
<pre>          default: src_b = '0;</pre>
<pre>        endcase</pre>
<pre>    endcase // src_b</pre>
<h3>./bp_fe/src/v/bp_fe_lce.v</h3>
<pre> *</pre>
<pre style="background-color: #FF0000;"> * Parameters:</pre>
<pre> *</pre>
<pre style="background-color: #FF0000;"> * Inputs:</pre>
<pre>module bp_fe_lce</pre>
<pre>   `declare_bp_proc_params(cfg_p)</pre>
<pre>                                 ,lce_assoc_p</pre>
<pre>    , input                                                      reset_i</pre>
<pre>    , input                                                      freeze_i</pre>
<pre></pre>
<pre>    , input [cfg_addr_width_p-1:0]                               cfg_addr_i</pre>
<pre>    , input [cfg_data_width_p-1:0]                               cfg_data_i</pre>
<pre></pre>
<pre></pre>
<pre>    , output logic                                               cache_miss_o</pre>
<pre></pre>
<pre>    , input [paddr_width_p-1:0]                                  miss_addr_i</pre>
<pre></pre>
<pre></pre>
<pre>    , output logic [data_mem_pkt_width_lp-1:0]                   data_mem_pkt_o</pre>
<pre>    , output logic                                               data_mem_pkt_v_o</pre>
<pre>    , input                                                      data_mem_pkt_yumi_i</pre>
<pre></pre>
<pre>    , output logic                                               tag_mem_pkt_v_o</pre>
<pre>    , input                                                      tag_mem_pkt_yumi_i</pre>
<pre>       </pre>
<pre>    , output logic [stat_mem_pkt_width_lp-1:0]                   stat_mem_pkt_o</pre>
<pre>    , input [way_id_width_lp-1:0]                                lru_way_i</pre>
<pre>    , input                                                      stat_mem_pkt_yumi_i</pre>
<pre>      </pre>
<pre style="background-color: #FF0000;">    // LCE-CCE interface </pre>
<pre>    , output logic [lce_cce_req_width_lp-1:0] lce_req_o</pre>
<pre>    , output logic lce_req_v_o</pre>
<pre>    , input lce_req_ready_i</pre>
<pre></pre>
<pre>    , output logic [lce_cce_resp_width_lp-1:0] lce_resp_o</pre>
<pre>    , output logic lce_resp_v_o</pre>
<pre>    , input lce_resp_ready_i</pre>
<pre></pre>
<pre>    , input lce_cmd_v_i</pre>
<pre>    , output logic lce_cmd_ready_o</pre>
<pre></pre>
<pre>    , output logic [lce_cmd_width_lp-1:0] lce_cmd_o</pre>
<pre>    , output logic lce_cmd_v_o</pre>
<pre>    , input lce_cmd_ready_i</pre>
<pre></pre>
<pre>    , output bp_fe_icache_lce_mode_e                  lce_mode_o</pre>
<pre>  );</pre>
<pre></pre>
<pre>  // LCE Mode control</pre>
<pre>  bp_fe_icache_lce_mode_e lce_mode_r, lce_mode_n;</pre>
<pre>  assign lce_mode_o = lce_mode_r;</pre>
<pre></pre>
<pre>  logic lce_mode_w_v, lce_mode_addr_v;</pre>
<pre>  assign lce_mode_addr_v = (cfg_addr_i == bp_cfg_reg_icache_mode_gp);</pre>
<pre>  assign lce_mode_w_v = freeze_i & cfg_w_v_i & lce_mode_addr_v;</pre>
<pre>  assign lce_mode_n = bp_fe_icache_lce_mode_e'(cfg_data_i[0+:`bp_fe_icache_lce_mode_bits]);</pre>
<pre></pre>
<pre>  always_ff @(posedge clk_i) begin</pre>
<pre>    if (reset_i) begin</pre>
<pre>      lce_mode_r <= e_icache_lce_mode_uncached;</pre>
<pre>    end else begin</pre>
<pre>      if (lce_mode_w_v) begin</pre>
<pre>        lce_mode_r <= lce_mode_n;</pre>
<pre>      end</pre>
<pre>    end</pre>
<pre></pre>
<pre></pre>
<pre>  `declare_bp_lce_cce_if(num_cce_p, num_lce_p, paddr_width_p, lce_assoc_p, dword_width_p, cce_block_width_p);</pre>
<pre></pre>
<pre>  `declare_bp_fe_icache_lce_data_mem_pkt_s(lce_sets_p, lce_assoc_p, cce_block_width_p);</pre>
<pre>  `declare_bp_fe_icache_lce_tag_mem_pkt_s(lce_sets_p, lce_assoc_p, tag_width_lp);</pre>
<pre>  `declare_bp_fe_icache_lce_stat_mem_pkt_s(lce_sets_p, lce_assoc_p);</pre>
<pre></pre>
<pre>  bp_lce_cce_req_s lce_req;</pre>
<pre>  bp_lce_cce_resp_s lce_resp;</pre>
<pre>  bp_lce_cmd_s lce_cmd;</pre>
<pre>  bp_lce_cmd_s lce_cmd_out;</pre>
<pre></pre>
<pre>  bp_fe_icache_lce_data_mem_pkt_s data_mem_pkt;</pre>
<pre>  bp_fe_icache_lce_tag_mem_pkt_s tag_mem_pkt;</pre>
<pre>  bp_fe_icache_lce_stat_mem_pkt_s stat_mem_pkt;</pre>
<pre></pre>
<pre>  assign lce_req_o           = lce_req;</pre>
<pre>  assign lce_resp_o          = lce_resp;</pre>
<pre>  assign lce_cmd          = lce_cmd_i;</pre>
<pre>  assign lce_cmd_o    = lce_cmd_out;</pre>
<pre></pre>
<pre>  assign data_mem_pkt_o        = data_mem_pkt;</pre>
<pre>  assign tag_mem_pkt_o         = tag_mem_pkt;</pre>
<pre>  assign stat_mem_pkt_o    = stat_mem_pkt;</pre>
<pre></pre>
<pre>  // lce_REQ</pre>
<pre>  bp_lce_cce_resp_s lce_req_lce_resp_lo;</pre>
<pre>  logic cce_data_received;</pre>
<pre>  logic uncached_data_received;</pre>
<pre>  logic set_tag_received;</pre>
<pre>  logic set_tag_wakeup_received;</pre>
<pre>  logic lce_req_lce_resp_v_lo;</pre>
<pre>  logic lce_req_lce_resp_yumi_li;</pre>
<pre>  logic [paddr_width_p-1:0] miss_addr_lo;</pre>
<pre></pre>
<pre>  bp_fe_lce_req #(.cfg_p(cfg_p))</pre>
<pre>    lce_req_inst (</pre>
<pre style="background-color: #FF0000;">    .clk_i(clk_i)</pre>
<pre>    ,.reset_i(reset_i)</pre>
<pre>  </pre>
<pre>    ,.lce_id_i(lce_id_i)</pre>
<pre></pre>
<pre>    ,.miss_i(miss_i)</pre>
<pre>    ,.miss_addr_i(miss_addr_i)</pre>
<pre>    ,.lru_way_i(lru_way_i)</pre>
<pre>    ,.uncached_req_i(uncached_req_i)</pre>
<pre></pre>
<pre>    ,.miss_addr_o(miss_addr_lo)</pre>
<pre></pre>
<pre>    ,.uncached_data_received_i(uncached_data_received)</pre>
<pre>    ,.set_tag_received_i(set_tag_received)</pre>
<pre>    ,.set_tag_wakeup_received_i(set_tag_wakeup_received)</pre>
<pre></pre>
<pre>    ,.lce_req_v_o(lce_req_v_o)</pre>
<pre>    ,.lce_req_ready_i(lce_req_ready_i)</pre>
<pre></pre>
<pre>    ,.lce_resp_v_o(lce_req_lce_resp_v_lo)</pre>
<pre>    ,.lce_resp_yumi_i(lce_req_lce_resp_yumi_li)</pre>
<pre>  );</pre>
<pre>  </pre>
<pre>  logic lce_cmd_lce_resp_v_lo;</pre>
<pre>  logic lce_cmd_lce_resp_yumi_li;</pre>
<pre></pre>
<pre>    lce_cmd_inst (</pre>
<pre style="background-color: #FF0000;">    .clk_i(clk_i)</pre>
<pre>    ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>    ,.miss_addr_i(miss_addr_lo)</pre>
<pre></pre>
<pre>    ,.set_tag_received_o(set_tag_received)</pre>
<pre>    ,.set_tag_wakeup_received_o(set_tag_wakeup_received)</pre>
<pre>    ,.cce_data_received_o(cce_data_received)</pre>
<pre>    ,.uncached_data_received_o(uncached_data_received)</pre>
<pre></pre>
<pre>    ,.data_mem_pkt_v_o(data_mem_pkt_v_o)</pre>
<pre>    ,.data_mem_pkt_yumi_i(data_mem_pkt_yumi_i)</pre>
<pre>    ,.data_mem_data_i(data_mem_data_i)</pre>
<pre></pre>
<pre>    ,.tag_mem_pkt_v_o(tag_mem_pkt_v_o)</pre>
<pre>    ,.tag_mem_pkt_yumi_i(tag_mem_pkt_yumi_i)                 </pre>
<pre></pre>
<pre>    ,.stat_mem_pkt_o(stat_mem_pkt)</pre>
<pre>    ,.stat_mem_pkt_yumi_i(stat_mem_pkt_yumi_i)</pre>
<pre></pre>
<pre>    ,.lce_cmd_v_i(lce_cmd_v_i)</pre>
<pre>    ,.lce_cmd_ready_o(lce_cmd_ready_o)</pre>
<pre></pre>
<pre>    ,.lce_resp_v_o(lce_cmd_lce_resp_v_lo)</pre>
<pre>    ,.lce_resp_yumi_i(lce_cmd_lce_resp_yumi_li)</pre>
<pre></pre>
<pre>    ,.lce_cmd_v_o(lce_cmd_v_o)</pre>
<pre>    ,.lce_cmd_ready_i(lce_cmd_ready_i)</pre>
<pre>  );</pre>
<pre>    lce_req_lce_resp_yumi_li = 1'b0; </pre>
<pre>    lce_cmd_lce_resp_yumi_li = 1'b0; </pre>
<pre></pre>
<pre>      lce_resp_v_o = 1'b1;</pre>
<pre>      lce_resp = lce_req_lce_resp_lo;</pre>
<pre>      lce_req_lce_resp_yumi_li = lce_resp_ready_i;</pre>
<pre>    end</pre>
<pre>      lce_resp_v_o = lce_cmd_lce_resp_v_lo;</pre>
<pre>      lce_resp = lce_cmd_lce_resp_lo;</pre>
<pre>      lce_cmd_lce_resp_yumi_li = lce_cmd_lce_resp_v_lo & lce_resp_ready_i;</pre>
<pre>    end</pre>
<pre>  logic timeout;</pre>
<pre></pre>
<pre>    timeout       = 1'b0;</pre>
<pre>    timeout_cnt_n = timeout_cnt_r;</pre>
<pre>    </pre>
<pre>      timeout = 1'b1;</pre>
<pre>      timeout_cnt_n = '0;</pre>
<pre>    end</pre>
<pre>      if (data_mem_pkt_v_o | tag_mem_pkt_v_o | stat_mem_pkt_v_o) begin</pre>
<pre>        timeout_cnt_n = ~(data_mem_pkt_yumi_i | tag_mem_pkt_yumi_i | stat_mem_pkt_yumi_i)</pre>
<pre>          ? (timeout_cnt_r + 1)</pre>
<pre>          : '0;</pre>
<pre>      end</pre>
<pre>        timeout_cnt_n = '0;</pre>
<pre>      end</pre>
<pre>    if (reset_i) begin</pre>
<pre>      timeout_cnt_r   <= '0;</pre>
<pre>    end</pre>
<pre>      timeout_cnt_r   <= timeout_cnt_n;</pre>
<pre>    end</pre>
<pre>  assign lce_ready = (lce_mode_r == e_icache_lce_mode_uncached) ? ~freeze_i : lce_ready_lo;</pre>
<pre>  assign ready_o = lce_ready & ~timeout & ~cache_miss_o;</pre>
<pre> </pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./bp_me/src/v/cce/bp_cce_msg.v</h3>
<pre> *</pre>
<pre style="background-color: #FF0000;"> *   Processing of a Memory Data Response takes priority over processing of any other memory</pre>
<pre style="background-color: #FF0000;"> *   messages being sent or received. This arbitration is handled by the instruction decoder.</pre>
<pre>module bp_cce_msg</pre>
<pre>    `declare_bp_proc_params(cfg_p)</pre>
<pre>    , localparam lg_num_lce_lp             = `BSG_SAFE_CLOG2(num_lce_p)</pre>
<pre>    , localparam lg_num_cce_lp             = `BSG_SAFE_CLOG2(num_cce_p)</pre>
<pre>    , localparam lg_block_size_in_bytes_lp = `BSG_SAFE_CLOG2(block_size_in_bytes_lp)</pre>
<pre>    , localparam lg_lce_assoc_lp           = `BSG_SAFE_CLOG2(lce_assoc_p)</pre>
<pre>    , localparam lg_lce_sets_lp            = `BSG_SAFE_CLOG2(lce_sets_p)</pre>
<pre>    , localparam num_way_groups_lp         = (lce_sets_p/num_cce_p)</pre>
<pre>    , localparam lg_num_way_groups_lp      = `BSG_SAFE_CLOG2(num_way_groups_lp)</pre>
<pre>    , localparam mshr_width_lp = `bp_cce_mshr_width(num_lce_p, lce_assoc_p, paddr_width_p)</pre>
<pre>   , input                                             reset_i</pre>
<pre></pre>
<pre>   , input bp_cce_mode_e                               cce_mode_i</pre>
<pre></pre>
<pre>   // outbound: ready&valid (connects directly to ME network)</pre>
<pre>   , input                                             lce_req_v_i</pre>
<pre>   , output logic                                      lce_req_yumi_o</pre>
<pre></pre>
<pre>   , input                                             lce_resp_v_i</pre>
<pre>   , output logic                                      lce_resp_yumi_o</pre>
<pre></pre>
<pre>   , output logic                                      lce_cmd_v_o</pre>
<pre>   , input                                             lce_cmd_ready_i</pre>
<pre></pre>
<pre>   , input                                             mem_resp_v_i</pre>
<pre>   , output logic                                      mem_resp_yumi_o</pre>
<pre></pre>
<pre>   , input                                             mem_cmd_v_i</pre>
<pre>   , output logic                                      mem_cmd_yumi_o</pre>
<pre></pre>
<pre>   , output logic                                      mem_cmd_v_o</pre>
<pre>   , input                                             mem_cmd_ready_i</pre>
<pre></pre>
<pre>   , output logic [cce_mem_msg_width_lp-1:0]           mem_resp_o</pre>
<pre>   , output logic                                      mem_resp_v_o</pre>
<pre>   , input                                             mem_resp_ready_i</pre>
<pre></pre>
<pre style="background-color: #FF0000;">   // MSHR</pre>
<pre>   , input [mshr_width_lp-1:0]                         mshr_i</pre>
<pre></pre>
<pre>   , input bp_cce_inst_decoded_s                       decoded_inst_i</pre>
<pre></pre>
<pre>   // Pending bit write</pre>
<pre>   , output logic [lg_num_way_groups_lp-1:0]           pending_w_way_group_o</pre>
<pre>   , output logic                                      pending_o</pre>
<pre></pre>
<pre>   // arbitration signals to instruction decode</pre>
<pre>   , output logic                                      lce_cmd_busy_o</pre>
<pre></pre>
<pre>   , input [`bp_cce_inst_num_gpr-1:0][`bp_cce_inst_gpr_width-1:0] gpr_i</pre>
<pre></pre>
<pre>   , input [num_lce_p-1:0][lg_lce_assoc_lp-1:0]        sharers_ways_i</pre>
<pre></pre>
<pre>   , input [dword_width_p-1:0]                         nc_data_i</pre>
<pre></pre>
<pre>   , output logic                                      fence_zero_o</pre>
<pre>  );</pre>
<pre></pre>
<pre>  // Define structure variables for output queues</pre>
<pre>  `declare_bp_me_if(paddr_width_p, cce_block_width_p, num_lce_p, lce_assoc_p);</pre>
<pre>  `declare_bp_lce_cce_if(num_cce_p, num_lce_p, paddr_width_p, lce_assoc_p, dword_width_p, cce_block_width_p);</pre>
<pre></pre>
<pre>  bp_lce_cce_req_s  lce_req_li;</pre>
<pre>  bp_lce_cce_resp_s lce_resp_li;</pre>
<pre>  bp_lce_cmd_s      lce_cmd_lo;</pre>
<pre></pre>
<pre>  bp_cce_mem_msg_s  mem_cmd_li, mem_cmd_lo, mem_resp_li, mem_resp_lo;</pre>
<pre></pre>
<pre>  // assign output queue ports to structure variables</pre>
<pre>  assign lce_cmd_o = lce_cmd_lo;</pre>
<pre>  assign mem_cmd_o = mem_cmd_lo;</pre>
<pre>  assign mem_resp_o = mem_resp_lo;</pre>
<pre></pre>
<pre>  // cast input messages with data</pre>
<pre>  assign mem_resp_li = mem_resp_i;</pre>
<pre>  assign mem_cmd_li = mem_cmd_i;</pre>
<pre>  assign lce_resp_li = lce_resp_i;</pre>
<pre>  assign lce_req_li = lce_req_i;</pre>
<pre></pre>
<pre>  // Message Unit Signals</pre>
<pre>  logic                                          lce_req_yumi_from_msg;</pre>
<pre>  logic                                          lce_resp_yumi_from_msg;</pre>
<pre>  logic [lce_cmd_width_lp-1:0]                   lce_cmd_from_msg;</pre>
<pre>  logic                                          lce_cmd_v_from_msg;</pre>
<pre>  logic                                          mem_resp_yumi_from_msg;</pre>
<pre>  logic                                          mem_cmd_yumi_from_msg;</pre>
<pre>  logic [cce_mem_msg_width_lp-1:0]               mem_cmd_from_msg;</pre>
<pre>  logic                                          mem_cmd_v_from_msg;</pre>
<pre>  logic [cce_mem_msg_width_lp-1:0]               mem_resp_from_msg;</pre>
<pre>  logic                                          mem_resp_v_from_msg;</pre>
<pre></pre>
<pre>  logic                                          lce_req_yumi_from_uc;</pre>
<pre>  logic                                          lce_resp_yumi_from_uc;</pre>
<pre>  logic [lce_cmd_width_lp-1:0]                   lce_cmd_from_uc;</pre>
<pre>  logic                                          lce_cmd_v_from_uc;</pre>
<pre>  logic                                          mem_resp_yumi_from_uc;</pre>
<pre>  logic                                          mem_cmd_yumi_from_uc;</pre>
<pre>  logic [cce_mem_msg_width_lp-1:0]               mem_cmd_from_uc;</pre>
<pre>  logic                                          mem_cmd_v_from_uc;</pre>
<pre>  logic [cce_mem_msg_width_lp-1:0]               mem_resp_from_uc;</pre>
<pre>  logic                                          mem_resp_v_from_uc;</pre>
<pre></pre>
<pre>  // Message unit</pre>
<pre>  bp_cce_msg_cached</pre>
<pre>    #(.num_lce_p(num_lce_p)</pre>
<pre>      ,.num_cce_p(num_cce_p)</pre>
<pre>      ,.paddr_width_p(paddr_width_p)</pre>
<pre>      ,.lce_assoc_p(lce_assoc_p)</pre>
<pre>      ,.lce_sets_p(lce_sets_p)</pre>
<pre>      ,.block_size_in_bytes_p(block_size_in_bytes_lp)</pre>
<pre>      ,.lce_req_data_width_p(dword_width_p)</pre>
<pre>      ,.num_way_groups_p(num_way_groups_lp)</pre>
<pre>      ,.cce_block_width_p(cce_block_width_p)</pre>
<pre>      ,.dword_width_p(dword_width_p)</pre>
<pre>      )</pre>
<pre>    bp_cce_msg_cached</pre>
<pre>     (.clk_i(clk_i)</pre>
<pre>      ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>      ,.cce_mode_i(cce_mode_i)</pre>
<pre></pre>
<pre>      ,.lce_req_v_i(lce_req_v_i)</pre>
<pre>      ,.lce_req_yumi_o(lce_req_yumi_from_msg)</pre>
<pre></pre>
<pre>      ,.lce_resp_v_i(lce_resp_v_i)</pre>
<pre>      ,.lce_resp_yumi_o(lce_resp_yumi_from_msg)</pre>
<pre></pre>
<pre>      ,.lce_cmd_v_o(lce_cmd_v_from_msg)</pre>
<pre>      ,.lce_cmd_ready_i(lce_cmd_ready_i)</pre>
<pre></pre>
<pre>      ,.mem_resp_v_i(mem_resp_v_i)</pre>
<pre>      ,.mem_resp_yumi_o(mem_resp_yumi_from_msg)</pre>
<pre>      ,.mem_cmd_i(mem_cmd_li)</pre>
<pre>      ,.mem_cmd_v_i(mem_cmd_v_i)</pre>
<pre>      ,.mem_cmd_yumi_o(mem_cmd_yumi_from_msg)</pre>
<pre></pre>
<pre>      ,.mem_cmd_v_o(mem_cmd_v_from_msg)</pre>
<pre>      ,.mem_cmd_ready_i(mem_cmd_ready_i)</pre>
<pre>      ,.mem_resp_o(mem_resp_from_msg)</pre>
<pre>      ,.mem_resp_v_o(mem_resp_v_from_msg)</pre>
<pre>      ,.mem_resp_ready_i(mem_resp_ready_i)</pre>
<pre></pre>
<pre>      ,.decoded_inst_i(decoded_inst_i)</pre>
<pre></pre>
<pre>      ,.pending_w_way_group_o(pending_w_way_group_o)</pre>
<pre>      ,.pending_o(pending_o)</pre>
<pre></pre>
<pre>      ,.lce_cmd_busy_o(lce_cmd_busy_o)</pre>
<pre></pre>
<pre>      ,.sharers_ways_i(sharers_ways_i)</pre>
<pre>      ,.nc_data_i(nc_data_i)</pre>
<pre></pre>
<pre>      );</pre>
<pre>    #(.num_lce_p(num_lce_p)</pre>
<pre>      ,.num_cce_p(num_cce_p)</pre>
<pre>      ,.paddr_width_p(paddr_width_p)</pre>
<pre>      ,.lce_assoc_p(lce_assoc_p)</pre>
<pre>      ,.lce_sets_p(lce_sets_p)</pre>
<pre>      ,.block_size_in_bytes_p(block_size_in_bytes_lp)</pre>
<pre>      ,.lce_req_data_width_p(dword_width_p)</pre>
<pre>      )</pre>
<pre style="background-color: #FF0000;">     (.clk_i(clk_i)</pre>
<pre>      ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>      ,.cce_mode_i(cce_mode_i)</pre>
<pre></pre>
<pre>      ,.lce_req_v_i(lce_req_v_i)</pre>
<pre>      ,.lce_req_yumi_o(lce_req_yumi_from_uc)</pre>
<pre></pre>
<pre></pre>
<pre>      ,.lce_cmd_v_o(lce_cmd_v_from_uc)</pre>
<pre>      ,.lce_cmd_ready_i(lce_cmd_ready_i)</pre>
<pre></pre>
<pre>      ,.mem_resp_v_i(mem_resp_v_i)</pre>
<pre>      ,.mem_resp_yumi_o(mem_resp_yumi_from_uc)</pre>
<pre>      ,.mem_cmd_i(mem_cmd_li)</pre>
<pre>      ,.mem_cmd_v_i(mem_cmd_v_i)</pre>
<pre>      ,.mem_cmd_yumi_o(mem_cmd_yumi_from_uc)</pre>
<pre></pre>
<pre>      ,.mem_cmd_v_o(mem_cmd_v_from_uc)</pre>
<pre>      ,.mem_cmd_ready_i(mem_cmd_ready_i)</pre>
<pre>      ,.mem_resp_o(mem_resp_from_uc)</pre>
<pre>      ,.mem_resp_v_o(mem_resp_v_from_uc)</pre>
<pre>      ,.mem_resp_ready_i(mem_resp_ready_i)</pre>
<pre></pre>
<pre>  begin</pre>
<pre>    if (cce_mode_i == e_cce_mode_uncached) begin</pre>
<pre>      lce_resp_yumi_o = '0;</pre>
<pre>      lce_req_yumi_o = lce_req_yumi_from_uc;</pre>
<pre></pre>
<pre>      mem_cmd_yumi_o = mem_cmd_yumi_from_uc;</pre>
<pre>      lce_cmd_v_o = lce_cmd_v_from_uc;</pre>
<pre>      mem_cmd_v_o = mem_cmd_v_from_uc;</pre>
<pre>      mem_resp_v_o = mem_resp_v_from_uc;</pre>
<pre></pre>
<pre>      mem_cmd_lo = mem_cmd_from_uc;</pre>
<pre>      mem_resp_lo = mem_resp_from_uc;</pre>
<pre>    end else begin</pre>
<pre>      lce_req_yumi_o = lce_req_yumi_from_msg;</pre>
<pre>      lce_resp_yumi_o = lce_resp_yumi_from_msg;</pre>
<pre></pre>
<pre>      mem_cmd_yumi_o = mem_cmd_yumi_from_msg;</pre>
<pre>      lce_cmd_v_o = lce_cmd_v_from_msg;</pre>
<pre>      mem_cmd_v_o = mem_cmd_v_from_msg;</pre>
<pre>      mem_resp_v_o = mem_resp_v_from_msg;</pre>
<pre></pre>
<pre>      mem_cmd_lo = mem_cmd_from_msg;</pre>
<pre>      mem_resp_lo = mem_resp_from_msg;</pre>
<pre>    end</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./bp_fe/src/v/bp_fe_pc_gen.v</h3>
<pre> * pc_gen.v provides the interfaces for the pc_gen logics and also interfacing</pre>
<pre style="background-color: #FF0000;"> * other modules in the frontend. PC_gen provides the pc for the itlb and icache.</pre>
<pre style="background-color: #FF0000;"> * PC_gen also provides the BTB, BHT and RAS indexes for the backend (the queue</pre>
<pre> * between the frontend and the backend, i.e. the frontend queue).</pre>
<pre>*/</pre>
<pre></pre>
<pre>module bp_fe_pc_gen</pre>
<pre> import bp_common_pkg::*;</pre>
<pre> import bp_common_rv64_pkg::*;</pre>
<pre> import bp_fe_pkg::*;</pre>
<pre> import bp_common_aviary_pkg::*;</pre>
<pre> #(parameter bp_cfg_e cfg_p = e_bp_inv_cfg</pre>
<pre>   `declare_bp_proc_params(cfg_p)</pre>
<pre>   `declare_bp_fe_be_if_widths(vaddr_width_p, paddr_width_p, asid_width_p, branch_metadata_fwd_width_p)</pre>
<pre></pre>
<pre>   , localparam mem_cmd_width_lp  = `bp_fe_mem_cmd_width(vaddr_width_p, vtag_width_p, ptag_width_p)</pre>
<pre>   , localparam mem_resp_width_lp = `bp_fe_mem_resp_width</pre>
<pre>   )</pre>
<pre>  (input                                             clk_i</pre>
<pre>   , input                                           reset_i</pre>
<pre> </pre>
<pre>   , output [mem_cmd_width_lp-1:0]                   mem_cmd_o</pre>
<pre>   , output                                          mem_cmd_v_o</pre>
<pre>   , input                                           mem_cmd_ready_i</pre>
<pre></pre>
<pre>   , output                                          mem_poison_o</pre>
<pre></pre>
<pre>   , input [mem_resp_width_lp-1:0]                   mem_resp_i</pre>
<pre>   , input                                           mem_resp_v_i</pre>
<pre>   , output                                          mem_resp_ready_o</pre>
<pre></pre>
<pre>   , input [fe_cmd_width_lp-1:0]                     fe_cmd_i</pre>
<pre>   , input                                           fe_cmd_v_i</pre>
<pre>   , output logic                                    fe_cmd_yumi_o</pre>
<pre>   , output                                          fe_cmd_processed_o</pre>
<pre></pre>
<pre>   , output [fe_queue_width_lp-1:0]                  fe_queue_o</pre>
<pre>   , output                                          fe_queue_v_o</pre>
<pre>   , input                                           fe_queue_ready_i</pre>
<pre>   );</pre>
<pre></pre>
<pre>`declare_bp_fe_be_if(vaddr_width_p, paddr_width_p, asid_width_p, branch_metadata_fwd_width_p);</pre>
<pre>`declare_bp_fe_branch_metadata_fwd_s(btb_tag_width_p, btb_idx_width_p, bht_idx_width_p,ras_idx_width_p);</pre>
<pre>`declare_bp_fe_mem_structs(vaddr_width_p, lce_sets_p, cce_block_width_p, vtag_width_p, ptag_width_p)</pre>
<pre>`declare_bp_fe_pc_gen_stage_s(vaddr_width_p);</pre>
<pre></pre>
<pre>bp_fe_mem_cmd_s mem_cmd_cast_o;</pre>
<pre>bp_fe_mem_resp_s mem_resp_cast_i;</pre>
<pre></pre>
<pre>assign mem_cmd_o       = mem_cmd_cast_o;</pre>
<pre>assign mem_resp_cast_i = mem_resp_i;</pre>
<pre></pre>
<pre>// branch prediction wires</pre>
<pre>logic [vaddr_width_p-1:0]       br_target;</pre>
<pre>logic                           ovr_taken, ovr_ntaken;</pre>
<pre>// btb io</pre>
<pre>logic [vaddr_width_p-1:0]       btb_br_tgt_lo;</pre>
<pre>logic                           btb_br_tgt_v_lo;</pre>
<pre></pre>
<pre>bp_fe_queue_s fe_queue_cast_o;</pre>
<pre>bp_fe_cmd_s fe_cmd_cast_i;</pre>
<pre></pre>
<pre>assign fe_cmd_cast_i = fe_cmd_i;</pre>
<pre>assign fe_queue_o = fe_queue_cast_o;</pre>
<pre></pre>
<pre>bp_fe_pc_gen_stage_s [1:0] pc_gen_stage_n, pc_gen_stage_r;</pre>
<pre></pre>
<pre>// Helper signals</pre>
<pre>wire                      v_if1 = pc_gen_stage_r[0].v;</pre>
<pre>wire                      v_if2 = pc_gen_stage_r[1].v;</pre>
<pre>wire [vaddr_width_p-1:0] pc_if1 = pc_gen_stage_r[0].pc;</pre>
<pre>wire [vaddr_width_p-1:0] pc_if2 = pc_gen_stage_r[1].pc;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">// Flags for valid FE commands</pre>
<pre>wire state_reset_v    = fe_cmd_v_i & (fe_cmd_cast_i.opcode == e_op_state_reset); </pre>
<pre>wire pc_redirect_v    = fe_cmd_v_i & (fe_cmd_cast_i.opcode == e_op_pc_redirection);</pre>
<pre>wire itlb_fill_v      = fe_cmd_v_i & (fe_cmd_cast_i.opcode == e_op_itlb_fill_response);</pre>
<pre>wire icache_fence_v   = fe_cmd_v_i & (fe_cmd_cast_i.opcode == e_op_icache_fence);</pre>
<pre>wire itlb_fence_v     = fe_cmd_v_i & (fe_cmd_cast_i.opcode == e_op_itlb_fence);</pre>
<pre>wire attaboy_v        = fe_cmd_v_i & (fe_cmd_cast_i.opcode == e_op_attaboy);</pre>
<pre>wire cmd_nonattaboy_v = fe_cmd_v_i & (fe_cmd_cast_i.opcode != e_op_attaboy);</pre>
<pre></pre>
<pre style="background-color: #FF0000;">// Until we support C, must be aligned to 4 bytes</pre>
<pre style="background-color: #FF0000;">// There's also an interesting question about physical alignment (I/O devices, etc)</pre>
<pre>//   But let's punt that for now...</pre>
<pre style="background-color: #FF0000;">// TODO: misaligned is actually done by the branch target, not the PC</pre>
<pre>wire misalign_exception           = 1'b0;</pre>
<pre>wire itlb_miss_exception          = v_if2 & (mem_resp_v_i & mem_resp_cast_i.itlb_miss);</pre>
<pre>wire instr_access_fault_exception = v_if2 & (mem_resp_v_i & mem_resp_cast_i.instr_access_fault);</pre>
<pre></pre>
<pre>wire fetch_fail     = v_if2 & ~fe_queue_v_o;</pre>
<pre>wire queue_miss     = v_if2 & ~fe_queue_ready_i;</pre>
<pre>wire icache_miss    = v_if2 & (mem_resp_v_i & mem_resp_cast_i.icache_miss);</pre>
<pre>wire flush          = itlb_miss_exception | icache_miss | queue_miss | cmd_nonattaboy_v;</pre>
<pre>wire fe_instr_v     = v_if2 & mem_resp_v_i & ~flush;</pre>
<pre>wire fe_exception_v = v_if2 & (instr_access_fault_exception | misalign_exception | itlb_miss_exception);</pre>
<pre></pre>
<pre>// FSM</pre>
<pre>enum bit [1:0] {e_wait=2'd0, e_run, e_stall} state_n, state_r;</pre>
<pre></pre>
<pre>// Decoded state signals</pre>
<pre>wire is_wait  = (state_r == e_wait);</pre>
<pre>wire is_run   = (state_r == e_run);</pre>
<pre>wire is_stall = (state_r == e_stall);</pre>
<pre></pre>
<pre>// Change the resume pc on redirect command, else save the PC in IF2 while running</pre>
<pre>logic [vaddr_width_p-1:0] pc_resume_n, pc_resume_r;</pre>
<pre>assign pc_resume_n = cmd_nonattaboy_v ? fe_cmd_cast_i.vaddr :  pc_gen_stage_r[1].pc;</pre>
<pre>bsg_dff_reset_en</pre>
<pre> #(.width_p(vaddr_width_p))</pre>
<pre> pc_resume_reg</pre>
<pre>  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre>   ,.en_i(cmd_nonattaboy_v | is_run)</pre>
<pre></pre>
<pre>   ,.data_i(pc_resume_n)</pre>
<pre>   ,.data_o(pc_resume_r)</pre>
<pre>   );</pre>
<pre></pre>
<pre>// Controlling state machine</pre>
<pre>always_comb</pre>
<pre>  case (state_r)</pre>
<pre>    // Wait for FE cmd</pre>
<pre>    e_wait : state_n = cmd_nonattaboy_v ? e_stall : e_wait;</pre>
<pre>    // Stall until we can start valid fetch</pre>
<pre style="background-color: #FF0000;">    e_stall: state_n = pc_gen_stage_n[0].v ? e_run : e_stall;</pre>
<pre>    // Run state -- PCs are actually being fetched</pre>
<pre>    // Stay in run if there's an incoming cmd, the next pc will automatically be valid </pre>
<pre>    // Transition to wait if there's a TLB miss while we wait for fill</pre>
<pre>    // Transition to stall if we don't successfully complete the fetch for whatever reason</pre>
<pre>                       ? e_run </pre>
<pre>                       : fetch_fail </pre>
<pre>                         ? e_stall </pre>
<pre>                         : fe_exception_v </pre>
<pre>                           ? e_wait </pre>
<pre>                           : e_run;</pre>
<pre>    default: state_n = e_wait;</pre>
<pre>  endcase</pre>
<pre>always_ff @(posedge clk_i)</pre>
<pre>  if (reset_i)</pre>
<pre>      state_r <= e_wait;</pre>
<pre>  else</pre>
<pre>    begin </pre>
<pre>      state_r <= state_n;</pre>
<pre>    end</pre>
<pre>always_comb</pre>
<pre>  begin</pre>
<pre>    // We can't fetch from wait state, only run and coming out of stall.</pre>
<pre>    // We wait until both the FE queue and I$ are ready, but flushes invalidate the fetch.</pre>
<pre>    // The next PC is valid during a FE cmd, since it is a non-speculative</pre>
<pre>    //   command and we must accept it immediately.</pre>
<pre>    // FE cmds normally flush the queue, so we don't expect this to affect</pre>
<pre>    pc_gen_stage_n[0].pred_taken = btb_br_tgt_v_lo | ovr_taken;</pre>
<pre>    pc_gen_stage_n[0].ovr        = ovr_taken | ovr_ntaken;</pre>
<pre></pre>
<pre>    // Next PC calculation</pre>
<pre>    // load boot pc on reset command</pre>
<pre>        pc_gen_stage_n[0].pc = fe_cmd_cast_i.vaddr;</pre>
<pre>    // if we need to redirect</pre>
<pre>    else if (pc_redirect_v | icache_fence_v | itlb_fence_v)</pre>
<pre>        pc_gen_stage_n[0].pc = fe_cmd_cast_i.vaddr;</pre>
<pre>    else if (state_r != e_run) </pre>
<pre>        pc_gen_stage_n[0].pc = pc_resume_r;</pre>
<pre>    else if (ovr_taken)</pre>
<pre>        pc_gen_stage_n[0].pc = br_target;</pre>
<pre>    else if (ovr_ntaken)</pre>
<pre>        pc_gen_stage_n[0].pc = pc_gen_stage_r[1].pc + 4;</pre>
<pre>    else if (btb_br_tgt_v_lo)</pre>
<pre>        pc_gen_stage_n[0].pc = btb_br_tgt_lo;</pre>
<pre>    else</pre>
<pre>        pc_gen_stage_n[0].pc = pc_gen_stage_r[0].pc + 4;</pre>
<pre>      end</pre>
<pre>    pc_gen_stage_n[1].v &= ~flush & ~(ovr_taken || ovr_ntaken);</pre>
<pre>  end</pre>
<pre> #(.width_p($bits(bp_fe_pc_gen_stage_s)*2))</pre>
<pre> pc_gen_stage_reg</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>   ,.data_o(pc_gen_stage_r)</pre>
<pre>   );</pre>
<pre>wire                    pred_taken_if2 = pc_gen_stage_r[1].pred_taken;</pre>
<pre>wire [btb_tag_width_p-1:0] btb_tag_if2 = pc_if2[2+btb_idx_width_p+:btb_tag_width_p];</pre>
<pre>wire [btb_idx_width_p-1:0] btb_idx_if2 = pc_if2[2+:btb_idx_width_p];</pre>
<pre>wire [bht_idx_width_p-1:0] bht_idx_if2 = pc_if2[2+:bht_idx_width_p];</pre>
<pre></pre>
<pre>  '{pred_taken: pred_taken_if2</pre>
<pre>    ,btb_tag  : btb_tag_if2</pre>
<pre>    ,btb_idx  : btb_idx_if2</pre>
<pre>    ,bht_idx  : bht_idx_if2</pre>
<pre>    ,default  : '0</pre>
<pre>    };</pre>
<pre> #(.width_p(branch_metadata_fwd_width_p))</pre>
<pre> branch_metadata_fwd_reg</pre>
<pre>  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i) </pre>
<pre>   ,.en_i(fe_queue_v_o)</pre>
<pre></pre>
<pre>   ,.data_o(fe_queue_cast_o_branch_metadata_r)</pre>
<pre>   );</pre>
<pre>assign fe_cmd_branch_metadata = fe_cmd_cast_i.operands.pc_redirect_operands.branch_metadata_fwd;</pre>
<pre>bp_fe_btb</pre>
<pre> #(.vaddr_width_p(vaddr_width_p)</pre>
<pre>   ,.btb_tag_width_p(btb_tag_width_p)</pre>
<pre>   ,.btb_idx_width_p(btb_idx_width_p)</pre>
<pre>   )</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>   ,.r_v_i(pc_gen_stage_n[0].v)</pre>
<pre>   ,.br_tgt_o(btb_br_tgt_lo)</pre>
<pre>   ,.br_tgt_v_o(btb_br_tgt_v_lo)</pre>
<pre></pre>
<pre>   ,.w_idx_i(fe_cmd_branch_metadata.btb_idx)</pre>
<pre>   // Literature says that we should only update btb on taken branches, but I'd like to see</pre>
<pre>   ,.br_tgt_i(fe_cmd_cast_i.vaddr)</pre>
<pre>   );</pre>
<pre>bp_fe_bht</pre>
<pre> #(.bht_idx_width_p(bht_idx_width_p))</pre>
<pre> bp_fe_bht</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>   ,.idx_r_i(fe_queue_cast_o_branch_metadata.bht_idx)</pre>
<pre>   ,.predict_o(bht_pred_lo)</pre>
<pre></pre>
<pre>   ,.idx_w_i(fe_cmd_branch_metadata.bht_idx)</pre>
<pre>   ,.correct_i(attaboy_v)</pre>
<pre>   );</pre>
<pre style="background-color: #FF0000;">`declare_bp_fe_instr_scan_s(vaddr_width_p)</pre>
<pre>bp_fe_instr_scan </pre>
<pre> #(.cfg_p(cfg_p))</pre>
<pre> instr_scan</pre>
<pre style="background-color: #FF0000;">  (.instr_i(mem_resp_cast_i.data)</pre>
<pre></pre>
<pre>   );</pre>
<pre></pre>
<pre style="background-color: #FF0000;">wire is_br        = mem_resp_v_i & (scan_instr.scan_class == e_rvi_branch);</pre>
<pre>wire is_jal       = mem_resp_v_i & (scan_instr.scan_class == e_rvi_jal);</pre>
<pre>assign ovr_taken  = pc_gen_stage_r[1].v & ~pc_gen_stage_r[0].ovr & ~pc_gen_stage_r[0].pred_taken & ((is_br &  bht_pred_lo) | is_jal);</pre>
<pre>assign ovr_ntaken = pc_gen_stage_r[1].v & ~pc_gen_stage_r[0].ovr &  pc_gen_stage_r[0].pred_taken &  (is_br & ~bht_pred_lo);</pre>
<pre>assign br_target  = pc_gen_stage_r[1].pc + scan_instr.imm;</pre>
<pre></pre>
<pre>always_comb</pre>
<pre>  begin</pre>
<pre>    mem_cmd_cast_o = '0;</pre>
<pre></pre>
<pre>      begin</pre>
<pre>        mem_cmd_cast_o.op                   = e_fe_op_tlb_fence;</pre>
<pre>        mem_cmd_cast_o.operands.fetch.vaddr = fe_cmd_cast_i.vaddr;</pre>
<pre>      end</pre>
<pre>      begin</pre>
<pre>        mem_cmd_cast_o.op                  = e_fe_op_tlb_fill;</pre>
<pre>        mem_cmd_cast_o.operands.fill.vtag  = fe_cmd_cast_i.vaddr[vaddr_width_p-1:page_offset_width_p];</pre>
<pre>        mem_cmd_cast_o.operands.fill.entry = fe_cmd_cast_i.operands.itlb_fill_response.pte_entry_leaf;</pre>
<pre>      end</pre>
<pre>        mem_cmd_cast_o.op                   = e_fe_op_fetch;</pre>
<pre>        mem_cmd_cast_o.operands.fetch.vaddr = pc_gen_stage_n[0].pc;</pre>
<pre>      end</pre>
<pre style="background-color: #FF0000;">assign mem_poison_o = ~pc_gen_stage_n[1].v;</pre>
<pre></pre>
<pre>assign mem_resp_ready_o = 1'b1;</pre>
<pre></pre>
<pre>assign fe_cmd_processed_o = fe_cmd_yumi_o; // All FE cmds are processed in 1 cycle, for now</pre>
<pre></pre>
<pre>always_comb</pre>
<pre>  begin</pre>
<pre>    // Set padding to 0</pre>
<pre></pre>
<pre style="background-color: #FF0000;">    if (fe_exception_v)</pre>
<pre>      begin</pre>
<pre>        fe_queue_cast_o.msg_type                     = e_fe_exception;</pre>
<pre>        fe_queue_cast_o.msg.exception.vaddr          = pc_if2;</pre>
<pre>        fe_queue_cast_o.msg.exception.exception_code = misalign_exception</pre>
<pre>                                                       ? e_instr_misaligned</pre>
<pre>                                                       : itlb_miss_exception</pre>
<pre>                                                         ? e_itlb_miss</pre>
<pre>                                                         : e_instr_access_fault;</pre>
<pre>      end</pre>
<pre>        fe_queue_cast_o.msg_type                      = e_fe_fetch;</pre>
<pre>        fe_queue_cast_o.msg.fetch.pc                  = pc_if2;</pre>
<pre>        fe_queue_cast_o.msg.fetch.instr               = mem_resp_cast_i.data;</pre>
<pre>        fe_queue_cast_o.msg.fetch.branch_metadata_fwd = fe_queue_cast_o_branch_metadata_r;</pre>
<pre>      end</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./bp_fe/src/v/bp_fe_instr_scan.v</h3>
<pre>module bp_fe_instr_scan</pre>
<pre>   `declare_bp_proc_params(cfg_p)</pre>
<pre>   , localparam instr_scan_width_lp = `bp_fe_instr_scan_width(vaddr_width_p)</pre>
<pre></pre>
<pre>  );</pre>
<pre style="background-color: #FF0000;">`declare_bp_fe_instr_scan_s(vaddr_width_p);</pre>
<pre style="background-color: #FF0000;"></pre>
<pre>bp_fe_instr_scan_s scan_cast_o;</pre>
<pre></pre>
<pre>assign scan_o = scan_cast_o;</pre>
<pre></pre>
<pre>wire is_compressed = (instr_i[1:0] != 2'b11);</pre>
<pre></pre>
<pre>  begin</pre>
<pre>    unique casez (instr_cast_i.opcode)</pre>
<pre>      `RV64_BRANCH_OP: scan_cast_o.scan_class = e_rvi_branch;</pre>
<pre>      `RV64_JAL_OP   : scan_cast_o.scan_class = e_rvi_jal;</pre>
<pre>      `RV64_JALR_OP  : scan_cast_o.scan_class = e_rvi_jalr;</pre>
<pre>      default        : scan_cast_o.scan_class = e_default;</pre>
<pre>    endcase</pre>
<pre>      `RV64_BRANCH_OP: scan_cast_o.imm = `rv64_signext_b_imm(instr_i);</pre>
<pre>      `RV64_JAL_OP   : scan_cast_o.imm = `rv64_signext_j_imm(instr_i);</pre>
<pre>    endcase</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<h3>./bp_fe/src/v/bp_fe_top.v</h3>
<pre></pre>
<pre>module bp_fe_top</pre>
<pre style="background-color: #FF0000;"> import bp_fe_pkg::*;</pre>
<pre> import bp_common_pkg::*;</pre>
<pre> import bp_common_aviary_pkg::*;</pre>
<pre> import bp_common_rv64_pkg::*;</pre>
<pre> import bp_be_pkg::*;</pre>
<pre> import bp_cfg_link_pkg::*;</pre>
<pre> #(parameter bp_cfg_e cfg_p = e_bp_inv_cfg</pre>
<pre>   `declare_bp_proc_params(cfg_p)</pre>
<pre>   `declare_bp_fe_be_if_widths(vaddr_width_p, paddr_width_p, asid_width_p, branch_metadata_fwd_width_p)</pre>
<pre>   `declare_bp_lce_cce_if_widths(num_cce_p, num_lce_p, paddr_width_p, lce_assoc_p, dword_width_p, cce_block_width_p)</pre>
<pre></pre>
<pre>   , localparam lce_id_width_lp = `BSG_SAFE_CLOG2(num_lce_p)</pre>
<pre>   )</pre>
<pre>  (input                                              clk_i</pre>
<pre>   , input                                            reset_i</pre>
<pre>   , input                                            freeze_i</pre>
<pre></pre>
<pre></pre>
<pre>   , input                                            cfg_w_v_i</pre>
<pre>   , input [cfg_addr_width_p-1:0]                     cfg_addr_i</pre>
<pre>   , input [cfg_data_width_p-1:0]                     cfg_data_i</pre>
<pre></pre>
<pre>   , input [fe_cmd_width_lp-1:0]                      fe_cmd_i</pre>
<pre>   , input                                            fe_cmd_v_i</pre>
<pre>   , output                                           fe_cmd_yumi_o</pre>
<pre>   , output                                           fe_cmd_processed_o</pre>
<pre></pre>
<pre>   , output [fe_queue_width_lp-1:0]                   fe_queue_o</pre>
<pre>   , output                                           fe_queue_v_o</pre>
<pre>   , input                                            fe_queue_ready_i</pre>
<pre></pre>
<pre>   , output [lce_cce_req_width_lp-1:0]                lce_req_o</pre>
<pre>   , output                                           lce_req_v_o</pre>
<pre>   , input                                            lce_req_ready_i</pre>
<pre></pre>
<pre style="background-color: #FF0000;">   , input [lce_cmd_width_lp-1:0]                     lce_cmd_i</pre>
<pre>   , input                                            lce_cmd_v_i</pre>
<pre>   , output                                           lce_cmd_ready_o</pre>
<pre></pre>
<pre>   , output [lce_cmd_width_lp-1:0]                    lce_cmd_o</pre>
<pre>   , output                                           lce_cmd_v_o</pre>
<pre>   , input                                            lce_cmd_ready_i</pre>
<pre></pre>
<pre>   , output [lce_cce_resp_width_lp-1:0]               lce_resp_o</pre>
<pre>   , output                                           lce_resp_v_o</pre>
<pre>   , input                                            lce_resp_ready_i</pre>
<pre>   );</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">`declare_bp_fe_be_if(vaddr_width_p, paddr_width_p, asid_width_p, branch_metadata_fwd_width_p);</pre>
<pre>`declare_bp_fe_mem_structs(vaddr_width_p, lce_sets_p, cce_block_width_p, vtag_width_p, ptag_width_p)</pre>
<pre style="background-color: #FF0000;">   </pre>
<pre>bp_fe_mem_cmd_s  mem_cmd_lo;</pre>
<pre>logic            mem_cmd_v_lo, mem_cmd_ready_li;</pre>
<pre>logic            mem_poison_lo;</pre>
<pre>bp_fe_mem_resp_s mem_resp_li;</pre>
<pre>logic            mem_resp_v_li, mem_resp_ready_lo;</pre>
<pre></pre>
<pre>bp_fe_pc_gen </pre>
<pre> #(.cfg_p(cfg_p)) </pre>
<pre> pc_gen</pre>
<pre>  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre>               </pre>
<pre>   ,.mem_cmd_o(mem_cmd_lo)</pre>
<pre>   ,.mem_cmd_v_o(mem_cmd_v_lo)</pre>
<pre>   ,.mem_cmd_ready_i(mem_cmd_ready_li)</pre>
<pre></pre>
<pre>   ,.mem_poison_o(mem_poison_lo)</pre>
<pre></pre>
<pre>   ,.mem_resp_i(mem_resp_li)</pre>
<pre>   ,.mem_resp_v_i(mem_resp_v_li)</pre>
<pre>   ,.mem_resp_ready_o(mem_resp_ready_lo)</pre>
<pre></pre>
<pre>   ,.fe_cmd_i(fe_cmd_i)</pre>
<pre>   ,.fe_cmd_v_i(fe_cmd_v_i)</pre>
<pre>   ,.fe_cmd_yumi_o(fe_cmd_yumi_o)</pre>
<pre>   ,.fe_cmd_processed_o(fe_cmd_processed_o)</pre>
<pre></pre>
<pre>   ,.fe_queue_o(fe_queue_o)</pre>
<pre>   ,.fe_queue_v_o(fe_queue_v_o)</pre>
<pre>   ,.fe_queue_ready_i(fe_queue_ready_i)</pre>
<pre>   );</pre>
<pre style="background-color: #FF0000;"></pre>
<pre>bp_fe_mem</pre>
<pre> #(.cfg_p(cfg_p))</pre>
<pre> mem</pre>
<pre>  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre>   ,.freeze_i(freeze_i)</pre>
<pre>   </pre>
<pre>   ,.lce_id_i(lce_id_i)</pre>
<pre>   </pre>
<pre style="background-color: #FF0000;">   ,.cfg_w_v_i(cfg_w_v_i)</pre>
<pre>   ,.cfg_addr_i(cfg_addr_i)</pre>
<pre>   ,.cfg_data_i(cfg_data_i)</pre>
<pre></pre>
<pre>   ,.mem_cmd_i(mem_cmd_lo)</pre>
<pre>   ,.mem_cmd_v_i(mem_cmd_v_lo)</pre>
<pre>   ,.mem_cmd_ready_o(mem_cmd_ready_li)</pre>
<pre></pre>
<pre>   ,.mem_poison_i(mem_poison_lo)</pre>
<pre></pre>
<pre>   ,.mem_resp_o(mem_resp_li)</pre>
<pre>   ,.mem_resp_v_o(mem_resp_v_li)</pre>
<pre>   ,.mem_resp_ready_i(mem_resp_ready_lo)</pre>
<pre></pre>
<pre>   ,.lce_req_v_o(lce_req_v_o)</pre>
<pre>   ,.lce_req_ready_i(lce_req_ready_i)</pre>
<pre>         </pre>
<pre>   ,.lce_cmd_i(lce_cmd_i)</pre>
<pre>   ,.lce_cmd_v_i(lce_cmd_v_i)</pre>
<pre>   ,.lce_cmd_ready_o(lce_cmd_ready_o)</pre>
<pre>         </pre>
<pre>   ,.lce_cmd_o(lce_cmd_o)</pre>
<pre>   ,.lce_cmd_v_o(lce_cmd_v_o)</pre>
<pre>   ,.lce_cmd_ready_i(lce_cmd_ready_i)</pre>
<pre></pre>
<pre>   ,.lce_resp_o(lce_resp_o)</pre>
<pre>   ,.lce_resp_v_o(lce_resp_v_o)</pre>
<pre>   ,.lce_resp_ready_i(lce_resp_ready_i)</pre>
<pre>   );</pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./bp_top/src/v/bp_chip.v</h3>
<pre></pre>
<pre>module bp_chip</pre>
<pre> import bp_common_pkg::*;</pre>
<pre> import bsg_noc_pkg::*;</pre>
<pre> import bsg_wormhole_router_pkg::*;</pre>
<pre> import bp_cfg_link_pkg::*;</pre>
<pre> import bp_me_pkg::*;</pre>
<pre>   `declare_bp_proc_params(cfg_p)</pre>
<pre>   )</pre>
<pre>   , input                                            core_reset_i</pre>
<pre></pre>
<pre>   , input                                            coh_reset_i</pre>
<pre></pre>
<pre>   , input                                            mem_clk_i</pre>
<pre>   , input                                            mem_reset_i</pre>
<pre></pre>
<pre>   , input [num_core_p-1:0][mem_noc_cord_width_p-1:0] tile_cord_i</pre>
<pre>   , input [mem_noc_cord_width_p-1:0]                 dram_cord_i</pre>
<pre>   , input [mem_noc_cord_width_p-1:0]                 mmio_cord_i</pre>
<pre>   , input [mem_noc_cord_width_p-1:0]                 host_cord_i</pre>
<pre></pre>
<pre>   , output [bsg_ready_and_link_sif_width_lp-1:0]     prev_cmd_link_o</pre>
<pre></pre>
<pre>   , output [bsg_ready_and_link_sif_width_lp-1:0]     prev_resp_link_o</pre>
<pre></pre>
<pre>   , output [bsg_ready_and_link_sif_width_lp-1:0]     next_cmd_link_o</pre>
<pre></pre>
<pre>   , output [bsg_ready_and_link_sif_width_lp-1:0]     next_resp_link_o</pre>
<pre>   );</pre>
<pre>`declare_bp_common_proc_cfg_s(num_core_p, num_cce_p, num_lce_p)</pre>
<pre style="background-color: #FF0000;">`declare_bp_lce_cce_if(num_cce_p, num_lce_p, paddr_width_p, lce_assoc_p, dword_width_p, cce_block_width_p)</pre>
<pre style="background-color: #FF0000;">`declare_bsg_ready_and_link_sif_s(mem_noc_flit_width_p, bsg_ready_and_link_sif_s);</pre>
<pre>logic [num_core_p-1:0][cfg_addr_width_p-1:0] cfg_addr_lo;</pre>
<pre>logic [num_core_p-1:0][cfg_data_width_p-1:0] cfg_data_lo;</pre>
<pre>logic [num_core_p-1:0] timer_irq_lo, soft_irq_lo, external_irq_lo;</pre>
<pre></pre>
<pre>bsg_ready_and_link_sif_s [mem_noc_x_dim_p-1:0] mem_resp_link_li, mem_resp_link_lo;</pre>
<pre></pre>
<pre> #(.cfg_p(cfg_p))</pre>
<pre> cc</pre>
<pre style="background-color: #FF0000;">  (.core_clk_i(core_clk_i)</pre>
<pre>   ,.core_reset_i(core_reset_i)</pre>
<pre></pre>
<pre>   ,.coh_reset_i(coh_reset_i)</pre>
<pre></pre>
<pre>   ,.mem_clk_i(mem_clk_i)</pre>
<pre>   ,.mem_reset_i(mem_reset_i)</pre>
<pre></pre>
<pre>   ,.tile_cord_i(tile_cord_i)</pre>
<pre>   ,.dram_cord_i(dram_cord_i)</pre>
<pre>   ,.mmio_cord_i(mmio_cord_i)</pre>
<pre>   ,.host_cord_i(host_cord_i)</pre>
<pre></pre>
<pre>   ,.cfg_w_v_i(cfg_w_v_lo)</pre>
<pre>   ,.cfg_addr_i(cfg_addr_lo)</pre>
<pre>   ,.cfg_data_i(cfg_data_lo)</pre>
<pre></pre>
<pre>   ,.soft_irq_i(soft_irq_lo)</pre>
<pre>   ,.external_irq_i(external_irq_lo)</pre>
<pre></pre>
<pre>   ,.mem_cmd_link_o(mem_cmd_link_lo)</pre>
<pre></pre>
<pre>   ,.mem_resp_link_i(mem_resp_link_li)</pre>
<pre>   ,.mem_resp_link_o(mem_resp_link_lo)</pre>
<pre>   );</pre>
<pre></pre>
<pre>bp_mem_complex</pre>
<pre> #(.cfg_p(cfg_p))</pre>
<pre> mc</pre>
<pre>  (.core_clk_i(core_clk_i)</pre>
<pre>   ,.core_reset_i(core_reset_i)</pre>
<pre></pre>
<pre>   ,.mem_clk_i(mem_clk_i)</pre>
<pre>   ,.mem_reset_i(mem_reset_i)</pre>
<pre></pre>
<pre>   ,.mem_cord_i(mem_cord_i)</pre>
<pre></pre>
<pre>   ,.cfg_w_v_o(cfg_w_v_lo)</pre>
<pre>   ,.cfg_addr_o(cfg_addr_lo)</pre>
<pre>   ,.cfg_data_o(cfg_data_lo)</pre>
<pre></pre>
<pre>   ,.timer_irq_o(timer_irq_lo)</pre>
<pre>   ,.soft_irq_o(soft_irq_lo)</pre>
<pre>   ,.external_irq_o(external_irq_lo)</pre>
<pre></pre>
<pre>   ,.mem_cmd_link_i(mem_cmd_link_lo)</pre>
<pre>   ,.mem_cmd_link_o(mem_cmd_link_li)</pre>
<pre></pre>
<pre>   ,.mem_resp_link_i(mem_resp_link_lo)</pre>
<pre>   ,.mem_resp_link_o(mem_resp_link_li)</pre>
<pre></pre>
<pre>   ,.prev_cmd_link_i(prev_cmd_link_i)</pre>
<pre>   ,.prev_cmd_link_o(prev_cmd_link_o)</pre>
<pre></pre>
<pre>   ,.next_cmd_link_i(next_cmd_link_i)</pre>
<pre>   ,.next_cmd_link_o(next_cmd_link_o)</pre>
<pre></pre>
<pre>   ,.prev_resp_link_i(prev_resp_link_i)</pre>
<pre>   ,.prev_resp_link_o(prev_resp_link_o)</pre>
<pre></pre>
<pre>   ,.next_resp_link_i(next_resp_link_i)</pre>
<pre>   ,.next_resp_link_o(next_resp_link_o)</pre>
<pre>   );</pre>
<pre></pre>
<pre>endmodule</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./bp_me/src/v/wormhole/bp_me_cce_id_to_cord.v</h3>
<pre>module bp_me_cce_id_to_cord</pre>
<pre>   `declare_bp_proc_params(cfg_p)</pre>
<pre>   )</pre>
<pre>   , output [coh_noc_cord_width_p-1:0] cce_cord_o</pre>
<pre>   , output [coh_noc_cid_width_p-1:0]  cce_cid_o</pre>
<pre>   );</pre>
<pre>    begin : x_cord</pre>
<pre>      assign cce_cord_o[0+:coh_noc_x_cord_width_p]                      = cce_id_i % coh_noc_x_dim_p;</pre>
<pre>    end</pre>
<pre>    begin : y_cord</pre>
<pre>      assign cce_cord_o[coh_noc_x_cord_width_p+:coh_noc_y_cord_width_p] = cce_id_i / coh_noc_x_dim_p;</pre>
<pre>    end</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<h3>./bp_me/src/v/cce/bp_cce_alu.v</h3>
<pre>module bp_cce_alu</pre>
<pre>  #(parameter width_p = "inv"</pre>
<pre>  (input logic                               v_i</pre>
<pre>   , input logic                             br_v_i</pre>
<pre>   , input logic [width_p-1:0]               opd_a_i</pre>
<pre>   , input logic [width_p-1:0]               opd_b_i</pre>
<pre>   , input bp_cce_inst_minor_alu_op_e        alu_op_i</pre>
<pre>   , input bp_cce_inst_minor_branch_op_e     br_op_i</pre>
<pre>   , output logic [width_p-1:0]              res_o</pre>
<pre>   , output logic                            branch_res_o</pre>
<pre>  logic equal, less;</pre>
<pre>  assign equal = (opd_a_i == opd_b_i);</pre>
<pre>  assign less = (opd_a_i < opd_b_i);</pre>
<pre>  always_comb begin : branch_result</pre>
<pre>    if (br_v_i) begin</pre>
<pre>    case (br_op_i)</pre>
<pre>      e_beq_op:  branch_res_o = equal;</pre>
<pre>      e_bne_op:  branch_res_o = ~equal;</pre>
<pre>      e_blt_op:  branch_res_o = less;</pre>
<pre>      e_ble_op:  branch_res_o = less | equal;</pre>
<pre>      e_bi_op:   branch_res_o = 1'b1;</pre>
<pre>      e_bf_op:   branch_res_o = equal;</pre>
<pre>      e_bqv_op:  branch_res_o = equal;</pre>
<pre>      e_bs_op:   branch_res_o = equal;</pre>
<pre>      default: branch_res_o = '0;</pre>
<pre>    end else begin</pre>
<pre>      branch_res_o = '0;</pre>
<pre>  always_comb begin : arithmetic</pre>
<pre>    res_o = '0;</pre>
<pre>    if (v_i) begin</pre>
<pre>    case (alu_op_i)</pre>
<pre>      e_add_op: res_o = opd_a_i + opd_b_i;</pre>
<pre>      e_sub_op: res_o = opd_a_i - opd_b_i;</pre>
<pre>      e_lsh_op: res_o = opd_a_i << opd_b_i;</pre>
<pre>      e_rsh_op: res_o = opd_a_i >> opd_b_i;</pre>
<pre>      e_and_op: res_o = opd_a_i & opd_b_i;</pre>
<pre>      e_or_op:  res_o = opd_a_i | opd_b_i;</pre>
<pre>      e_xor_op: res_o = opd_a_i ^ opd_b_i;</pre>
<pre>      e_neg_op: res_o = ~opd_a_i;</pre>
<pre>      default: res_o = '0;</pre>
<h3>./bp_me/src/v/cce/bp_cce_dir.v</h3>
<pre>module bp_cce_dir</pre>
<pre>  #(parameter num_way_groups_p            = "inv"</pre>
<pre>    , parameter num_lce_p                 = "inv"</pre>
<pre>    , parameter num_cce_p                 = "inv"</pre>
<pre>    , parameter lce_assoc_p               = "inv"</pre>
<pre>    , parameter tag_width_p               = "inv"</pre>
<pre>    , parameter dir_tag_sets_per_row_lp  = (num_lce_p / num_cce_p)</pre>
<pre>    , localparam lg_num_lce_lp            = `BSG_SAFE_CLOG2(num_lce_p)</pre>
<pre>    , localparam lg_lce_assoc_lp          = `BSG_SAFE_CLOG2(lce_assoc_p)</pre>
<pre></pre>
<pre>    , localparam tag_set_width_lp         = (entry_width_lp*lce_assoc_p)</pre>
<pre></pre>
<pre>    // Width of each directory RAM row</pre>
<pre>    // number of entry (tag+state) per directory row</pre>
<pre></pre>
<pre>    , localparam lg_dir_rows_per_wg_lp    = `BSG_SAFE_CLOG2(dir_rows_per_wg_lp)</pre>
<pre>    // Total number of rows in the directory RAM</pre>
<pre>    , localparam lg_dir_rows_lp           = `BSG_SAFE_CLOG2(dir_rows_lp)</pre>
<pre></pre>
<pre></pre>
<pre>   , input                                                        reset_i</pre>
<pre></pre>
<pre>   , input [lg_num_lce_lp-1:0]                                    lce_i</pre>
<pre>   , input [lg_lce_assoc_lp-1:0]                                  way_i</pre>
<pre>   , input [lg_lce_assoc_lp-1:0]                                  lru_way_i</pre>
<pre>   , input [`bp_cce_inst_minor_op_width-1:0]                      r_cmd_i</pre>
<pre>   , input                                                        r_v_i</pre>
<pre></pre>
<pre>   , input [`bp_coh_bits-1:0]                                     coh_state_i</pre>
<pre>   , input [`bp_cce_inst_minor_op_width-1:0]                      w_cmd_i</pre>
<pre>   , input                                                        w_v_i</pre>
<pre>   , input                                                        w_clr_wg_i</pre>
<pre></pre>
<pre></pre>
<pre>   , output logic [num_lce_p-1:0]                                 sharers_hits_o</pre>
<pre>   , output logic [num_lce_p-1:0][lg_lce_assoc_lp-1:0]            sharers_ways_o</pre>
<pre>   , output logic [num_lce_p-1:0][`bp_coh_bits-1:0]               sharers_coh_states_o</pre>
<pre></pre>
<pre>   , output logic                                                 lru_cached_excl_o</pre>
<pre>   , output logic [tag_width_p-1:0]                               lru_tag_o</pre>
<pre></pre>
<pre></pre>
<pre>    logic [tag_width_p-1:0]      tag;</pre>
<pre>    logic [`bp_coh_bits-1:0]     state;</pre>
<pre>  } dir_entry_s;</pre>
<pre style="background-color: #FF0000;"></pre>
<pre>  logic dir_ram_v;</pre>
<pre>  // read / write address</pre>
<pre>  // write mask and data in</pre>
<pre>  logic [dir_row_width_lp-1:0] dir_ram_w_data;</pre>
<pre>  // data out</pre>
<pre>  dir_entry_s [dir_tag_sets_per_row_lp-1:0][lce_assoc_p-1:0] dir_row_entries;</pre>
<pre>  assign dir_row_entries = dir_row_lo;</pre>
<pre></pre>
<pre>    RESET</pre>
<pre>    ,READY</pre>
<pre>    ,READ_WAY_GROUP</pre>
<pre>    ,READ_ENTRY</pre>
<pre>  } dir_state_e;</pre>
<pre></pre>
<pre></pre>
<pre>  logic [lg_num_way_groups_lp-1:0]  way_group_r, way_group_n;</pre>
<pre>  logic [lg_num_lce_lp-1:0]         lce_r, lce_n;</pre>
<pre>  logic [lg_lce_assoc_lp-1:0]       way_r, way_n;</pre>
<pre>  logic [lg_lce_assoc_lp-1:0]       lru_way_r, lru_way_n;</pre>
<pre>  logic [tag_width_p-1:0]           tag_r, tag_n;</pre>
<pre>  logic dir_data_o_v_r, dir_data_o_v_n;</pre>
<pre></pre>
<pre>  assign wr_tag_set_select = (num_lce_p == 1) ? '0 : lce_i[0+:lg_dir_tag_sets_per_row_lp];</pre>
<pre>  assign rd_tag_set_select = (num_lce_p == 1) ? '0 : lce_i[0+:lg_dir_tag_sets_per_row_lp];</pre>
<pre></pre>
<pre>  assign wr_wg_row_select = (num_lce_p == 1) ? '0 : lce_i[(lg_num_lce_lp-1)-:lg_dir_rows_per_wg_lp];</pre>
<pre>  assign rd_wg_row_select = (num_lce_p == 1) ? '0 : lce_i[(lg_num_lce_lp-1)-:lg_dir_rows_per_wg_lp];</pre>
<pre></pre>
<pre>  logic [num_lce_p-1:0]                                 sharers_hits_r, sharers_hits_n;</pre>
<pre>  logic [num_lce_p-1:0][lg_lce_assoc_lp-1:0]            sharers_ways_r, sharers_ways_n;</pre>
<pre>  logic [num_lce_p-1:0][`bp_coh_bits-1:0]               sharers_coh_states_r, sharers_coh_states_n;</pre>
<pre></pre>
<pre>  assign sharers_hits_o = sharers_hits_r;</pre>
<pre>  assign sharers_ways_o = sharers_ways_r;</pre>
<pre>  assign sharers_coh_states_o = sharers_coh_states_r;</pre>
<pre></pre>
<pre>  logic [dir_tag_sets_per_row_lp-1:0][lg_lce_assoc_lp-1:0]            sharers_ways;</pre>
<pre>  logic [dir_tag_sets_per_row_lp-1:0][`bp_coh_bits-1:0]               sharers_coh_states;</pre>
<pre></pre>
<pre>    if (reset_i) begin</pre>
<pre>      dir_state <= RESET;</pre>
<pre>      dir_rd_cnt_r <= '0;</pre>
<pre>      way_group_r <= '0;</pre>
<pre>      lce_r <= '0;</pre>
<pre>      way_r <= '0;</pre>
<pre>      lru_way_r <= '0;</pre>
<pre>      tag_r <= '0;</pre>
<pre>      dir_data_o_v_r <= '0;</pre>
<pre></pre>
<pre>      sharers_hits_r <= '0;</pre>
<pre>      sharers_ways_r <= '0;</pre>
<pre>      sharers_coh_states_r <= '0;</pre>
<pre></pre>
<pre>      dir_state <= dir_state_n;</pre>
<pre>      dir_rd_cnt_r <= dir_rd_cnt_n;</pre>
<pre>      way_group_r <= way_group_n;</pre>
<pre>      lce_r <= lce_n;</pre>
<pre>      way_r <= way_n;</pre>
<pre>      lru_way_r <= lru_way_n;</pre>
<pre>      tag_r <= tag_n;</pre>
<pre>      dir_data_o_v_r <= dir_data_o_v_n;</pre>
<pre></pre>
<pre>      sharers_hits_r <= sharers_hits_n;</pre>
<pre>      sharers_ways_r <= sharers_ways_n;</pre>
<pre>      sharers_coh_states_r <= sharers_coh_states_n;</pre>
<pre></pre>
<pre>    if (reset_i) begin</pre>
<pre>      dir_state_n = RESET;</pre>
<pre>      dir_rd_cnt_n = '0;</pre>
<pre>      dir_ram_w_mask = '0;</pre>
<pre>      dir_ram_w_data = '0;</pre>
<pre>      dir_ram_v = '0;</pre>
<pre>      dir_ram_w_v = '0;</pre>
<pre>      dir_ram_addr = '0;</pre>
<pre>      way_group_n = '0;</pre>
<pre>      lce_n = '0;</pre>
<pre>      way_n = '0;</pre>
<pre>      lru_way_n = '0;</pre>
<pre>      tag_n = '0;</pre>
<pre>      dir_data_o_v_n = '0;</pre>
<pre></pre>
<pre>      sharers_hits_n = '0;</pre>
<pre>      sharers_ways_n = '0;</pre>
<pre>      sharers_coh_states_n = '0;</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre>      // hold state by default</pre>
<pre>      dir_rd_cnt_n = '0;</pre>
<pre>      dir_ram_w_mask = '0;</pre>
<pre>      dir_ram_w_data = '0;</pre>
<pre>      dir_ram_v = '0;</pre>
<pre>      dir_ram_w_v = '0;</pre>
<pre>      dir_ram_addr = '0;</pre>
<pre>      way_group_n = way_group_r;</pre>
<pre>      lce_n = lce_r;</pre>
<pre>      way_n = way_r;</pre>
<pre>      lru_way_n = lru_way_r;</pre>
<pre>      tag_n = tag_r;</pre>
<pre>      dir_data_o_v_n = '0;</pre>
<pre></pre>
<pre>      sharers_hits_n = sharers_hits_r;</pre>
<pre>      sharers_ways_n = sharers_ways_r;</pre>
<pre>      sharers_coh_states_n = sharers_coh_states_r;</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre>        RESET: begin</pre>
<pre>          dir_state_n = (reset_i) ? RESET : READY;</pre>
<pre>        end</pre>
<pre>          dir_state_n = READY;</pre>
<pre></pre>
<pre>            dir_state_n = READ_WAY_GROUP;</pre>
<pre></pre>
<pre>            lce_n = lce_i;</pre>
<pre>            way_n = way_i;</pre>
<pre>            lru_way_n = lru_way_i;</pre>
<pre>            tag_n = tag_i;</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre>            sharers_hits_n = '0;</pre>
<pre>            sharers_ways_n = '0;</pre>
<pre>            sharers_coh_states_n = '0;</pre>
<pre></pre>
<pre>            dir_state_n = READ_ENTRY;</pre>
<pre></pre>
<pre>            lce_n = lce_i;</pre>
<pre>            way_n = way_i;</pre>
<pre></pre>
<pre>            tag_n = '0;</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre>            sharers_hits_n = '0;</pre>
<pre>            sharers_ways_n = '0;</pre>
<pre>            sharers_coh_states_n = '0;</pre>
<pre></pre>
<pre>            // mark sharers info as invalid after a write, since it is possible the write</pre>
<pre></pre>
<pre></pre>
<pre>            dir_ram_v = 1'b1;</pre>
<pre>            dir_ram_w_v = 1'b1;</pre>
<pre></pre>
<pre></pre>
<pre>              dir_ram_w_data = '0;</pre>
<pre>              dir_ram_w_mask = '1;</pre>
<pre>            end else if (w_cmd_i == e_wde_op) begin</pre>
<pre>              dir_ram_w_mask = {{(dir_row_width_lp-entry_width_lp){1'b0}},{entry_width_lp{1'b1}}}</pre>
<pre>                              << (wr_tag_set_select*tag_set_width_lp + way_i*entry_width_lp);</pre>
<pre>              dir_ram_w_data = {{(dir_row_width_lp-entry_width_lp){1'b0}},{tag_i, coh_state_i}}</pre>
<pre>                               << (wr_tag_set_select*tag_set_width_lp + way_i*entry_width_lp);</pre>
<pre>            end else if (w_cmd_i == e_wds_op) begin</pre>
<pre>              dir_ram_w_mask = {{(dir_row_width_lp-`bp_coh_bits){1'b0}},{`bp_coh_bits{1'b1}}}</pre>
<pre>                              << (wr_tag_set_select*tag_set_width_lp + way_i*entry_width_lp);</pre>
<pre>              dir_ram_w_data = {{(dir_row_width_lp-entry_width_lp){1'b0}},{tag_i, coh_state_i}}</pre>
<pre>                               << (wr_tag_set_select*tag_set_width_lp + way_i*entry_width_lp);</pre>
<pre>            end else begin</pre>
<pre>              dir_ram_w_mask = '0;</pre>
<pre>            end</pre>
<pre></pre>
<pre></pre>
<pre>            sharers_hits_n[(dir_rd_cnt_r << sh_assign_shift_lp) + i] = sharers_hits[i];</pre>
<pre>            sharers_ways_n[(dir_rd_cnt_r << sh_assign_shift_lp) + i] = sharers_ways[i];</pre>
<pre>            sharers_coh_states_n[(dir_rd_cnt_r << sh_assign_shift_lp) + i] = sharers_coh_states[i];</pre>
<pre>          end</pre>
<pre></pre>
<pre>            dir_ram_v = 1'b1;</pre>
<pre>            dir_ram_addr = {way_group_r, dir_rd_cnt_n};</pre>
<pre>            dir_data_o_v_n = 1'b1;</pre>
<pre>            dir_state_n = READ_WAY_GROUP;</pre>
<pre>          end else begin</pre>
<pre>            dir_state_n = READY;</pre>
<pre>            // sharers will be valid next cycle</pre>
<pre>          end</pre>
<pre>          busy_o = 1'b1;</pre>
<pre>          sharers_hits_n[0] = 1'b1;</pre>
<pre>          sharers_ways_n[0] = way_r;</pre>
<pre>          sharers_coh_states_n[0] = dir_row_entries[lce_r[0+:lg_dir_tag_sets_per_row_lp]][way_r].state;</pre>
<pre>          sharers_v_n = 1'b1;</pre>
<pre>          // output the tag in the entry, and store it to the register</pre>
<pre>          tag_n = dir_row_entries[lce_r[0+:lg_dir_tag_sets_per_row_lp]][way_r].tag;</pre>
<pre>          dir_state_n = READY;</pre>
<pre>        end</pre>
<pre>          dir_state_n = RESET;</pre>
<pre>        end</pre>
<pre>    #(.width_p(dir_row_width_lp)</pre>
<pre>      ,.els_p(dir_rows_lp)</pre>
<pre>      )</pre>
<pre style="background-color: #FF0000;">     (.clk_i(clk_i)</pre>
<pre>      ,.reset_i(reset_i)</pre>
<pre>      ,.w_i(dir_ram_w_v)</pre>
<pre>      ,.w_mask_i(dir_ram_w_mask)</pre>
<pre>      ,.addr_i(dir_ram_addr)</pre>
<pre>      ,.data_i(dir_ram_w_data)</pre>
<pre>      ,.v_i(dir_ram_v)</pre>
<pre>      ,.data_o(dir_row_lo)</pre>
<pre>      );</pre>
<pre>    #(.tag_sets_per_row_p(dir_tag_sets_per_row_lp)</pre>
<pre>      ,.rows_per_wg_p(dir_rows_per_wg_lp)</pre>
<pre>      ,.row_width_p(dir_row_width_lp)</pre>
<pre>      ,.lce_assoc_p(lce_assoc_p)</pre>
<pre>      ,.tag_width_p(tag_width_p)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">     (.row_i(dir_row_lo)</pre>
<pre>      ,.row_v_i(dir_data_o_v_r)</pre>
<pre>      ,.tag_i(tag_r)</pre>
<pre>      ,.sharers_hits_o(sharers_hits)</pre>
<pre>      ,.sharers_ways_o(sharers_ways)</pre>
<pre>      ,.sharers_coh_states_o(sharers_coh_states)</pre>
<pre>     );</pre>
<pre>    #(.tag_sets_per_row_p(dir_tag_sets_per_row_lp)</pre>
<pre>      ,.rows_per_wg_p(dir_rows_per_wg_lp)</pre>
<pre>      ,.row_width_p(dir_row_width_lp)</pre>
<pre>      ,.lce_assoc_p(lce_assoc_p)</pre>
<pre>      ,.num_lce_p(num_lce_p)</pre>
<pre>      ,.tag_width_p(tag_width_p)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">     (.row_i(dir_row_lo)</pre>
<pre>      ,.row_v_i(dir_data_o_v_r)</pre>
<pre>      ,.wg_row_i(dir_rd_cnt_r)</pre>
<pre>      ,.lce_i(lce_r)</pre>
<pre>      ,.lru_way_i(lru_way_r)</pre>
<pre>      ,.lru_v_o(lru_v_o)</pre>
<pre>      ,.lru_cached_excl_o(lru_cached_excl_o)</pre>
<pre>      ,.lru_tag_o(lru_tag_o)</pre>
<pre>     );</pre>
<h3>./bp_me/src/v/cce/bp_cce_inst_decode.v</h3>
<pre>module bp_cce_inst_decode</pre>
<pre>  #(parameter inst_width_p        = "inv"</pre>
<pre>    , parameter inst_addr_width_p = "inv"</pre>
<pre>  (input                                         clk_i</pre>
<pre>   , input                                       reset_i</pre>
<pre>   , input [inst_width_p-1:0]                    inst_i</pre>
<pre>   , input                                       inst_v_i</pre>
<pre>   , input                                       pending_w_busy_i</pre>
<pre>   , input                                       lce_cmd_busy_i</pre>
<pre>   , input                                       lce_req_v_i</pre>
<pre>   , input                                       lce_resp_v_i</pre>
<pre>   , input bp_lce_cce_resp_type_e                lce_resp_type_i</pre>
<pre>   , input                                       mem_resp_v_i</pre>
<pre>   , input                                       mem_cmd_v_i</pre>
<pre>   , input                                       pending_v_i</pre>
<pre>   , input                                       lce_cmd_ready_i</pre>
<pre>   , input                                       mem_cmd_ready_i</pre>
<pre>   , input                                       mem_resp_ready_i</pre>
<pre>   , input                                       fence_zero_i</pre>
<pre>   , output bp_cce_inst_decoded_s                decoded_inst_o</pre>
<pre>   , output logic                                decoded_inst_v_o</pre>
<pre>   , output logic                                pc_stall_o</pre>
<pre>   , output logic [inst_addr_width_p-1:0]        pc_branch_target_o</pre>
<pre>  wire unused0 = clk_i;</pre>
<pre>  bp_cce_inst_s                inst;</pre>
<pre>  bp_cce_inst_op_e             op;</pre>
<pre>  bp_cce_inst_minor_op_u       minor_op_u;</pre>
<pre>  bp_cce_inst_type_u           op_type_u;</pre>
<pre>  bp_cce_inst_alu_op_s         alu_op_s;</pre>
<pre>  bp_cce_inst_branch_op_s      branch_op_s;</pre>
<pre>  bp_cce_inst_mov_op_s         mov_op_s;</pre>
<pre>  bp_cce_inst_flag_op_s        flag_op_s;</pre>
<pre>  bp_cce_inst_read_dir_op_s    read_dir_op_s;</pre>
<pre>  bp_cce_inst_write_dir_op_s   write_dir_op_s;</pre>
<pre>  bp_cce_inst_misc_op_s        misc_op_s;</pre>
<pre>  bp_cce_inst_queue_op_s       queue_op_s;</pre>
<pre>  logic pushq_op, popq_op, poph_op;</pre>
<pre>  bp_cce_inst_dst_q_sel_e pushq_qsel;</pre>
<pre>  bp_cce_inst_src_q_sel_e popq_qsel;</pre>
<pre>  logic [`bp_cce_num_src_q-1:0] wfq_mask;</pre>
<pre>  logic wfq_op;</pre>
<pre>  logic wfq_q_ready;</pre>
<pre>  logic stall_op;</pre>
<pre>  logic gpr_w_v;</pre>
<pre>  logic wdp_op;</pre>
<pre>  logic fence_op;</pre>
<pre></pre>
<pre>  begin</pre>
<pre>    gpr_w_v = '0;</pre>
<pre></pre>
<pre>    op = inst.op;</pre>
<pre>    minor_op_u = inst.minor_op_u;</pre>
<pre>    op_type_u = inst.type_u;</pre>
<pre>    alu_op_s = op_type_u.alu_op_s;</pre>
<pre>    branch_op_s = op_type_u.branch_op_s;</pre>
<pre>    mov_op_s = op_type_u.mov_op_s;</pre>
<pre>    flag_op_s = op_type_u.flag_op_s;</pre>
<pre>    read_dir_op_s = op_type_u.read_dir_op_s;</pre>
<pre>    write_dir_op_s = op_type_u.write_dir_op_s;</pre>
<pre>    misc_op_s = op_type_u.misc_op_s;</pre>
<pre>    queue_op_s = op_type_u.queue_op_s;</pre>
<pre></pre>
<pre>    decoded_inst_o = '0;</pre>
<pre>    pc_stall_o = '0;</pre>
<pre>    pc_branch_target_o = '0;</pre>
<pre></pre>
<pre>    popq_op = (op == e_op_queue) & (minor_op_u == e_popq_op);</pre>
<pre>    poph_op = (op == e_op_queue) & (minor_op_u == e_poph_op);</pre>
<pre>    pushq_qsel = queue_op_s.op.pushq.dst_q;</pre>
<pre>    popq_qsel = queue_op_s.op.popq.src_q;</pre>
<pre></pre>
<pre>      decoded_inst_v_o = '0;</pre>
<pre>    end else begin</pre>
<pre>      decoded_inst_v_o = inst_v_i;</pre>
<pre>      decoded_inst_o.op = op;</pre>
<pre>      decoded_inst_o.minor_op_u = minor_op_u;</pre>
<pre></pre>
<pre>        e_op_alu: begin</pre>
<pre>          decoded_inst_o.alu_v = 1'b1;</pre>
<pre>          // All ALU arithmetic operations write a GPR destination</pre>
<pre>          decoded_inst_o.imm[0+:`bp_cce_inst_imm16_width] = alu_op_s.imm;</pre>
<pre>          // Dst and Src fields are GPRs or immediate (src only)</pre>
<pre>          decoded_inst_o.src_a.gpr = alu_op_s.src_a;</pre>
<pre>          decoded_inst_o.src_b.gpr = alu_op_s.src_b;</pre>
<pre></pre>
<pre>          decoded_inst_o.src_a_sel = e_src_sel_gpr;</pre>
<pre>          decoded_inst_o.src_b_sel = e_src_sel_gpr;</pre>
<pre></pre>
<pre>          decoded_inst_o.branch_v = 1'b1;</pre>
<pre>          // Next PC computation</pre>
<pre>          pc_branch_target_o = branch_op_s.target[0+:inst_addr_width_p];</pre>
<pre></pre>
<pre>          decoded_inst_o.src_b.gpr = branch_op_s.src_b.gpr;</pre>
<pre>          decoded_inst_o.src_a_sel = e_src_sel_gpr;</pre>
<pre>          decoded_inst_o.src_b_sel = e_src_sel_gpr;</pre>
<pre></pre>
<pre>            decoded_inst_o.src_a.flag = branch_op_s.src_a.flag;</pre>
<pre>            decoded_inst_o.src_a_sel = e_src_sel_flag;</pre>
<pre></pre>
<pre>            decoded_inst_o.src_a.special = branch_op_s.src_a.special;</pre>
<pre>            decoded_inst_o.src_a_sel = e_src_sel_special;</pre>
<pre></pre>
<pre>            decoded_inst_o.src_a.special = branch_op_s.src_a.special;</pre>
<pre>            decoded_inst_o.src_a_sel = e_src_sel_special;</pre>
<pre>          end</pre>
<pre>          decoded_inst_o.mov_dst_w_v = 1'b1;</pre>
<pre></pre>
<pre>          decoded_inst_o.src_a.gpr = mov_op_s.src.gpr;</pre>
<pre>          decoded_inst_o.dst_sel = e_dst_sel_gpr;</pre>
<pre>          decoded_inst_o.src_a_sel = e_src_sel_gpr;</pre>
<pre></pre>
<pre></pre>
<pre>            decoded_inst_o.src_a.flag = mov_op_s.src.flag;</pre>
<pre>            decoded_inst_o.src_a_sel = e_src_sel_flag;</pre>
<pre>          end</pre>
<pre>            decoded_inst_o.src_a.special = mov_op_s.src.special;</pre>
<pre>            decoded_inst_o.src_a_sel = e_src_sel_special;</pre>
<pre>          end</pre>
<pre>            decoded_inst_o.dst.special = mov_op_s.dst.special;</pre>
<pre>            decoded_inst_o.dst_sel = e_dst_sel_special;</pre>
<pre>          end</pre>
<pre></pre>
<pre>          decoded_inst_o.src_a_sel = e_src_sel_flag;</pre>
<pre></pre>
<pre>          decoded_inst_o.src_b_sel = e_src_sel_flag;</pre>
<pre></pre>
<pre></pre>
<pre>          decoded_inst_o.dst_sel = e_dst_sel_flag;</pre>
<pre></pre>
<pre>            decoded_inst_o.minor_op_u.alu_minor_op = e_and_op;</pre>
<pre>            decoded_inst_o.dst.gpr = flag_op_s.dst.gpr;</pre>
<pre>            decoded_inst_o.dst_sel = e_dst_sel_gpr;</pre>
<pre>            decoded_inst_o.alu_v = 1'b1;</pre>
<pre>            decoded_inst_o.alu_dst_w_v = 1'b1;</pre>
<pre>          end else if (minor_op_u.flag_minor_op == e_orf_op) begin</pre>
<pre>            decoded_inst_o.minor_op_u.alu_minor_op = e_or_op;</pre>
<pre>            decoded_inst_o.dst.gpr = flag_op_s.dst.gpr;</pre>
<pre>            decoded_inst_o.dst_sel = e_dst_sel_gpr;</pre>
<pre>            decoded_inst_o.alu_v = 1'b1;</pre>
<pre>            decoded_inst_o.alu_dst_w_v = 1'b1;</pre>
<pre>          end else begin</pre>
<pre>            if (flag_op_s.dst == e_dst_rqf) begin</pre>
<pre>              decoded_inst_o.rqf_sel = e_rqf_imm0;</pre>
<pre>              decoded_inst_o.flag_mask_w_v = e_flag_rqf;</pre>
<pre>            end else if (flag_op_s.dst == e_dst_ucf) begin</pre>
<pre>              decoded_inst_o.rqf_sel = e_rqf_imm0;</pre>
<pre>              decoded_inst_o.flag_mask_w_v = e_flag_ucf;</pre>
<pre>            end else if (flag_op_s.dst == e_dst_nerf) begin</pre>
<pre>              decoded_inst_o.nerf_sel = e_nerf_imm0;</pre>
<pre>              decoded_inst_o.flag_mask_w_v = e_flag_nerf;</pre>
<pre>            end else if (flag_op_s.dst == e_dst_ldf) begin</pre>
<pre>              decoded_inst_o.ldf_sel = e_ldf_imm0;</pre>
<pre>              decoded_inst_o.flag_mask_w_v = e_flag_ldf;</pre>
<pre>            end else if (flag_op_s.dst == e_dst_nwbf) begin</pre>
<pre>              decoded_inst_o.nwbf_sel = e_nwbf_imm0;</pre>
<pre>              decoded_inst_o.flag_mask_w_v = e_flag_nwbf;</pre>
<pre>            end else if (flag_op_s.dst == e_dst_tf) begin</pre>
<pre>              decoded_inst_o.tf_sel = e_tf_imm0;</pre>
<pre>              decoded_inst_o.flag_mask_w_v = e_flag_tf;</pre>
<pre>            end else if (flag_op_s.dst == e_dst_rf) begin</pre>
<pre>              decoded_inst_o.rf_sel = e_rf_imm0;</pre>
<pre>              decoded_inst_o.flag_mask_w_v = e_flag_rf;</pre>
<pre>            end else if (flag_op_s.dst == e_dst_pf) begin</pre>
<pre>              decoded_inst_o.pf_sel = e_pf_imm0;</pre>
<pre>              decoded_inst_o.flag_mask_w_v = e_flag_pf;</pre>
<pre>            end else if (flag_op_s.dst == e_dst_uf) begin</pre>
<pre>              decoded_inst_o.uf_sel = e_uf_imm0;</pre>
<pre>              decoded_inst_o.flag_mask_w_v = e_flag_uf;</pre>
<pre>            end else if (flag_op_s.dst == e_dst_if) begin</pre>
<pre>              decoded_inst_o.if_sel = e_if_imm0;</pre>
<pre>              decoded_inst_o.flag_mask_w_v = e_flag_if;</pre>
<pre>            end else if (flag_op_s.dst == e_dst_cf) begin</pre>
<pre>              decoded_inst_o.cf_sel = e_cf_imm0;</pre>
<pre>              decoded_inst_o.flag_mask_w_v = e_flag_cf;</pre>
<pre>            end else if (flag_op_s.dst == e_dst_cef) begin</pre>
<pre>              decoded_inst_o.cef_sel = e_cef_imm0;</pre>
<pre>              decoded_inst_o.flag_mask_w_v = e_flag_cef;</pre>
<pre>            end else if (flag_op_s.dst == e_dst_cof) begin</pre>
<pre>              decoded_inst_o.cof_sel = e_cof_imm0;</pre>
<pre>              decoded_inst_o.flag_mask_w_v = e_flag_cof;</pre>
<pre>            end else if (flag_op_s.dst == e_dst_cdf) begin</pre>
<pre>              decoded_inst_o.cdf_sel = e_cdf_imm0;</pre>
<pre>              decoded_inst_o.flag_mask_w_v = e_flag_cdf;</pre>
<pre>            end else if (flag_op_s.dst == e_dst_ucf) begin</pre>
<pre>              decoded_inst_o.ucf_sel = e_ucf_imm0;</pre>
<pre>              decoded_inst_o.flag_mask_w_v = e_flag_ucf;</pre>
<pre>            end</pre>
<pre>          // Directory input mux selects</pre>
<pre>          decoded_inst_o.dir_lce_sel = read_dir_op_s.dir_lce_sel;</pre>
<pre>          decoded_inst_o.dir_way_sel = read_dir_op_s.dir_way_sel;</pre>
<pre>          decoded_inst_o.dir_tag_sel = read_dir_op_s.dir_tag_sel;</pre>
<pre></pre>
<pre>          if (minor_op_u.read_dir_minor_op == e_rdp_op) begin</pre>
<pre>            decoded_inst_o.pending_r_v = 1'b1;</pre>
<pre>            decoded_inst_o.flag_mask_w_v = e_flag_pf;</pre>
<pre>          end</pre>
<pre>            decoded_inst_o.dir_r_v = 1'b1;</pre>
<pre>          end</pre>
<pre>            decoded_inst_o.dir_r_v = 1'b1;</pre>
<pre>            decoded_inst_o.dst.gpr = read_dir_op_s.dst;</pre>
<pre>            decoded_inst_o.dst_sel = e_dst_sel_gpr;</pre>
<pre>            decoded_inst_o.rde_w_v = 1'b1;</pre>
<pre>          end</pre>
<pre>          // Directory input mux selects</pre>
<pre>          decoded_inst_o.dir_lce_sel = write_dir_op_s.dir_lce_sel;</pre>
<pre>          decoded_inst_o.dir_way_sel = write_dir_op_s.dir_way_sel;</pre>
<pre>          decoded_inst_o.dir_coh_state_sel = write_dir_op_s.dir_coh_state_sel;</pre>
<pre>          decoded_inst_o.dir_tag_sel = write_dir_op_s.dir_tag_sel;</pre>
<pre></pre>
<pre>          decoded_inst_o.dir_w_v = 1'b1;</pre>
<pre></pre>
<pre></pre>
<pre>            decoded_inst_o.pending_w_v = 1'b1;</pre>
<pre>          end</pre>
<pre>          if (minor_op_u.misc_minor_op == e_gad_op) begin</pre>
<pre>            decoded_inst_o.gad_v = 1'b1;</pre>
<pre>            decoded_inst_o.transfer_lce_w_v = 1'b1; // transfer_lce, transfer_lce_way</pre>
<pre>            decoded_inst_o.req_addr_way_w_v = 1'b1; // req_addr_way</pre>
<pre>            decoded_inst_o.transfer_lce_w_v = 1'b1; // transfer_lce, transfer_lce_way</pre>
<pre>            decoded_inst_o.tf_sel = e_tf_logic;</pre>
<pre>            decoded_inst_o.rf_sel = e_rf_logic;</pre>
<pre>            decoded_inst_o.uf_sel = e_uf_logic;</pre>
<pre>            decoded_inst_o.if_sel = e_if_logic;</pre>
<pre>            decoded_inst_o.cf_sel = e_cf_logic;</pre>
<pre>            decoded_inst_o.cef_sel = e_cef_logic;</pre>
<pre>            decoded_inst_o.cof_sel = e_cof_logic;</pre>
<pre>            decoded_inst_o.cdf_sel = e_cdf_logic;</pre>
<pre>            decoded_inst_o.flag_mask_w_v =</pre>
<pre>              (e_flag_tf | e_flag_rf | e_flag_uf | e_flag_if | e_flag_cf | e_flag_cef</pre>
<pre>               | e_flag_cof | e_flag_cdf);</pre>
<pre>          end</pre>
<pre>            decoded_inst_o.mshr_clear = 1'b1;</pre>
<pre>          end</pre>
<pre>          end</pre>
<pre>          if (minor_op_u.queue_minor_op == e_pushq_op) begin</pre>
<pre>            // lce cmd</pre>
<pre>            // cce_lce_cmd_queue inputs</pre>
<pre>            decoded_inst_o.lce_cmd_addr_sel = queue_op_s.op.pushq.lce_cmd_addr_sel;</pre>
<pre>            decoded_inst_o.lce_cmd_way_sel = queue_op_s.op.pushq.lce_cmd_way_sel;</pre>
<pre>            // mem cmd</pre>
<pre>            // mem_cmd_queue inputs</pre>
<pre>            // mem_resp</pre>
<pre></pre>
<pre>            // Output to Mem (ready&valid), connects to FIFO buffer</pre>
<pre>            decoded_inst_o.mem_resp_v = (pushq_qsel == e_dst_q_mem_resp);</pre>
<pre>      </pre>
<pre>              | (minor_op_u.queue_minor_op == e_poph_op)) begin</pre>
<pre></pre>
<pre>              // Input queue yumi signals (to FIFOs)</pre>
<pre>              decoded_inst_o.lce_resp_yumi = lce_resp_v_i & (popq_qsel == e_src_q_sel_lce_resp);</pre>
<pre>              // Input from Mem (valid->yumi)</pre>
<pre>              decoded_inst_o.mem_cmd_yumi = mem_cmd_v_i & (popq_qsel == e_src_q_sel_mem_cmd);</pre>
<pre>            end</pre>
<pre>              decoded_inst_o.nwbf_sel = e_nwbf_lce_resp;</pre>
<pre>              decoded_inst_o.flag_mask_w_v = e_flag_nwbf;</pre>
<pre>              decoded_inst_o.dst.gpr = queue_op_s.op.popq.dst;</pre>
<pre>              decoded_inst_o.dst_sel = e_dst_sel_gpr;</pre>
<pre>              decoded_inst_o.resp_type_w_v = 1'b1;</pre>
<pre></pre>
<pre>              // pop the response type into a GPR</pre>
<pre>              decoded_inst_o.dst_sel = e_dst_sel_gpr;</pre>
<pre>              decoded_inst_o.mem_resp_type_w_v = 1'b1;</pre>
<pre></pre>
<pre>              // pop the command into a GPR</pre>
<pre>              decoded_inst_o.dst_sel = e_dst_sel_gpr;</pre>
<pre>              decoded_inst_o.mem_cmd_type_w_v = 1'b1;</pre>
<pre>              // store address and lce fields to special registers</pre>
<pre>              decoded_inst_o.req_sel = e_req_sel_mem_cmd;</pre>
<pre></pre>
<pre>              decoded_inst_o.req_sel = e_req_sel_lce_req;</pre>
<pre>              decoded_inst_o.lru_way_sel = e_lru_way_sel_lce_req;</pre>
<pre>              decoded_inst_o.req_w_v = 1'b1; // req_lce, req_addr</pre>
<pre>              decoded_inst_o.lru_way_w_v = 1'b1;</pre>
<pre>              decoded_inst_o.nerf_sel = e_nerf_lce_req;</pre>
<pre>              decoded_inst_o.ldf_sel = e_ldf_lce_req;</pre>
<pre>              decoded_inst_o.rqf_sel = e_rqf_lce_req;</pre>
<pre>              decoded_inst_o.ucf_sel = e_ucf_lce_req;</pre>
<pre>              decoded_inst_o.nc_req_size_w_v = 1'b1;</pre>
<pre>              decoded_inst_o.flag_mask_w_v = (e_flag_rqf | e_flag_nerf | e_flag_ldf | e_flag_ucf);</pre>
<pre>            end</pre>
<pre>        end</pre>
<pre>                 | decoded_inst_o.resp_type_w_v | decoded_inst_o.rde_w_v</pre>
<pre>                 | decoded_inst_o.mem_resp_type_w_v)</pre>
<pre>                & (decoded_inst_o.dst_sel == e_dst_sel_gpr);</pre>
<pre>      decoded_inst_o.gpr_w_mask =</pre>
<pre>        {</pre>
<pre>        (decoded_inst_o.dst.gpr == e_dst_r7) & (gpr_w_v)</pre>
<pre>        ,(decoded_inst_o.dst.gpr == e_dst_r6) & (gpr_w_v)</pre>
<pre>        ,(decoded_inst_o.dst.gpr == e_dst_r5) & (gpr_w_v)</pre>
<pre>        ,(decoded_inst_o.dst.gpr == e_dst_r4) & (gpr_w_v)</pre>
<pre>        ,(decoded_inst_o.dst.gpr == e_dst_r3) & (gpr_w_v)</pre>
<pre>        ,(decoded_inst_o.dst.gpr == e_dst_r2) & (gpr_w_v)</pre>
<pre>        ,(decoded_inst_o.dst.gpr == e_dst_r1) & (gpr_w_v)</pre>
<pre>        ,(decoded_inst_o.dst.gpr == e_dst_r0) & (gpr_w_v)</pre>
<pre>        };</pre>
<pre></pre>
<pre>    stall_op = (op == e_op_misc) & (minor_op_u.misc_minor_op == e_stall_op);</pre>
<pre>    wdp_op = (op == e_op_write_dir) & (minor_op_u.write_dir_minor_op == e_wdp_op);</pre>
<pre>    fence_op = (op == e_op_misc) & (minor_op_u.misc_minor_op == e_fence_op);</pre>
<pre></pre>
<pre>    // WFQ mask from instruction immediate</pre>
<pre></pre>
<pre></pre>
<pre>                 | (fence_op & ~fence_zero_i);</pre>
<pre></pre>
<pre>    case (pushq_qsel)</pre>
<pre>      e_dst_q_lce_cmd: pc_stall_o |= ~lce_cmd_ready_i;</pre>
<pre>      e_dst_q_mem_cmd: pc_stall_o |= ~mem_cmd_ready_i;</pre>
<pre>      e_dst_q_mem_resp: pc_stall_o |= ~mem_resp_ready_i;</pre>
<pre>      default: pc_stall_o = pc_stall_o;</pre>
<pre>    endcase</pre>
<pre>    case (popq_qsel)</pre>
<pre>      e_src_q_sel_lce_req: pc_stall_o |= ~lce_req_v_i;</pre>
<pre>      e_src_q_sel_mem_resp: pc_stall_o |= ~mem_resp_v_i;</pre>
<pre>      e_src_q_sel_lce_resp: pc_stall_o |= ~lce_resp_v_i;</pre>
<pre>      e_src_q_sel_mem_cmd: pc_stall_o |= ~mem_cmd_v_i;</pre>
<pre>      default: pc_stall_o = pc_stall_o;</pre>
<pre>    endcase</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<h3>./bp_me/src/v/cce/bp_cce_dir_tag_checker.v</h3>
<pre>module bp_cce_dir_tag_checker</pre>
<pre>  #(parameter tag_sets_per_row_p          = "inv"</pre>
<pre>    , parameter rows_per_wg_p             = "inv"</pre>
<pre>    , parameter row_width_p               = "inv"</pre>
<pre>    , parameter lce_assoc_p               = "inv"</pre>
<pre>    , parameter tag_width_p               = "inv"</pre>
<pre>  )</pre>
<pre>   , input                                                        row_v_i</pre>
<pre>   , input [tag_width_p-1:0]                                      tag_i</pre>
<pre></pre>
<pre>   , output logic [tag_sets_per_row_p-1:0][lg_lce_assoc_lp-1:0]   sharers_ways_o</pre>
<pre>   , output logic [tag_sets_per_row_p-1:0][`bp_coh_bits-1:0]      sharers_coh_states_o</pre>
<pre>  );</pre>
<pre>    logic [tag_width_p-1:0]      tag;</pre>
<pre>    logic [`bp_coh_bits-1:0]     state;</pre>
<pre>  } dir_entry_s;</pre>
<pre style="background-color: #FF0000;"></pre>
<pre>  assign row = row_i;</pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;">    for (genvar j = 0; j < lce_assoc_p; j++) begin : row_hits_way</pre>
<pre style="background-color: #FF0000;">      assign row_hits[i][j] =</pre>
<pre style="background-color: #FF0000;">        (row_v_i)</pre>
<pre style="background-color: #FF0000;">        ? (row[i][j].tag == tag_i) & |(row[i][j].state)</pre>
<pre style="background-color: #FF0000;">        : '0;</pre>
<pre style="background-color: #FF0000;">    end</pre>
<pre style="background-color: #FF0000;">    bsg_encode_one_hot</pre>
<pre style="background-color: #FF0000;">      #(.width_p(lce_assoc_p)</pre>
<pre style="background-color: #FF0000;">        )</pre>
<pre style="background-color: #FF0000;">       (.i(row_hits[i])</pre>
<pre style="background-color: #FF0000;">        ,.addr_o(sharers_ways_o[i])</pre>
<pre style="background-color: #FF0000;">        ,.v_o(sharers_hits_o[i])</pre>
<pre style="background-color: #FF0000;">        );</pre>
<pre style="background-color: #FF0000;">    assign sharers_coh_states_o[i] = (sharers_hits_o[i])</pre>
<pre style="background-color: #FF0000;">                                   ? row[i][sharers_ways_o[i]].state</pre>
<pre style="background-color: #FF0000;">                                   : '0;</pre>
<pre style="background-color: #FF0000;">  end</pre>
<h3>./bp_me/src/v/cce/bp_cce_dir_lru_extract.v</h3>
<pre>module bp_cce_dir_lru_extract</pre>
<pre>  #(parameter tag_sets_per_row_p          = "inv"</pre>
<pre>    , parameter row_width_p               = "inv"</pre>
<pre>    , parameter num_lce_p                 = "inv"</pre>
<pre>    , parameter lce_assoc_p               = "inv"</pre>
<pre>    , parameter rows_per_wg_p             = "inv"</pre>
<pre>    , parameter tag_width_p               = "inv"</pre>
<pre>    , localparam lg_lce_assoc_lp          = `BSG_SAFE_CLOG2(lce_assoc_p)</pre>
<pre>    , localparam lg_tag_sets_per_row_lp   = `BSG_SAFE_CLOG2(tag_sets_per_row_p)</pre>
<pre>    , localparam lg_rows_per_wg_lp        = `BSG_SAFE_CLOG2(rows_per_wg_p)</pre>
<pre></pre>
<pre>    , localparam lce_wg_bits_lp = (rows_per_wg_p == 1) ? 1 : lg_rows_per_wg_lp</pre>
<pre>  )</pre>
<pre>   , input                                                        row_v_i</pre>
<pre>   // If there are multiple rows per wg, wg_part_i indicates which row is being input</pre>
<pre></pre>
<pre>   , input [lg_lce_assoc_lp-1:0]                                  lru_way_i</pre>
<pre></pre>
<pre>   , output logic                                                 lru_cached_excl_o</pre>
<pre>   , output logic [tag_width_p-1:0]                               lru_tag_o</pre>
<pre></pre>
<pre>    logic [tag_width_p-1:0]      tag;</pre>
<pre>    logic [`bp_coh_bits-1:0]     state;</pre>
<pre>  } dir_entry_s;</pre>
<pre style="background-color: #FF0000;"></pre>
<pre>  assign row = row_i;</pre>
<pre></pre>
<pre>                   ? (rows_per_wg_p == 1)</pre>
<pre>                     ? 1'b1</pre>
<pre>                     : (lce_i[lce_wg_offset_lp+:lce_wg_bits_lp] == wg_row_i)</pre>
<pre>                       ? 1'b1</pre>
<pre>                       : 1'b0</pre>
<pre>                   : 1'b0;</pre>
<pre></pre>
<pre>  assign lru_coh_state = (row_v_i)</pre>
<pre>                         ? row[lce_i[0+:lg_tag_sets_per_row_lp]][lru_way_i].state</pre>
<pre>                         : '0;</pre>
<pre>  assign lru_cached_excl_o = |lru_coh_state & ~lru_coh_state[`bp_coh_shared_bit];</pre>
<pre>  assign lru_tag_o = (row_v_i)</pre>
<pre>                     ? row[lce_i[0+:lg_tag_sets_per_row_lp]][lru_way_i].tag</pre>
<pre>                     : '0;</pre>
<pre>endmodule</pre>
<h3>./bp_me/src/v/cce/bp_cce_gad.v</h3>
<pre>module bp_cce_gad</pre>
<pre>  #(parameter num_lce_p              = "inv"</pre>
<pre>    , parameter lce_assoc_p            = "inv"</pre>
<pre>    , localparam lg_lce_assoc_lp       = `BSG_SAFE_CLOG2(lce_assoc_p)</pre>
<pre>  )</pre>
<pre>   , input                                                 reset_i</pre>
<pre></pre>
<pre></pre>
<pre>   , input [num_lce_p-1:0]                                 sharers_hits_i</pre>
<pre>   , input [num_lce_p-1:0][lg_lce_assoc_lp-1:0]            sharers_ways_i</pre>
<pre>   , input [num_lce_p-1:0][`bp_coh_bits-1:0]               sharers_coh_states_i</pre>
<pre></pre>
<pre>   , input                                                 req_type_flag_i</pre>
<pre>   , input                                                 lru_dirty_flag_i</pre>
<pre>   , input                                                 lru_cached_excl_flag_i</pre>
<pre></pre>
<pre></pre>
<pre>   , output logic [lg_num_lce_lp-1:0]                      transfer_lce_o</pre>
<pre>   , output logic [lg_lce_assoc_lp-1:0]                    transfer_way_o</pre>
<pre>   , output logic                                          replacement_flag_o</pre>
<pre>   , output logic                                          upgrade_flag_o</pre>
<pre>   , output logic                                          invalidate_flag_o</pre>
<pre>   , output logic                                          cached_flag_o</pre>
<pre>   , output logic                                          cached_exclusive_flag_o</pre>
<pre>   , output logic                                          cached_owned_flag_o</pre>
<pre>   , output logic                                          cached_dirty_flag_o</pre>
<pre>  );</pre>
<pre></pre>
<pre>  bsg_decode</pre>
<pre>    #(.num_out_p(num_lce_p)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">     (.i(req_lce_i)</pre>
<pre>      ,.o(lce_id_one_hot)</pre>
<pre>     );</pre>
<pre>  assign lce_cached = sharers_hits_i;</pre>
<pre></pre>
<pre>  logic [num_lce_p-1:0] lce_cached_owned;</pre>
<pre>  logic [num_lce_p-1:0] lce_cached_dirty;</pre>
<pre>  for (genvar i = 0; i < num_lce_p; i=i+1) begin : lce_cached_excl_gen</pre>
<pre>    assign lce_cached_excl[i] = lce_cached[i] & ~sharers_coh_states_i[i][`bp_coh_shared_bit];</pre>
<pre>    assign lce_cached_owned[i] = lce_cached[i] & sharers_coh_states_i[i][`bp_coh_owned_bit];</pre>
<pre>    assign lce_cached_dirty[i] = lce_cached[i] & sharers_coh_states_i[i][`bp_coh_dirty_bit];</pre>
<pre>  end</pre>
<pre>  assign req_lce_cached = lce_cached[req_lce_i];</pre>
<pre>  // read-only permissions in requesting LCE</pre>
<pre>  assign req_lce_ro = req_lce_cached & sharers_coh_states_i[req_lce_i][`bp_coh_shared_bit];</pre>
<pre></pre>
<pre>    ? sharers_ways_i[req_lce_i]</pre>
<pre>    : '0;</pre>
<pre></pre>
<pre>  assign req_wr = (req_type_flag_i == e_lce_req_type_wr);</pre>
<pre>  assign req_rd = ~req_wr;</pre>
<pre></pre>
<pre>  assign cached_exclusive_flag_o = |(lce_cached_excl & ~lce_id_one_hot);</pre>
<pre>  assign cached_owned_flag_o = |(lce_cached_owned & ~lce_id_one_hot);</pre>
<pre>  assign cached_dirty_flag_o = |(lce_cached_dirty & ~lce_id_one_hot);</pre>
<pre></pre>
<pre>  // Upgrade from read-only to read-write</pre>
<pre>  // Replace the LRU block if not doing an upgrade and the lru block is actually dirty</pre>
<pre></pre>
<pre>  </pre>
<pre>  logic [lg_num_lce_lp-1:0] transfer_lce_lo;</pre>
<pre>  logic transfer_lce_v;</pre>
<pre></pre>
<pre>  bsg_encode_one_hot</pre>
<pre>    #(.width_p(num_lce_p)</pre>
<pre>      )</pre>
<pre style="background-color: #FF0000;">     (.i(transfer_lce_one_hot)</pre>
<pre>      ,.addr_o(transfer_lce_lo)</pre>
<pre>      ,.v_o(transfer_lce_v)</pre>
<pre>      );</pre>
<pre>                          ? transfer_lce_lo : '0;</pre>
<pre>  assign transfer_way_o = (gad_v_i & transfer_flag_o & transfer_lce_v)</pre>
<pre>                          ? sharers_ways_i[transfer_lce_lo] : '0;</pre>
<pre></pre>
<h3>./bp_me/src/v/cce/bp_cce_reg.v</h3>
<pre> */</pre>
<pre style="background-color: #FF0000;"></pre>
<pre>module bp_cce_reg</pre>
<pre>  #(parameter num_lce_p                     = "inv"</pre>
<pre>    , parameter num_cce_p                   = "inv"</pre>
<pre>    , parameter paddr_width_p                = "inv"</pre>
<pre>    , parameter lce_assoc_p                 = "inv"</pre>
<pre>    , parameter lce_sets_p                  = "inv"</pre>
<pre>    , parameter block_size_in_bytes_p       = "inv"</pre>
<pre>    , parameter lce_req_data_width_p        = "inv"</pre>
<pre>    , parameter cfg_addr_width_p            = "inv"</pre>
<pre>    , parameter cfg_data_width_p            = "inv"</pre>
<pre>    , localparam lg_num_cce_lp              = `BSG_SAFE_CLOG2(num_cce_p)</pre>
<pre>    , localparam block_size_in_bits_lp      = (block_size_in_bytes_p*8)</pre>
<pre>    , localparam lg_block_size_in_bytes_lp  = `BSG_SAFE_CLOG2(block_size_in_bytes_p)</pre>
<pre>    , localparam lg_lce_assoc_lp            = `BSG_SAFE_CLOG2(lce_assoc_p)</pre>
<pre>    , localparam lg_lce_sets_lp             = `BSG_SAFE_CLOG2(lce_sets_p)</pre>
<pre>    , localparam tag_width_lp               =</pre>
<pre>      (paddr_width_p-lg_lce_sets_lp-lg_block_size_in_bytes_lp)</pre>
<pre>    , localparam entry_width_lp             = (tag_width_lp+`bp_coh_bits)</pre>
<pre>    , localparam tag_set_width_lp           = (entry_width_lp*lce_assoc_p)</pre>
<pre></pre>
<pre>    , localparam mshr_width_lp = `bp_cce_mshr_width(num_lce_p, lce_assoc_p, paddr_width_p)</pre>
<pre></pre>
<pre>    `declare_bp_lce_cce_if_widths(num_cce_p, num_lce_p, paddr_width_p, lce_assoc_p, lce_req_data_width_p, block_size_in_bits_lp)</pre>
<pre>    `declare_bp_me_if_widths(paddr_width_p, block_size_in_bits_lp, num_lce_p, lce_assoc_p)</pre>
<pre>  )</pre>
<pre>  (input                                                                   clk_i</pre>
<pre>   , input                                                                 reset_i</pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;">   , input [lce_cce_req_width_lp-1:0]                                      lce_req_i</pre>
<pre>   , input                                                                 null_wb_flag_i</pre>
<pre>   , input bp_lce_cce_resp_type_e                                          lce_resp_type_i</pre>
<pre>   , input bp_cce_mem_cmd_type_e                                           mem_resp_type_i</pre>
<pre>   , input [cce_mem_msg_width_lp-1:0]                                      mem_cmd_i</pre>
<pre></pre>
<pre>   , input [`bp_cce_inst_gpr_width-1:0]                                    mov_src_i</pre>
<pre></pre>
<pre>   , input                                                                 pending_v_o_i</pre>
<pre></pre>
<pre>   , input                                                                 dir_lru_cached_excl_i</pre>
<pre>   , input [tag_width_lp-1:0]                                              dir_lru_tag_i</pre>
<pre>   , input [tag_width_lp-1:0]                                              dir_tag_i</pre>
<pre></pre>
<pre>   , input [lg_num_lce_lp-1:0]                                             gad_transfer_lce_i</pre>
<pre>   , input [lg_lce_assoc_lp-1:0]                                           gad_transfer_lce_way_i</pre>
<pre>   , input                                                                 gad_transfer_flag_i</pre>
<pre>   , input                                                                 gad_replacement_flag_i</pre>
<pre>   , input                                                                 gad_upgrade_flag_i</pre>
<pre>   , input                                                                 gad_invalidate_flag_i</pre>
<pre>   , input                                                                 gad_cached_flag_i</pre>
<pre>   , input                                                                 gad_cached_exclusive_flag_i</pre>
<pre>   , input                                                                 gad_cached_owned_flag_i</pre>
<pre>   , input                                                                 gad_cached_dirty_flag_i</pre>
<pre></pre>
<pre style="background-color: #FF0000;">   // Config channel</pre>
<pre>   , input                                                                 cfg_w_v_i</pre>
<pre>   , input [cfg_addr_width_p-1:0]                                          cfg_addr_i</pre>
<pre>   , input [cfg_data_width_p-1:0]                                          cfg_data_i</pre>
<pre></pre>
<pre>   // Register value outputs</pre>
<pre>   , output logic [mshr_width_lp-1:0]                                      mshr_o</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre>  );</pre>
<pre></pre>
<pre>  // Define structure variables for input queues</pre>
<pre>  `declare_bp_me_if(paddr_width_p, block_size_in_bits_lp, num_lce_p, lce_assoc_p);</pre>
<pre>  `declare_bp_lce_cce_if(num_cce_p, num_lce_p, paddr_width_p, lce_assoc_p, lce_req_data_width_p, block_size_in_bits_lp);</pre>
<pre></pre>
<pre>  bp_lce_cce_req_s lce_req;</pre>
<pre></pre>
<pre>  assign lce_req = lce_req_i;</pre>
<pre></pre>
<pre>  logic uc_req;</pre>
<pre>  assign uc_req = (lce_req.msg_type == e_lce_req_type_uc_rd) | (lce_req.msg_type == e_lce_req_type_uc_wr);</pre>
<pre></pre>
<pre>  bp_cce_mem_msg_s mem_cmd;</pre>
<pre>  assign mem_cmd = mem_cmd_i;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">  `declare_bp_cce_mshr_s(num_lce_p, lce_assoc_p, paddr_width_p);</pre>
<pre>  bp_cce_mshr_s mshr_r, mshr_n;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">  logic [`bp_cce_inst_num_gpr-1:0][`bp_cce_inst_gpr_width-1:0] gpr_r, gpr_n;</pre>
<pre>  logic [lce_req_data_width_p-1:0] nc_data_r, nc_data_n;</pre>
<pre>  logic [lg_num_lce_lp-1:0] num_lce_r, num_lce_n;</pre>
<pre></pre>
<pre>  // Config link</pre>
<pre>  wire cfg_num_lce_w_v = (cfg_w_v_i & (cfg_addr_i == bp_cfg_reg_num_lce_gp));</pre>
<pre></pre>
<pre>  // Output register values</pre>
<pre style="background-color: #FF0000;">  assign mshr_o = mshr_r;</pre>
<pre>  assign gpr_o = gpr_r;</pre>
<pre>  assign nc_data_o = nc_data_r;</pre>
<pre>  assign num_lce_o = num_lce_r;</pre>
<pre></pre>
<pre>  begin</pre>
<pre></pre>
<pre>    // GPR</pre>
<pre style="background-color: #FF0000;">    for (int i = 0; i < `bp_cce_inst_num_gpr; i=i+1) begin</pre>
<pre>      if (decoded_inst_i.alu_dst_w_v & decoded_inst_i.gpr_w_mask[i]) begin</pre>
<pre>        gpr_n[i] = alu_res_i;</pre>
<pre>      end else if (decoded_inst_i.mov_dst_w_v & decoded_inst_i.gpr_w_mask[i]) begin</pre>
<pre>        gpr_n[i] = mov_src_i;</pre>
<pre>      end else if (decoded_inst_i.resp_type_w_v & decoded_inst_i.gpr_w_mask[i]) begin</pre>
<pre>        gpr_n[i] = {'0, lce_resp_type_i};</pre>
<pre>      end else if (decoded_inst_i.mem_resp_type_w_v & decoded_inst_i.gpr_w_mask[i]) begin</pre>
<pre>        gpr_n[i] = {'0, mem_resp_type_i};</pre>
<pre>      end else if (decoded_inst_i.mem_cmd_type_w_v & decoded_inst_i.gpr_w_mask[i]) begin</pre>
<pre>        gpr_n[i] = {'0, mem_cmd.msg_type};</pre>
<pre>      end else if (decoded_inst_i.dir_r_v & (decoded_inst_i.dir_r_cmd == e_rde_op)</pre>
<pre>                   & decoded_inst_i.gpr_w_mask[i]) begin</pre>
<pre>        gpr_n[i] = {'0, dir_tag_i} << (paddr_width_p - tag_width_lp);</pre>
<pre>      end else begin</pre>
<pre>        gpr_n[i] = '0;</pre>
<pre>      end</pre>
<pre style="background-color: #FF0000;">    // Uncached data register is always sourced from LCE Request</pre>
<pre></pre>
<pre>    if (cfg_num_lce_w_v) begin</pre>
<pre>      num_lce_n = cfg_data_i[0+:lg_num_lce_lp];</pre>
<pre>    end else begin</pre>
<pre>      num_lce_n = mov_src_i[0+:lg_num_lce_lp];</pre>
<pre>    end</pre>
<pre>    // MSHR</pre>
<pre></pre>
<pre>      mshr_n = '0;</pre>
<pre>    end else begin</pre>
<pre>      // Request LCE, address, tag</pre>
<pre>        e_req_sel_lce_req: begin</pre>
<pre>          mshr_n.lce_id = lce_req.src_id;</pre>
<pre>          mshr_n.paddr = lce_req.addr;</pre>
<pre>        end</pre>
<pre>          mshr_n.lce_id = '0;</pre>
<pre>          mshr_n.paddr = '0;</pre>
<pre>        end</pre>
<pre>          mshr_n.lce_id = mem_cmd.payload.lce_id;</pre>
<pre>          mshr_n.paddr = mem_cmd.addr;</pre>
<pre>        end</pre>
<pre>          mshr_n.lce_id = '0;</pre>
<pre>          mshr_n.paddr = '0;</pre>
<pre>        end</pre>
<pre></pre>
<pre>        e_lru_way_sel_lce_req: begin</pre>
<pre>          mshr_n.lru_way_id = lce_req.msg.req.lru_way_id;</pre>
<pre>        end</pre>
<pre>          mshr_n.lru_way_id = '0; // TODO: v2</pre>
<pre>        end</pre>
<pre>            mshr_n.lru_way_id = '0;</pre>
<pre>        end</pre>
<pre>      mshr_n.tr_way_id = gad_transfer_lce_way_i;</pre>
<pre></pre>
<pre>        e_rqf_lce_req: begin</pre>
<pre>          mshr_n.flags[e_flag_sel_rqf] = lce_req.msg_type;</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_rqf] = '0; // TODO: v2</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_rqf] = decoded_inst_i.imm[`bp_cce_inst_flag_imm_bit];</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_rqf] = '0;</pre>
<pre>        end</pre>
<pre>        e_ucf_lce_req: begin</pre>
<pre>          mshr_n.flags[e_flag_sel_ucf] = uc_req;</pre>
<pre>          mshr_n.uc_req_size           = bp_lce_cce_uc_req_size_e'(lce_req.msg.uc_req.uc_size);</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_ucf] = '0;</pre>
<pre>          mshr_n.uc_req_size           = bp_lce_cce_uc_req_size_e'('0);</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_ucf] = decoded_inst_i.imm[`bp_cce_inst_flag_imm_bit];</pre>
<pre>          mshr_n.uc_req_size           = bp_lce_cce_uc_req_size_e'('0);</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_ucf] = '0;</pre>
<pre>          mshr_n.uc_req_size           = bp_lce_cce_uc_req_size_e'('0);</pre>
<pre>        end</pre>
<pre>        e_nerf_lce_req: begin</pre>
<pre>          mshr_n.flags[e_flag_sel_nerf] = lce_req.msg.req.non_exclusive;</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_nerf] = '0; // TODO: v2</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_nerf] = decoded_inst_i.imm[`bp_cce_inst_flag_imm_bit];</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_nerf] = '0;</pre>
<pre>        end</pre>
<pre>        e_ldf_lce_req: begin</pre>
<pre>          mshr_n.flags[e_flag_sel_ldf] = lce_req.msg.req.lru_dirty;</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_ldf] = '0; // TODO: v2</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_ldf] = decoded_inst_i.imm[`bp_cce_inst_flag_imm_bit];</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_ldf] = '0;</pre>
<pre>        end</pre>
<pre>        e_nwbf_lce_resp: begin</pre>
<pre>          mshr_n.flags[e_flag_sel_nwbf] = null_wb_flag_i;</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_nwbf] = decoded_inst_i.imm[`bp_cce_inst_flag_imm_bit];</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_nwbf] = '0;</pre>
<pre>        end</pre>
<pre>        e_tf_logic: begin</pre>
<pre>          mshr_n.flags[e_flag_sel_tf] = gad_transfer_flag_i;</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_tf] = decoded_inst_i.imm[`bp_cce_inst_flag_imm_bit];</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_tf] = '0;</pre>
<pre>        end</pre>
<pre>        e_pf_logic: begin</pre>
<pre>          mshr_n.flags[e_flag_sel_pf] = pending_o_i; // RDP instruction</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_pf] = decoded_inst_i.imm[`bp_cce_inst_flag_imm_bit];</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_pf] = '0;</pre>
<pre>        end</pre>
<pre>        e_rf_logic: begin</pre>
<pre>          mshr_n.flags[e_flag_sel_rf] = gad_replacement_flag_i;</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_rf] = decoded_inst_i.imm[`bp_cce_inst_flag_imm_bit];</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_rf] = '0;</pre>
<pre>        end</pre>
<pre>        e_uf_logic: begin</pre>
<pre>          mshr_n.flags[e_flag_sel_uf] = gad_upgrade_flag_i;</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_uf] = decoded_inst_i.imm[`bp_cce_inst_flag_imm_bit];</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_uf] = '0;</pre>
<pre>        end</pre>
<pre>        e_if_logic: begin</pre>
<pre>          mshr_n.flags[e_flag_sel_if] = gad_invalidate_flag_i;</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_if] = decoded_inst_i.imm[`bp_cce_inst_flag_imm_bit];</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_if] = '0;</pre>
<pre>        end</pre>
<pre>        e_cf_logic: begin</pre>
<pre>          mshr_n.flags[e_flag_sel_cf] = gad_cached_flag_i;</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_cf] = decoded_inst_i.imm[`bp_cce_inst_flag_imm_bit];</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_cf] = '0;</pre>
<pre>        end</pre>
<pre>        e_cef_logic: begin</pre>
<pre>          mshr_n.flags[e_flag_sel_cef] = gad_cached_exclusive_flag_i;</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_cef] = decoded_inst_i.imm[`bp_cce_inst_flag_imm_bit];</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_cef] = '0;</pre>
<pre>        end</pre>
<pre>        e_cof_logic: begin</pre>
<pre>          mshr_n.flags[e_flag_sel_cof] = gad_cached_owned_flag_i;</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_cof] = decoded_inst_i.imm[`bp_cce_inst_flag_imm_bit];</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_cof] = '0;</pre>
<pre>        end</pre>
<pre>        e_cdf_logic: begin</pre>
<pre>          mshr_n.flags[e_flag_sel_cdf] = gad_cached_dirty_flag_i;</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_cdf] = decoded_inst_i.imm[`bp_cce_inst_flag_imm_bit];</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_cdf] = '0;</pre>
<pre>        end</pre>
<pre>        e_lef_logic: begin</pre>
<pre>          mshr_n.flags[e_flag_sel_lef] = dir_lru_cached_excl_i;</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_lef] = decoded_inst_i.imm[`bp_cce_inst_flag_imm_bit];</pre>
<pre>        end</pre>
<pre>          mshr_n.flags[e_flag_sel_lef] = '0;</pre>
<pre>        end</pre>
<pre></pre>
<pre>                          {lg_block_size_in_bytes_lp{1'b0}}};</pre>
<pre></pre>
<pre>  begin</pre>
<pre>    if (reset_i) begin</pre>
<pre>      mshr_r <= '0;</pre>
<pre>      gpr_r <= '0;</pre>
<pre>      nc_data_r <= '0;</pre>
<pre>      num_lce_r <= '0;</pre>
<pre>    end else begin</pre>
<pre>      // MSHR writes</pre>
<pre>        mshr_r <= mshr_n;</pre>
<pre>      end else begin</pre>
<pre>        if (decoded_inst_i.req_w_v) begin</pre>
<pre>          mshr_r.lce_id <= mshr_n.lce_id;</pre>
<pre>          mshr_r.paddr <= mshr_n.paddr;</pre>
<pre>        end</pre>
<pre>          mshr_r.way_id <= mshr_n.way_id;</pre>
<pre>        end</pre>
<pre>          mshr_r.lru_way_id <= mshr_n.lru_way_id;</pre>
<pre>        end</pre>
<pre>          mshr_r.tr_lce_id <= mshr_n.tr_lce_id;</pre>
<pre>          mshr_r.tr_way_id <= mshr_n.tr_way_id;</pre>
<pre>        end</pre>
<pre>          if (decoded_inst_i.flag_mask_w_v[i]) begin</pre>
<pre>            mshr_r.flags[i] <= mshr_n.flags[i];</pre>
<pre>          end</pre>
<pre>          mshr_r.flags[e_flag_sel_lef] <= mshr_n.flags[e_flag_sel_lef];</pre>
<pre>          mshr_r.lru_paddr <= mshr_n.lru_paddr;</pre>
<pre>        end</pre>
<pre>            & (decoded_inst_i.dst.special == e_dst_next_coh_state)) begin</pre>
<pre>          mshr_r.next_coh_state <= mshr_n.next_coh_state;</pre>
<pre>        end</pre>
<pre>          mshr_r.uc_req_size <= mshr_n.uc_req_size;</pre>
<pre>        end</pre>
<pre>        if (decoded_inst_i.gpr_w_mask[i]) begin</pre>
<pre>          gpr_r[i] <= gpr_n[i];</pre>
<pre>        end</pre>
<pre>        nc_data_r <= nc_data_n;</pre>
<pre>      end</pre>
<pre>          | (decoded_inst_i.mov_dst_w_v & (decoded_inst_i.dst_sel == e_dst_sel_special)</pre>
<pre>             & (decoded_inst_i.dst.special == e_dst_num_lce))) begin</pre>
<pre>        num_lce_r <= num_lce_n;</pre>
<pre>      end</pre>
<h3>./bp_me/src/v/wormhole/bp_me_lce_id_to_cord.v</h3>
<pre>module bp_me_lce_id_to_cord</pre>
<pre>   `declare_bp_proc_params(cfg_p)</pre>
<pre>   )</pre>
<pre>   , output [coh_noc_cord_width_p-1:0] lce_cord_o</pre>
<pre>   , output [coh_noc_cid_width_p-1:0]  lce_cid_o</pre>
<pre>   );</pre>
<pre>    begin : x_cord</pre>
<pre>      assign lce_cord_o[0+:coh_noc_x_cord_width_p] = </pre>
<pre>        (lce_id_i >> 1'b1) % lce_id_width_lp'(coh_noc_x_dim_p);</pre>
<pre>    end</pre>
<pre>    begin : y_cord</pre>
<pre>      assign lce_cord_o[coh_noc_x_cord_width_p+:coh_noc_y_cord_width_p] = </pre>
<pre>        (lce_id_i >> 1'b1) / lce_id_width_lp'(coh_noc_x_dim_p);</pre>
<pre>    end</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<h3>./bp_me/src/v/cce/bp_cce_msg_cached.v</h3>
<pre> *</pre>
<pre style="background-color: #FF0000;"> *   Processing of a Memory Data Response takes priority over processing of any other memory</pre>
<pre style="background-color: #FF0000;"> *   messages being sent or received. This arbitration is handled by the instruction decoder.</pre>
<pre>module bp_cce_msg_cached</pre>
<pre>  #(parameter num_lce_p                    = "inv"</pre>
<pre>    , parameter num_cce_p                  = "inv"</pre>
<pre>    , parameter paddr_width_p              = "inv"</pre>
<pre>    , parameter lce_assoc_p                = "inv"</pre>
<pre>    , parameter lce_sets_p                 = "inv"</pre>
<pre>    , parameter block_size_in_bytes_p      = "inv"</pre>
<pre>    , parameter lce_req_data_width_p       = "inv"</pre>
<pre>    , parameter num_way_groups_p           = "inv"</pre>
<pre>    , parameter cce_block_width_p          = "inv"</pre>
<pre>    , parameter dword_width_p              = "inv"</pre>
<pre>    , localparam lg_num_lce_lp             = `BSG_SAFE_CLOG2(num_lce_p)</pre>
<pre>    , localparam lg_lce_assoc_lp           = `BSG_SAFE_CLOG2(lce_assoc_p)</pre>
<pre>    , localparam block_size_in_bits_lp     = (block_size_in_bytes_p*8)</pre>
<pre>    , localparam mshr_width_lp = `bp_cce_mshr_width(num_lce_p, lce_assoc_p, paddr_width_p)</pre>
<pre>    `declare_bp_lce_cce_if_widths(num_cce_p, num_lce_p, paddr_width_p, lce_assoc_p, lce_req_data_width_p, block_size_in_bits_lp)</pre>
<pre>    `declare_bp_me_if_widths(paddr_width_p, block_size_in_bits_lp, num_lce_p, lce_assoc_p)</pre>
<pre></pre>
<pre>    , localparam lg_lce_sets_lp            = `BSG_SAFE_CLOG2(lce_sets_p)</pre>
<pre>    , localparam lg_block_size_in_bytes_lp = `BSG_SAFE_CLOG2(block_size_in_bytes_p)</pre>
<pre>    , localparam lg_num_way_groups_lp      = `BSG_SAFE_CLOG2(num_way_groups_p)</pre>
<pre>    , localparam way_group_offset_high_lp  = (lg_block_size_in_bytes_lp+lg_lce_sets_lp)</pre>
<pre>  )</pre>
<pre>  (input                                               clk_i</pre>
<pre>   , input                                             reset_i</pre>
<pre></pre>
<pre>   , input bp_cce_mode_e                               cce_mode_i</pre>
<pre></pre>
<pre>   , input                                             lce_req_v_i</pre>
<pre>   , output logic                                      lce_req_yumi_o</pre>
<pre></pre>
<pre>   , input                                             lce_resp_v_i</pre>
<pre>   , output logic                                      lce_resp_yumi_o</pre>
<pre></pre>
<pre>   , output logic                                      lce_cmd_v_o</pre>
<pre>   , input                                             lce_cmd_ready_i</pre>
<pre></pre>
<pre style="background-color: #FF0000;">   , input [cce_mem_msg_width_lp-1:0]                  mem_resp_i</pre>
<pre>   , input                                             mem_resp_v_i</pre>
<pre>   , output logic                                      mem_resp_yumi_o</pre>
<pre></pre>
<pre>   , input                                             mem_cmd_v_i</pre>
<pre>   , output logic                                      mem_cmd_yumi_o</pre>
<pre></pre>
<pre>   , output logic [cce_mem_msg_width_lp-1:0]           mem_cmd_o</pre>
<pre>   , output logic                                      mem_cmd_v_o</pre>
<pre>   , input                                             mem_cmd_ready_i</pre>
<pre></pre>
<pre>   , output logic [cce_mem_msg_width_lp-1:0]           mem_resp_o</pre>
<pre>   , output logic                                      mem_resp_v_o</pre>
<pre>   , input                                             mem_resp_ready_i</pre>
<pre></pre>
<pre>   // MSHR</pre>
<pre></pre>
<pre></pre>
<pre>   , output logic [lg_num_way_groups_lp-1:0]           pending_w_way_group_o</pre>
<pre>   , output logic                                      pending_o</pre>
<pre></pre>
<pre>   // arbitration signals to instruction decode</pre>
<pre>   , output logic                                      lce_cmd_busy_o</pre>
<pre></pre>
<pre>   , input [`bp_cce_inst_num_gpr-1:0][`bp_cce_inst_gpr_width-1:0] gpr_i</pre>
<pre></pre>
<pre>   , input [num_lce_p-1:0][lg_lce_assoc_lp-1:0]        sharers_ways_i</pre>
<pre></pre>
<pre>   , input [dword_width_p-1:0]                         nc_data_i</pre>
<pre></pre>
<pre>   , output logic                                      fence_zero_o</pre>
<pre>  );</pre>
<pre></pre>
<pre>  `declare_bp_cce_mshr_s(num_lce_p, lce_assoc_p, paddr_width_p);</pre>
<pre>  bp_cce_mshr_s mshr;</pre>
<pre>  assign mshr = mshr_i;</pre>
<pre></pre>
<pre>  `declare_bp_me_if(paddr_width_p, block_size_in_bits_lp, num_lce_p, lce_assoc_p);</pre>
<pre>  `declare_bp_lce_cce_if(num_cce_p, num_lce_p, paddr_width_p, lce_assoc_p, lce_req_data_width_p, block_size_in_bits_lp);</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">  // structures for casting</pre>
<pre>  bp_lce_cmd_s lce_cmd;</pre>
<pre>  bp_lce_cce_resp_s lce_resp;</pre>
<pre></pre>
<pre>  bp_cce_mem_msg_s mem_resp_li, mem_resp_lo, mem_cmd_lo, mem_cmd_li;</pre>
<pre></pre>
<pre>  // cast output queue messages from structure variables</pre>
<pre style="background-color: #FF0000;">  assign lce_cmd_o = lce_cmd;</pre>
<pre>  assign mem_cmd_o = mem_cmd_lo;</pre>
<pre>  assign mem_resp_o = mem_resp_lo;</pre>
<pre></pre>
<pre>  // cast input queue messages to structure variables</pre>
<pre>  assign mem_cmd_li = mem_cmd_i;</pre>
<pre>  assign lce_resp = lce_resp_i;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">  // signals for setting fields in outbound messages</pre>
<pre>  logic [lg_num_lce_lp-1:0] lce_cmd_lce;</pre>
<pre>  logic [paddr_width_p-1:0] lce_cmd_addr;</pre>
<pre>  logic [lg_lce_assoc_lp-1:0] lce_cmd_way;</pre>
<pre></pre>
<pre>  localparam [paddr_width_p-lg_lce_sets_lp-1:0] lce_cmd_addr_0 =</pre>
<pre>    (paddr_width_p-lg_lce_sets_lp)'('0);</pre>
<pre style="background-color: #FF0000;"></pre>
<pre>  logic [lg_lce_sets_lp-1:0] gpr_set;</pre>
<pre></pre>
<pre>  // CCE fence counter</pre>
<pre>  logic fence_inc, fence_dec;</pre>
<pre>  logic [`BSG_WIDTH(2*num_way_groups_p)-1:0] fence_cnt;</pre>
<pre>  assign fence_zero_o = (fence_cnt == '0);</pre>
<pre>  bsg_counter_up_down</pre>
<pre>    #(.max_val_p(2*num_way_groups_p)</pre>
<pre>      ,.init_val_p('0)</pre>
<pre>      ,.max_step_p(1)</pre>
<pre>      )</pre>
<pre style="background-color: #FF0000;">      (.clk_i(clk_i)</pre>
<pre>       ,.reset_i(reset_i)</pre>
<pre>       ,.up_i(fence_inc)</pre>
<pre>       ,.down_i(fence_dec)</pre>
<pre>       ,.count_o(fence_cnt)</pre>
<pre>       );</pre>
<pre></pre>
<pre>  always_comb begin</pre>
<pre>    // defaults</pre>
<pre>    mem_cmd_lo = '0;</pre>
<pre>    mem_resp_v_o = '0;</pre>
<pre>    mem_resp_lo = '0;</pre>
<pre></pre>
<pre>    lce_cmd = '0;</pre>
<pre></pre>
<pre>    lce_resp_yumi_o = '0;</pre>
<pre>    mem_resp_yumi_o = '0;</pre>
<pre>    mem_cmd_yumi_o = '0;</pre>
<pre></pre>
<pre>    pending_w_way_group_o = '0;</pre>
<pre>    pending_o = '0;</pre>
<pre></pre>
<pre>    lce_cmd_busy_o = '0;</pre>
<pre></pre>
<pre>    fence_dec = '0;</pre>
<pre></pre>
<pre></pre>
<pre>          | (mem_resp_li.msg_type.cce_mem_cmd == e_cce_mem_wr)</pre>
<pre>          | (mem_resp_li.msg_type.cce_mem_cmd == e_cce_mem_uc_rd)) begin</pre>
<pre></pre>
<pre>        mem_resp_yumi_o = lce_cmd_ready_i;</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre>          lce_cmd.msg_type = e_lce_cmd_uc_data;</pre>
<pre>          lce_cmd.way_id = '0;</pre>
<pre>          lce_cmd.msg.dt_cmd.data[0+:dword_width_p] = mem_resp_li.data[0+:dword_width_p];</pre>
<pre>          lce_cmd.msg.dt_cmd.addr = mem_resp_li.addr;</pre>
<pre>        end else begin</pre>
<pre>          lce_cmd.msg_type = e_lce_cmd_data;</pre>
<pre>          lce_cmd.way_id = mem_resp_li.payload.way_id;</pre>
<pre>          lce_cmd.msg.dt_cmd.data = mem_resp_li.data;</pre>
<pre>          lce_cmd.msg.dt_cmd.addr = mem_resp_li.addr;</pre>
<pre>          lce_cmd.msg.dt_cmd.state = mem_resp_li.payload.state;</pre>
<pre>        end</pre>
<pre>          pending_w_v_o = lce_cmd_ready_i;</pre>
<pre>          pending_w_way_group_o =</pre>
<pre>            mem_resp_li.addr[(way_group_offset_high_lp-1) -: lg_num_way_groups_lp];</pre>
<pre>          pending_o = 1'b0;</pre>
<pre>          // TODO: only blocking on cycle that message sends because Mem Cmd are sent to a full width buffer, so it only</pre>
<pre>        end</pre>
<pre>        mem_resp_yumi_o = 1'b1;</pre>
<pre>        pending_w_v_o = 1'b1;</pre>
<pre>        pending_w_way_group_o =</pre>
<pre>          mem_resp_li.addr[(way_group_offset_high_lp-1) -: lg_num_way_groups_lp];</pre>
<pre>        pending_o = 1'b0;</pre>
<pre>        pending_w_busy_o = 1'b1;</pre>
<pre></pre>
<pre></pre>
<pre>        // after store response is received, need to send uncached store done command to LCE</pre>
<pre></pre>
<pre></pre>
<pre>        lce_cmd.msg_type = e_lce_cmd_uc_st_done;</pre>
<pre>        lce_cmd.way_id = '0;</pre>
<pre></pre>
<pre>        lce_cmd.msg.cmd.addr = mem_resp_li.addr;</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre>      e_mem_cmd_addr_r0: mem_cmd_addr = gpr_i[e_gpr_r0][0+:paddr_width_p];</pre>
<pre>      e_mem_cmd_addr_r1: mem_cmd_addr = gpr_i[e_gpr_r1][0+:paddr_width_p];</pre>
<pre>      e_mem_cmd_addr_r2: mem_cmd_addr = gpr_i[e_gpr_r2][0+:paddr_width_p];</pre>
<pre>      e_mem_cmd_addr_r3: mem_cmd_addr = gpr_i[e_gpr_r3][0+:paddr_width_p];</pre>
<pre>      e_mem_cmd_addr_r4: mem_cmd_addr = gpr_i[e_gpr_r4][0+:paddr_width_p];</pre>
<pre>      e_mem_cmd_addr_r5: mem_cmd_addr = gpr_i[e_gpr_r5][0+:paddr_width_p];</pre>
<pre>      e_mem_cmd_addr_r6: mem_cmd_addr = gpr_i[e_gpr_r6][0+:paddr_width_p];</pre>
<pre>      e_mem_cmd_addr_r7: mem_cmd_addr = gpr_i[e_gpr_r7][0+:paddr_width_p];</pre>
<pre>      e_mem_cmd_addr_lru_way_addr: mem_cmd_addr = mshr.lru_paddr;</pre>
<pre>      e_mem_cmd_addr_req_addr: mem_cmd_addr = mshr.paddr;</pre>
<pre>      default mem_cmd_addr = '0;</pre>
<pre>    endcase</pre>
<pre>    case (decoded_inst_i.lce_cmd_lce_sel)</pre>
<pre>      e_lce_cmd_lce_r0: lce_cmd_lce = gpr_i[e_gpr_r0][lg_num_lce_lp-1:0];</pre>
<pre>      e_lce_cmd_lce_r1: lce_cmd_lce = gpr_i[e_gpr_r1][lg_num_lce_lp-1:0];</pre>
<pre>      e_lce_cmd_lce_r2: lce_cmd_lce = gpr_i[e_gpr_r2][lg_num_lce_lp-1:0];</pre>
<pre>      e_lce_cmd_lce_r3: lce_cmd_lce = gpr_i[e_gpr_r3][lg_num_lce_lp-1:0];</pre>
<pre>      e_lce_cmd_lce_r4: lce_cmd_lce = gpr_i[e_gpr_r4][lg_num_lce_lp-1:0];</pre>
<pre>      e_lce_cmd_lce_r5: lce_cmd_lce = gpr_i[e_gpr_r5][lg_num_lce_lp-1:0];</pre>
<pre>      e_lce_cmd_lce_r6: lce_cmd_lce = gpr_i[e_gpr_r6][lg_num_lce_lp-1:0];</pre>
<pre>      e_lce_cmd_lce_r7: lce_cmd_lce = gpr_i[e_gpr_r7][lg_num_lce_lp-1:0];</pre>
<pre>      e_lce_cmd_lce_req_lce: lce_cmd_lce = mshr.lce_id;</pre>
<pre>      e_lce_cmd_lce_tr_lce: lce_cmd_lce = mshr.tr_lce_id;</pre>
<pre>      e_lce_cmd_lce_0: lce_cmd_lce = '0;</pre>
<pre>      default: lce_cmd_lce = '0;</pre>
<pre>    endcase</pre>
<pre style="background-color: #FF0000;">    case (decoded_inst_i.lce_cmd_addr_sel)</pre>
<pre>      e_lce_cmd_addr_r0: lce_cmd_addr = gpr_i[e_gpr_r0][0+:paddr_width_p];</pre>
<pre>      e_lce_cmd_addr_r1: lce_cmd_addr = gpr_i[e_gpr_r1][0+:paddr_width_p];</pre>
<pre>      e_lce_cmd_addr_r2: lce_cmd_addr = gpr_i[e_gpr_r2][0+:paddr_width_p];</pre>
<pre>      e_lce_cmd_addr_r3: lce_cmd_addr = gpr_i[e_gpr_r3][0+:paddr_width_p];</pre>
<pre>      e_lce_cmd_addr_r4: lce_cmd_addr = gpr_i[e_gpr_r4][0+:paddr_width_p];</pre>
<pre>      e_lce_cmd_addr_r5: lce_cmd_addr = gpr_i[e_gpr_r5][0+:paddr_width_p];</pre>
<pre>      e_lce_cmd_addr_r6: lce_cmd_addr = gpr_i[e_gpr_r6][0+:paddr_width_p];</pre>
<pre>      e_lce_cmd_addr_r7: lce_cmd_addr = gpr_i[e_gpr_r7][0+:paddr_width_p];</pre>
<pre>      e_lce_cmd_addr_req_addr: lce_cmd_addr = mshr.paddr;</pre>
<pre>      e_lce_cmd_addr_lru_way_addr: lce_cmd_addr = mshr.lru_paddr;</pre>
<pre>      e_lce_cmd_addr_0: lce_cmd_addr = '0;</pre>
<pre>      default: lce_cmd_addr = '0;</pre>
<pre>    endcase</pre>
<pre style="background-color: #FF0000;">    case (decoded_inst_i.lce_cmd_way_sel)</pre>
<pre>      e_lce_cmd_way_r0: lce_cmd_way = gpr_i[e_gpr_r0][lg_num_lce_lp-1:0];</pre>
<pre>      e_lce_cmd_way_r1: lce_cmd_way = gpr_i[e_gpr_r1][lg_num_lce_lp-1:0];</pre>
<pre>      e_lce_cmd_way_r2: lce_cmd_way = gpr_i[e_gpr_r2][lg_num_lce_lp-1:0];</pre>
<pre>      e_lce_cmd_way_r3: lce_cmd_way = gpr_i[e_gpr_r3][lg_num_lce_lp-1:0];</pre>
<pre>      e_lce_cmd_way_r4: lce_cmd_way = gpr_i[e_gpr_r4][lg_num_lce_lp-1:0];</pre>
<pre>      e_lce_cmd_way_r5: lce_cmd_way = gpr_i[e_gpr_r5][lg_num_lce_lp-1:0];</pre>
<pre>      e_lce_cmd_way_r6: lce_cmd_way = gpr_i[e_gpr_r6][lg_num_lce_lp-1:0];</pre>
<pre>      e_lce_cmd_way_r7: lce_cmd_way = gpr_i[e_gpr_r7][lg_num_lce_lp-1:0];</pre>
<pre>      e_lce_cmd_way_req_addr_way: lce_cmd_way = mshr.way_id;</pre>
<pre>      e_lce_cmd_way_tr_addr_way: lce_cmd_way = mshr.tr_way_id;</pre>
<pre>      e_lce_cmd_way_sh_list_r0: lce_cmd_way = sharers_ways_i[gpr_i[e_gpr_r0][lg_num_lce_lp-1:0]];</pre>
<pre>      e_lce_cmd_way_lru_addr_way: lce_cmd_way = mshr.lru_way_id;</pre>
<pre>      e_lce_cmd_way_0: lce_cmd_way = '0;</pre>
<pre>      default: lce_cmd_way = '0;</pre>
<pre>    endcase</pre>
<pre></pre>
<pre>      mem_cmd_lo.addr = mem_cmd_addr;</pre>
<pre>      mem_cmd_lo.size = e_mem_size_64;</pre>
<pre>      mem_cmd_lo.payload.lce_id = mshr.lce_id;</pre>
<pre>      mem_cmd_lo.payload.way_id = mshr.lru_way_id;</pre>
<pre>      mem_cmd_lo.payload.state = mshr.next_coh_state;</pre>
<pre>      mem_cmd_lo.data = '0;</pre>
<pre></pre>
<pre>        mem_cmd_v_o = 1'b1;</pre>
<pre>        // load or store</pre>
<pre>          mem_cmd_lo.msg_type.cce_mem_cmd = e_cce_mem_uc_wr;</pre>
<pre>          mem_cmd_lo.data = {(cce_block_width_p-dword_width_p)'('0),nc_data_i};</pre>
<pre>        end else begin</pre>
<pre>          mem_cmd_lo.msg_type.cce_mem_cmd = e_cce_mem_uc_rd;</pre>
<pre>        end</pre>
<pre>          (mshr.uc_req_size == e_lce_uc_req_1)</pre>
<pre>          ? e_mem_size_1</pre>
<pre>          : (mshr.uc_req_size == e_lce_uc_req_2)</pre>
<pre>            ? e_mem_size_2</pre>
<pre>            : (mshr.uc_req_size == e_lce_uc_req_4)</pre>
<pre>              ? e_mem_size_4</pre>
<pre>              : e_mem_size_8</pre>
<pre>          ;</pre>
<pre></pre>
<pre>        mem_cmd_v_o = 1'b1;</pre>
<pre></pre>
<pre>          mem_cmd_lo.msg_type.cce_mem_cmd = e_cce_mem_wb;</pre>
<pre>          mem_cmd_lo.data = lce_resp.data;</pre>
<pre>          mem_cmd_lo.payload.lce_id = lce_resp.src_id;</pre>
<pre>          mem_cmd_lo.payload.way_id = '0;</pre>
<pre>        end</pre>
<pre>        pending_w_way_group_o =</pre>
<pre>          mem_cmd_addr[(way_group_offset_high_lp-1) -: lg_num_way_groups_lp];</pre>
<pre>        pending_o = 1'b1;</pre>
<pre></pre>
<pre>            | mem_cmd_lo.msg_type.cce_mem_cmd == e_cce_mem_wr</pre>
<pre>            | mem_cmd_lo.msg_type.cce_mem_cmd == e_cce_mem_rd) begin</pre>
<pre>          fence_inc = mem_cmd_v_o & mem_cmd_ready_i;</pre>
<pre>        end</pre>
<pre>      // TODO: implement pushq memResp with more flexibility</pre>
<pre>      mem_resp_lo.msg_type = decoded_inst_i.mem_resp;</pre>
<pre>      // mem_cmd_li stores addr into mshr. This assumes it is still valid.</pre>
<pre></pre>
<pre>      lce_cmd_v_o = 1'b1;</pre>
<pre></pre>
<pre>      lce_cmd.msg_type = decoded_inst_i.lce_cmd;</pre>
<pre>      lce_cmd.way_id = lce_cmd_way;</pre>
<pre></pre>
<pre>      lce_cmd.msg.cmd.addr = lce_cmd_addr;</pre>
<pre></pre>
<pre>      lce_cmd.msg.cmd.target = '0;</pre>
<pre>      lce_cmd.msg.cmd.target_way_id = '0;</pre>
<pre></pre>
<pre>          | (decoded_inst_i.lce_cmd == e_lce_cmd_set_tag_wakeup)) begin</pre>
<pre>        lce_cmd.msg.cmd.state = mshr.next_coh_state;</pre>
<pre>      end</pre>
<pre>        lce_cmd.msg.cmd.state = mshr.next_coh_state;</pre>
<pre>        lce_cmd.msg.cmd.target = mshr.lce_id;</pre>
<pre>        lce_cmd.msg.cmd.target_way_id = mshr.lru_way_id;</pre>
<pre>      end</pre>
<pre>      lce_req_yumi_o = decoded_inst_i.lce_req_yumi;</pre>
<pre>    end</pre>
<pre>      lce_resp_yumi_o = decoded_inst_i.lce_resp_yumi;</pre>
<pre>    end</pre>
<pre>      mem_resp_yumi_o = decoded_inst_i.mem_resp_yumi;</pre>
<pre>    end</pre>
<pre>      mem_cmd_yumi_o = decoded_inst_i.mem_cmd_yumi;</pre>
<pre>    end</pre>
<h3>./bp_me/src/v/wormhole/bp_me_cce_to_wormhole_link_client.v</h3>
<pre>module bp_me_cce_to_wormhole_link_client</pre>
<pre>  import bp_cce_pkg::*;</pre>
<pre style="background-color: #FF0000;">  import bp_common_pkg::*;</pre>
<pre>  import bp_common_aviary_pkg::*;</pre>
<pre>  `declare_bp_proc_params(cfg_p)</pre>
<pre style="background-color: #FF0000;">  `declare_bp_me_if_widths(paddr_width_p, cce_block_width_p, num_lce_p, lce_assoc_p)</pre>
<pre>  // TODO: Should be related to network credits</pre>
<pre>  , localparam num_outstanding_req_p           = 16</pre>
<pre>  // wormhole parameters</pre>
<pre>  , localparam bsg_ready_and_link_sif_width_lp = `bsg_ready_and_link_sif_width(mem_noc_flit_width_p)</pre>
<pre>  )</pre>
<pre style="background-color: #FF0000;">  </pre>
<pre>  , input                                        reset_i</pre>
<pre></pre>
<pre>  , output                                       mem_cmd_v_o</pre>
<pre>  , input                                        mem_cmd_yumi_i</pre>
<pre>                                           </pre>
<pre>  , input [cce_mem_msg_width_lp-1:0]             mem_resp_i</pre>
<pre>  , input                                        mem_resp_v_i</pre>
<pre>  , output                                       mem_resp_ready_o</pre>
<pre></pre>
<pre>  // Configuration</pre>
<pre>  , input [mem_noc_cid_width_p-1:0]              my_cid_i</pre>
<pre>    </pre>
<pre>  , output [bsg_ready_and_link_sif_width_lp-1:0] cmd_link_o</pre>
<pre></pre>
<pre>  , output [bsg_ready_and_link_sif_width_lp-1:0] resp_link_o</pre>
<pre>  );</pre>
<pre>  `declare_bsg_wormhole_concentrator_packet_s(mem_noc_cord_width_p, mem_noc_len_width_p, mem_noc_cid_width_p, $bits(mem_cmd_payload_s), mem_cmd_packet_s);</pre>
<pre>  `declare_bsg_wormhole_concentrator_packet_s(mem_noc_cord_width_p, mem_noc_len_width_p, mem_noc_cid_width_p, $bits(mem_resp_payload_s), mem_resp_packet_s);</pre>
<pre>  logic [mem_noc_cid_width_p-1:0] fifo_cid_li, fifo_cid_lo;</pre>
<pre>  logic fifo_ready_lo, fifo_v_li, fifo_v_lo, fifo_yumi_li;</pre>
<pre></pre>
<pre>  logic mem_cmd_packet_v_lo, mem_cmd_packet_yumi_li;</pre>
<pre>  bsg_wormhole_router_adapter_out</pre>
<pre>   #(.max_payload_width_p($bits(mem_cmd_payload_s)+mem_noc_cid_width_p)</pre>
<pre>     ,.len_width_p(mem_noc_len_width_p)</pre>
<pre>     ,.cord_width_p(mem_noc_cord_width_p)</pre>
<pre>     ,.flit_width_p(mem_noc_flit_width_p)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">    (.clk_i(clk_i)</pre>
<pre>      ,.reset_i(reset_i)</pre>
<pre>  </pre>
<pre>      ,.link_o(cmd_link_o)</pre>
<pre>  </pre>
<pre>      ,.v_o(mem_cmd_packet_v_lo)</pre>
<pre>      ,.yumi_i(mem_cmd_packet_yumi_li)</pre>
<pre>      );</pre>
<pre>  assign mem_cmd_payload_lo = mem_cmd_packet_lo.payload;</pre>
<pre>  assign mem_cmd_o = mem_cmd_payload_lo.data;</pre>
<pre>  assign mem_cmd_v_o = mem_cmd_packet_v_lo & fifo_ready_lo;</pre>
<pre>  assign mem_cmd_packet_yumi_li = mem_cmd_yumi_i;</pre>
<pre>  </pre>
<pre>  assign fifo_cord_li = mem_cmd_payload_lo.src_cord;</pre>
<pre>  assign fifo_cid_li  = mem_cmd_payload_lo.src_cid;</pre>
<pre>  assign fifo_v_li    = mem_cmd_yumi_i & ~mem_resp_v_i;</pre>
<pre>  bsg_fifo_1r1w_small </pre>
<pre>  #(.width_p(mem_noc_cid_width_p+mem_noc_cord_width_p)</pre>
<pre>    ,.els_p(num_outstanding_req_p)</pre>
<pre>    )</pre>
<pre>  cord_fifo</pre>
<pre style="background-color: #FF0000;">   (.clk_i  (clk_i)</pre>
<pre>    ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>    ,.data_i ({fifo_cid_li, fifo_cord_li})</pre>
<pre>    ,.ready_o(fifo_ready_lo)</pre>
<pre>    ,.v_i    (fifo_v_li)</pre>
<pre></pre>
<pre>    ,.data_o ({fifo_cid_lo, fifo_cord_lo})</pre>
<pre>    ,.v_o    (fifo_v_lo)</pre>
<pre>    ,.yumi_i (fifo_yumi_li)</pre>
<pre>    );</pre>
<pre>  assign fifo_yumi_li = fifo_v_lo & mem_resp_ready_o & mem_resp_v_i;</pre>
<pre></pre>
<pre>  wire [mem_noc_cord_width_p-1:0] dst_cord_lo = (mem_cmd_yumi_i & mem_resp_v_i) ? mem_cmd_payload_lo.src_cord : fifo_cord_lo;</pre>
<pre>  wire [mem_noc_cid_width_p-1:0] dst_cid_lo   = (mem_cmd_yumi_i & mem_resp_v_i) ? mem_cmd_payload_lo.src_cid  : fifo_cid_lo;</pre>
<pre>  </pre>
<pre>  bp_me_wormhole_packet_encode_mem_resp</pre>
<pre>   #(.cfg_p(cfg_p))</pre>
<pre>   mem_resp_encode</pre>
<pre>    (.mem_resp_i(mem_resp_i)</pre>
<pre>     ,.src_cord_i(my_cord_i)</pre>
<pre>     ,.src_cid_i(my_cid_i)</pre>
<pre>     ,.dst_cord_i(dst_cord_lo)</pre>
<pre>     ,.dst_cid_i(dst_cid_lo)</pre>
<pre>     ,.packet_o(mem_resp_packet_lo)</pre>
<pre>     );</pre>
<pre>  bsg_wormhole_router_adapter_in</pre>
<pre>   #(.max_payload_width_p($bits(mem_resp_payload_s)+mem_noc_cid_width_p)</pre>
<pre>     ,.len_width_p(mem_noc_len_width_p)</pre>
<pre>     ,.cord_width_p(mem_noc_cord_width_p)</pre>
<pre>     ,.flit_width_p(mem_noc_flit_width_p)</pre>
<pre>     )</pre>
<pre>   mem_resp_adapter_in</pre>
<pre>    (.clk_i(clk_i)</pre>
<pre>     ,.reset_i(reset_i)</pre>
<pre>  </pre>
<pre>     ,.packet_i(mem_resp_packet_lo)</pre>
<pre>     ,.v_i(mem_resp_v_i)</pre>
<pre>     ,.ready_o(mem_resp_ready_o)</pre>
<pre>  </pre>
<pre>     ,.link_i(resp_link_i)</pre>
<pre>     ,.link_o(resp_link_o)</pre>
<pre>     );</pre>
<pre>endmodule</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<h3>./bp_me/src/v/wormhole/bp_me_wormhole_packet_encode_lce_resp.v</h3>
<pre> *</pre>
<pre style="background-color: #FF0000;"> *    packet = {payload, length, cord}</pre>
<pre> */</pre>
<pre>module bp_me_wormhole_packet_encode_lce_resp</pre>
<pre>    `declare_bp_proc_params(cfg_p)</pre>
<pre>        `bsg_wormhole_concentrator_packet_width(coh_noc_cord_width_p, coh_noc_len_width_p, coh_noc_cid_width_p, lce_cce_resp_width_lp)</pre>
<pre>    , output [lce_cce_resp_packet_width_lp-1:0] packet_o</pre>
<pre>    );</pre>
<pre style="background-color: #FF0000;">  `declare_bp_lce_cce_if(num_cce_p, num_lce_p, paddr_width_p, lce_assoc_p, dword_width_p, cce_block_width_p);</pre>
<pre>  `declare_bsg_wormhole_concentrator_packet_s(coh_noc_cord_width_p, coh_noc_len_width_p, coh_noc_cid_width_p, lce_cce_resp_width_lp, lce_cce_resp_packet_s);</pre>
<pre></pre>
<pre>  bp_lce_cce_resp_s payload_cast_i;</pre>
<pre>  lce_cce_resp_packet_s packet_cast_o;</pre>
<pre>  assign payload_cast_i = payload_i;</pre>
<pre>  assign packet_o = packet_cast_o;</pre>
<pre></pre>
<pre>  localparam lce_cce_resp_ack_len_lp =</pre>
<pre>    `BSG_CDIV(lce_cce_resp_packet_width_lp-$bits(payload_cast_i.data), coh_noc_flit_width_p) - 1;</pre>
<pre>  localparam lce_cce_resp_wb_len_lp =</pre>
<pre>    `BSG_CDIV(lce_cce_resp_packet_width_lp, coh_noc_flit_width_p) - 1;</pre>
<pre></pre>
<pre>  logic [coh_noc_cid_width_p-1:0]  cce_cid_li;</pre>
<pre>  bp_me_cce_id_to_cord</pre>
<pre>   #(.cfg_p(cfg_p))</pre>
<pre>   router_cord</pre>
<pre>    (.cce_id_i(payload_cast_i.dst_id)</pre>
<pre>     ,.cce_cord_o(cce_cord_li)</pre>
<pre>     ,.cce_cid_o(cce_cid_li)</pre>
<pre>     );</pre>
<pre>    packet_cast_o.payload = payload_cast_i;</pre>
<pre>    packet_cast_o.cid     = cce_cid_li;</pre>
<pre>    packet_cast_o.cord    = cce_cord_li;</pre>
<pre></pre>
<pre>      e_lce_cce_sync_ack</pre>
<pre>      ,e_lce_cce_inv_ack</pre>
<pre>      ,e_lce_cce_coh_ack    : packet_cast_o.len = coh_noc_len_width_p'(lce_cce_resp_ack_len_lp);</pre>
<pre>      e_lce_cce_resp_wb     : packet_cast_o.len = coh_noc_len_width_p'(lce_cce_resp_wb_len_lp);</pre>
<pre>      e_lce_cce_resp_null_wb: packet_cast_o.len = coh_noc_len_width_p'(lce_cce_resp_ack_len_lp);</pre>
<pre>      default: packet_cast_o = '0;</pre>
<pre>    endcase</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./bp_me/src/v/cce/bp_cce_msg_uncached.v</h3>
<pre> *   when the CCE is in the uncached only access mode (i.e., executing prior to the microcode</pre>
<pre style="background-color: #FF0000;"> *   being loaded).</pre>
<pre style="background-color: #FF0000;"> *</pre>
<pre>module bp_cce_msg_uncached</pre>
<pre>  #(parameter num_lce_p                    = "inv"</pre>
<pre>    , parameter num_cce_p                  = "inv"</pre>
<pre>    , parameter paddr_width_p              = "inv"</pre>
<pre>    , parameter lce_assoc_p                = "inv"</pre>
<pre>    , parameter lce_sets_p                 = "inv"</pre>
<pre>    , parameter block_size_in_bytes_p      = "inv"</pre>
<pre>    , parameter lce_req_data_width_p       = "inv"</pre>
<pre>    , localparam block_size_in_bits_lp     = (block_size_in_bytes_p*8)</pre>
<pre>    , localparam mshr_width_lp = `bp_cce_mshr_width(num_lce_p, lce_assoc_p, paddr_width_p)</pre>
<pre>   , input                                             reset_i</pre>
<pre></pre>
<pre>   , input [lg_num_cce_lp-1:0]                         cce_id_i</pre>
<pre>   , input bp_cce_mode_e                               cce_mode_i</pre>
<pre></pre>
<pre style="background-color: #FF0000;">   // LCE-CCE Interface</pre>
<pre>   , input                                             lce_req_v_i</pre>
<pre>   , output logic                                      lce_req_yumi_o</pre>
<pre></pre>
<pre></pre>
<pre>   , output logic                                      lce_cmd_v_o</pre>
<pre>   , input                                             lce_cmd_ready_i</pre>
<pre></pre>
<pre>   , input                                             mem_resp_v_i</pre>
<pre>   , output logic                                      mem_resp_yumi_o</pre>
<pre></pre>
<pre>   , input [cce_mem_msg_width_lp-1:0]                  mem_cmd_i</pre>
<pre>   , input                                             mem_cmd_v_i</pre>
<pre>   , output logic                                      mem_cmd_yumi_o</pre>
<pre></pre>
<pre>   , output logic [cce_mem_msg_width_lp-1:0]           mem_cmd_o</pre>
<pre>   , output logic                                      mem_cmd_v_o</pre>
<pre>   , input                                             mem_cmd_ready_i</pre>
<pre></pre>
<pre>   , output logic [cce_mem_msg_width_lp-1:0]           mem_resp_o</pre>
<pre>   , output logic                                      mem_resp_v_o</pre>
<pre>   , input                                             mem_resp_ready_i</pre>
<pre>  );</pre>
<pre></pre>
<pre>  `declare_bp_me_if(paddr_width_p, block_size_in_bits_lp, num_lce_p, lce_assoc_p);</pre>
<pre style="background-color: #FF0000;">  `declare_bp_lce_cce_if(num_cce_p, num_lce_p, paddr_width_p, lce_assoc_p, lce_req_data_width_p, block_size_in_bits_lp);</pre>
<pre style="background-color: #FF0000;"></pre>
<pre>  bp_cce_mem_msg_s mem_resp_li, mem_resp_lo, mem_cmd_lo, mem_cmd_li;</pre>
<pre>  bp_lce_cmd_s     lce_cmd;</pre>
<pre>  bp_lce_cmd_cmd_s lce_cmd_cmd;</pre>
<pre></pre>
<pre>  assign mem_cmd_o = mem_cmd_lo;</pre>
<pre>  assign mem_resp_o = mem_resp_lo;</pre>
<pre></pre>
<pre>  // cast input queue messages to structure variables</pre>
<pre>  assign lce_req = lce_req_i;</pre>
<pre>  assign mem_resp_li = mem_resp_i;</pre>
<pre>  assign mem_cmd_li = mem_cmd_i;</pre>
<pre></pre>
<pre>  typedef enum logic [1:0] {</pre>
<pre>    READY</pre>
<pre>    ,SEND_MEM_CMD</pre>
<pre>    ,SEND_MEM_DATA_CMD</pre>
<pre>  } uc_state_e;</pre>
<pre></pre>
<pre>  uc_state_e uc_state, uc_state_n;</pre>
<pre></pre>
<pre>    // This module only operates when reset is low and CCE is in uncached mode</pre>
<pre>    if (reset_i | (cce_mode_i != e_cce_mode_uncached)) begin</pre>
<pre>      uc_state <= READY;</pre>
<pre>      lce_req_r <= '0;</pre>
<pre>    end else begin</pre>
<pre>      uc_state <= uc_state_n;</pre>
<pre>      lce_req_r <= lce_req_n;</pre>
<pre>    end</pre>
<pre>  // Input messages to the CCE are buffered by two element FIFOs in bp_cce_top.v, thus</pre>
<pre style="background-color: #FF0000;">  // the outbound valid signal is a yumi.</pre>
<pre style="background-color: #FF0000;">  // buffered by bp_cce_top.v, but messages to memory are.</pre>
<pre>  always_comb begin</pre>
<pre>    // defaults for output signals</pre>
<pre>    lce_req_yumi_o = '0;</pre>
<pre>    lce_resp_yumi_o = '0;</pre>
<pre>    mem_resp_yumi_o = '0;</pre>
<pre>    mem_cmd_yumi_o = '0;</pre>
<pre></pre>
<pre>    lce_cmd = '0;</pre>
<pre>    lce_cmd_cmd = '0;</pre>
<pre>    mem_cmd_v_o = '0;</pre>
<pre>    mem_cmd_lo = '0;</pre>
<pre>    mem_resp_v_o = '0;</pre>
<pre>    mem_resp_lo = '0;</pre>
<pre></pre>
<pre>    lce_req_n = lce_req_r;</pre>
<pre></pre>
<pre>    uc_state_n = READY;</pre>
<pre></pre>
<pre>    // only operate if not in reset and cce mode is uncached</pre>
<pre>    if (~reset_i & (cce_mode_i == e_cce_mode_uncached)) begin</pre>
<pre>      case (uc_state)</pre>
<pre>      READY: begin</pre>
<pre>        uc_state_n = READY;</pre>
<pre></pre>
<pre>          // after load response is received, need to send data back to LCE</pre>
<pre></pre>
<pre>          lce_cmd.dst_id = mem_resp_li.payload.lce_id;</pre>
<pre>          lce_cmd.msg_type = e_lce_cmd_uc_data;</pre>
<pre>          lce_cmd.way_id = '0;</pre>
<pre>          lce_cmd.msg.dt_cmd.data = mem_resp_li.data;</pre>
<pre>          lce_cmd.msg.dt_cmd.addr = mem_resp_li.addr;</pre>
<pre></pre>
<pre>          // dequeue the mem data response if outbound lce data cmd is accepted</pre>
<pre></pre>
<pre>          // after store response is received, need to send uncached store done command to LCE</pre>
<pre></pre>
<pre>          lce_cmd.msg_type = e_lce_cmd_uc_st_done;</pre>
<pre>          lce_cmd.way_id = '0;</pre>
<pre></pre>
<pre>          lce_cmd_cmd.addr = mem_resp_li.addr;</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre>          lce_req_n = lce_req;</pre>
<pre>          lce_req_yumi_o = lce_req_v_i;</pre>
<pre>          // uncached read first sends a memory cmd, uncached store sends memory data cmd</pre>
<pre>                       ? SEND_MEM_CMD</pre>
<pre>                       : SEND_MEM_DATA_CMD;</pre>
<pre>        end</pre>
<pre>        // uncached load, send a memory cmd</pre>
<pre></pre>
<pre>        mem_cmd_lo.addr = lce_req_r.addr;</pre>
<pre>        mem_cmd_lo.size =</pre>
<pre>          (lce_req_r.msg.uc_req.uc_size == e_lce_uc_req_1)</pre>
<pre>          ? e_mem_size_1</pre>
<pre>          : (lce_req_r.msg.uc_req.uc_size == e_lce_uc_req_2)</pre>
<pre>            ? e_mem_size_2</pre>
<pre>            : (lce_req_r.msg.uc_req.uc_size == e_lce_uc_req_4)</pre>
<pre>              ? e_mem_size_4</pre>
<pre>              : e_mem_size_8</pre>
<pre>          ;</pre>
<pre>        mem_cmd_lo.payload.way_id = '0;</pre>
<pre>        mem_cmd_lo.data = '0;</pre>
<pre></pre>
<pre></pre>
<pre>      end</pre>
<pre>        // uncached store, send memory data cmd</pre>
<pre></pre>
<pre>        mem_cmd_lo.addr = lce_req_r.addr;</pre>
<pre>        mem_cmd_lo.size =</pre>
<pre>          (lce_req_r.msg.uc_req.uc_size == e_lce_uc_req_1)</pre>
<pre>          ? e_mem_size_1</pre>
<pre>          : (lce_req_r.msg.uc_req.uc_size == e_lce_uc_req_2)</pre>
<pre>            ? e_mem_size_2</pre>
<pre>            : (lce_req_r.msg.uc_req.uc_size == e_lce_uc_req_4)</pre>
<pre>              ? e_mem_size_4</pre>
<pre>              : e_mem_size_8</pre>
<pre>          ;</pre>
<pre>        mem_cmd_lo.payload.way_id = '0;</pre>
<pre>        mem_cmd_lo.data = lce_req_r.msg.uc_req.data;</pre>
<pre></pre>
<pre></pre>
<pre>      end</pre>
<pre>        uc_state_n = READY;</pre>
<pre>      end</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./bp_me/src/v/cce/bp_cce_pc.v</h3>
<pre>module bp_cce_pc</pre>
<pre>  #(parameter inst_ram_els_p             = "inv"</pre>
<pre>    , parameter cfg_link_addr_width_p = "inv"</pre>
<pre>    , parameter cfg_link_data_width_p = "inv"</pre>
<pre>    , parameter cfg_ram_base_addr_p   = "inv"</pre>
<pre>    , parameter harden_p                 = 0</pre>
<pre>    , localparam inst_ram_addr_width_lp  = `BSG_SAFE_CLOG2(inst_ram_els_p)</pre>
<pre></pre>
<pre>    , localparam cfg_link_hi_pad_width_lp = cfg_link_data_width_p-cfg_link_hi_data_width_lp</pre>
<pre></pre>
<pre>  )</pre>
<pre>   , input                                       reset_i</pre>
<pre>   , input                                       freeze_i</pre>
<pre></pre>
<pre>   , input [cfg_link_addr_width_p-1:0]           cfg_addr_i</pre>
<pre>   , input [cfg_link_data_width_p-1:0]           cfg_data_i</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre>   , input [inst_ram_addr_width_lp-1:0]          pc_branch_target_i</pre>
<pre></pre>
<pre>   , output logic                                inst_v_o</pre>
<pre>  );</pre>
<pre>    assert(cfg_link_addr_width_p == 16) else $error("config link address not 16-bits");</pre>
<pre>    assert(cfg_link_data_width_p == 32) else $error("config link data not 32-bits");</pre>
<pre>  end</pre>
<pre>    RESET</pre>
<pre>    ,INIT</pre>
<pre>    ,INIT_CFG_REG_RESP</pre>
<pre>    ,INIT_RAM_RD_RESP</pre>
<pre>    ,INIT_END</pre>
<pre>    ,FETCH_1</pre>
<pre>    ,FETCH_2</pre>
<pre>    ,FETCH</pre>
<pre>  } pc_state_e;</pre>
<pre></pre>
<pre></pre>
<pre>  assign cce_mode_o = cce_mode_r;</pre>
<pre></pre>
<pre>  logic inst_v_r, inst_v_n;</pre>
<pre>  logic ram_v_r, ram_v_n;</pre>
<pre>  logic ram_w_r, ram_w_n;</pre>
<pre>  logic [inst_ram_addr_width_lp-1:0] ram_addr_li, ram_addr_r, ram_addr_n;</pre>
<pre>  logic [inst_width_lp-1:0] ram_data_r, ram_data_n, ram_data_lo;</pre>
<pre>  logic [inst_width_lp-1:0] ram_w_mask_r, ram_w_mask_n;</pre>
<pre></pre>
<pre>    #(.width_p(inst_width_lp)</pre>
<pre>      ,.els_p(inst_ram_els_p)</pre>
<pre>      )</pre>
<pre style="background-color: #FF0000;">     (.clk_i(clk_i)</pre>
<pre>      ,.reset_i(reset_i)</pre>
<pre>      ,.v_i(ram_v_r)</pre>
<pre>      ,.data_i(ram_data_r)</pre>
<pre>      ,.addr_i(ram_addr_li)</pre>
<pre>      ,.w_i(ram_w_r)</pre>
<pre>      ,.data_o(ram_data_lo)</pre>
<pre>      ,.w_mask_i(ram_w_mask_r)</pre>
<pre>      );</pre>
<pre>    if (reset_i) begin</pre>
<pre>      pc_state_r <= RESET;</pre>
<pre></pre>
<pre>      inst_v_r <= '0;</pre>
<pre>      ram_v_r <= '0;</pre>
<pre>      ram_w_r <= '0;</pre>
<pre>      ram_addr_r <= '0;</pre>
<pre>      ram_data_r <= '0;</pre>
<pre>      ram_w_mask_r <= '0;</pre>
<pre></pre>
<pre></pre>
<pre>      pc_state_r <= pc_state_n;</pre>
<pre></pre>
<pre>      inst_v_r <= inst_v_n;</pre>
<pre>      ram_v_r <= ram_v_n;</pre>
<pre>      ram_w_r <= ram_w_n;</pre>
<pre>      ram_addr_r <= ram_addr_n;</pre>
<pre>      ram_data_r <= ram_data_n;</pre>
<pre>      ram_w_mask_r <= ram_w_mask_n;</pre>
<pre></pre>
<pre>    end</pre>
<pre>  wire cfg_cce_mode_addr_v  = cfg_addr_i == bp_cfg_reg_cce_mode_gp;</pre>
<pre></pre>
<pre></pre>
<pre>  assign inst_o = (inst_v_o) ? ram_data_lo : '0;</pre>
<pre></pre>
<pre>    // by default, regardless of the pc_state, send the instruction ram the registered value</pre>
<pre></pre>
<pre>    ex_pc_n = '0;</pre>
<pre>    inst_v_n = '0;</pre>
<pre>    ram_v_n = '0;</pre>
<pre>    ram_w_n = '0;</pre>
<pre>    ram_addr_n = ram_addr_r;</pre>
<pre>    ram_data_n = '0;</pre>
<pre>    ram_w_mask_n = '0;</pre>
<pre></pre>
<pre></pre>
<pre>      RESET: begin</pre>
<pre>        pc_state_n = INIT;</pre>
<pre>      end</pre>
<pre>        // In INIT, the CCE waits for commands to arrive on the configuration link</pre>
<pre>          // finalize init, then start fetching microcode next</pre>
<pre>        // only do something if the config link input is valid, and the address targets the CCE</pre>
<pre>          cce_mode_n = bp_cce_mode_e'(cfg_data_i[0+:`bp_cce_mode_bits]);</pre>
<pre>        // address is reading or writing the instruction RAM</pre>
<pre>          // inputs to RAM are valid if config address high bit is set</pre>
<pre>          ram_w_n = cfg_w_v_i;</pre>
<pre>          // lsb of config address specifies if write is first or second part, so ram addr</pre>
<pre>          if (cfg_addr_i[0]) begin</pre>
<pre>            ram_w_mask_n = {(cfg_link_hi_data_width_lp)'('1),(cfg_link_data_width_p)'('0)};</pre>
<pre>            ram_data_n = {cfg_data_i[0+:cfg_link_hi_data_width_lp],(cfg_link_data_width_p)'('0)};</pre>
<pre>          end else begin</pre>
<pre>            ram_w_mask_n = {(cfg_link_hi_data_width_lp)'('0),(cfg_link_data_width_p)'('1)};</pre>
<pre>            ram_data_n = {(cfg_link_hi_data_width_lp)'('0),cfg_data_i};</pre>
<pre>          end</pre>
<pre>        // let the last cfg link write finish (if there is one)</pre>
<pre>      end</pre>
<pre>        // At the end of this cycle, the RAM will write the last instruction from the boot ROM</pre>
<pre></pre>
<pre>        ram_addr_n = '0;</pre>
<pre></pre>
<pre>        inst_v_n = '0;</pre>
<pre></pre>
<pre>        // setup the registers for the first instruction</pre>
<pre></pre>
<pre>        ram_addr_n = ram_addr_r + 'd1;</pre>
<pre></pre>
<pre>        inst_v_n = 1'b1;</pre>
<pre></pre>
<pre>        // Always continue fetching instructions</pre>
<pre>        // next instruction is always valid once in steady state</pre>
<pre></pre>
<pre>        // setup RAM address register and register tracking PC of instruction being executed</pre>
<pre>          // when stalling, hold executing pc and ram addr registers constant</pre>
<pre>          ram_addr_n = ram_addr_r;</pre>
<pre>          // feed the currently executing pc as input to instruction ram</pre>
<pre>        end else if (alu_branch_res_i) begin</pre>
<pre>          // when branching, the instruction executed next is the branch target</pre>
<pre>          // the following instruction to fetch is after the branch target</pre>
<pre>          // if branching, use the branch target from the current instruction</pre>
<pre>        end else begin</pre>
<pre>          // normal execution, the instruction that will be executed is the one that will</pre>
<pre>          // the next instruction to fetch follows sequentially</pre>
<pre>          // normally, use the address register (i.e., sequential execution)</pre>
<pre>        end</pre>
<pre>        pc_state_n = RESET;</pre>
<pre>      end</pre>
<h3>./bp_me/src/v/cce/bp_cce_pending.v</h3>
<pre>module bp_cce_pending</pre>
<pre>  #(parameter num_way_groups_p            = "inv"</pre>
<pre>    , parameter width_p                   = 2</pre>
<pre></pre>
<pre>   , input                                                        reset_i</pre>
<pre></pre>
<pre>   , input [lg_num_way_groups_lp-1:0]                             w_way_group_i</pre>
<pre>   , input                                                        pending_i</pre>
<pre></pre>
<pre>   , input [lg_num_way_groups_lp-1:0]                             r_way_group_i</pre>
<pre></pre>
<pre>   , output logic                                                 pending_v_o</pre>
<pre></pre>
<pre></pre>
<pre>    if (reset_i) begin</pre>
<pre>      pending_bits_r <= '0;</pre>
<pre>    end else begin</pre>
<pre>      pending_bits_r <= pending_bits_n;</pre>
<pre>    end</pre>
<pre>    if (reset_i) begin</pre>
<pre>      pending_bits_n = '0;</pre>
<pre>    end else begin</pre>
<pre>      pending_bits_n = pending_bits_r;</pre>
<pre>      if (w_v_i) begin</pre>
<pre>        if (pending_i) begin // increment count</pre>
<pre>          pending_bits_n[w_way_group_i] = pending_bits_r[w_way_group_i] + 'd1;</pre>
<pre>        end else begin // decrement count</pre>
<pre>          pending_bits_n[w_way_group_i] = pending_bits_r[w_way_group_i] - 'd1;</pre>
<pre>        end</pre>
<pre>    ? ~(pending_bits_n[r_way_group_i] == 0)</pre>
<pre>    : ~(pending_bits_r[r_way_group_i] == 0);</pre>
<pre></pre>
<pre></pre>
<h3>./bp_me/src/v/wormhole/bp_me_wormhole_packet_encode_lce_req.v</h3>
<pre> *</pre>
<pre style="background-color: #FF0000;"> *    packet = {payload, length, cord}</pre>
<pre> */</pre>
<pre>module bp_me_wormhole_packet_encode_lce_req</pre>
<pre>    `declare_bp_proc_params(cfg_p)</pre>
<pre>        `bsg_wormhole_concentrator_packet_width(coh_noc_cord_width_p, coh_noc_len_width_p, coh_noc_cid_width_p, lce_cce_req_width_lp)</pre>
<pre>    , output [lce_cce_req_packet_width_lp-1:0] packet_o</pre>
<pre>    );</pre>
<pre style="background-color: #FF0000;">  `declare_bp_lce_cce_if(num_cce_p, num_lce_p, paddr_width_p, lce_assoc_p, dword_width_p, cce_block_width_p);</pre>
<pre>  `declare_bsg_wormhole_concentrator_packet_s(coh_noc_cord_width_p, coh_noc_len_width_p, coh_noc_cid_width_p, lce_cce_req_width_lp, lce_cce_req_packet_s);</pre>
<pre></pre>
<pre>  bp_lce_cce_req_s payload_cast_i;</pre>
<pre>  lce_cce_req_packet_s packet_cast_o;</pre>
<pre>  assign payload_cast_i = payload_i;</pre>
<pre>  assign packet_o = packet_cast_o;</pre>
<pre></pre>
<pre>  localparam lce_cce_req_req_len_lp =</pre>
<pre>    `BSG_CDIV(lce_cce_req_packet_width_lp-$bits(payload_cast_i.msg.req.pad), coh_noc_flit_width_p) - 1;</pre>
<pre>  localparam lce_cce_req_uc_wr_len_lp =</pre>
<pre>    `BSG_CDIV(lce_cce_req_packet_width_lp, coh_noc_flit_width_p) - 1;</pre>
<pre>  localparam lce_cce_req_uc_rd_len_lp =</pre>
<pre>    `BSG_CDIV(lce_cce_req_packet_width_lp-$bits(payload_cast_i.msg.uc_req.data), coh_noc_flit_width_p) - 1;</pre>
<pre></pre>
<pre>  logic [coh_noc_cid_width_p-1:0]  cce_cid_li;</pre>
<pre>  bp_me_cce_id_to_cord</pre>
<pre>   #(.cfg_p(cfg_p))</pre>
<pre>   router_cord</pre>
<pre>    (.cce_id_i(payload_cast_i.dst_id)</pre>
<pre>     ,.cce_cord_o(cce_cord_li)</pre>
<pre>     ,.cce_cid_o(cce_cid_li)</pre>
<pre>     );</pre>
<pre>    packet_cast_o.payload = payload_cast_i;</pre>
<pre>    packet_cast_o.cid     = cce_cid_li;</pre>
<pre>    packet_cast_o.cord    = cce_cord_li;</pre>
<pre></pre>
<pre>      e_lce_req_type_rd</pre>
<pre>      ,e_lce_req_type_wr  : packet_cast_o.len = coh_noc_len_width_p'(lce_cce_req_req_len_lp);</pre>
<pre>      e_lce_req_type_uc_rd: packet_cast_o.len = coh_noc_len_width_p'(lce_cce_req_uc_wr_len_lp);</pre>
<pre>      e_lce_req_type_uc_wr: packet_cast_o.len = coh_noc_len_width_p'(lce_cce_req_uc_wr_len_lp);</pre>
<pre>      default: packet_cast_o = '0;</pre>
<pre>    endcase</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./bp_me/src/v/wormhole/bp_me_wormhole_packet_encode_mem_resp.v</h3>
<pre style="background-color: #FF0000;"> *</pre>
<pre style="background-color: #FF0000;"> *    packet = {payload, length, cord}</pre>
<pre style="background-color: #FF0000;"> */</pre>
<pre>module bp_me_wormhole_packet_encode_mem_resp</pre>
<pre>  import bp_common_aviary_pkg::*;</pre>
<pre>  import bp_cce_pkg::*;</pre>
<pre>  import bp_me_pkg::*;</pre>
<pre>  #(parameter bp_cfg_e cfg_p = e_bp_inv_cfg</pre>
<pre>    `declare_bp_proc_params(cfg_p)</pre>
<pre style="background-color: #FF0000;">    `declare_bp_me_if_widths(paddr_width_p, cce_block_width_p, num_lce_p, lce_assoc_p)</pre>
<pre></pre>
<pre>        `bp_mem_wormhole_payload_width(mem_noc_reserved_width_p, mem_noc_cord_width_p, mem_noc_cid_width_p, cce_mem_msg_width_lp)</pre>
<pre>        `bsg_wormhole_concentrator_packet_width(mem_noc_cord_width_p, mem_noc_len_width_p, mem_noc_cid_width_p, mem_resp_payload_width_lp)</pre>
<pre>    , input [mem_noc_cord_width_p-1:0]      src_cord_i</pre>
<pre>    , input [mem_noc_cid_width_p-1:0]       src_cid_i</pre>
<pre>    , input [mem_noc_cord_width_p-1:0]      dst_cord_i</pre>
<pre>    , input [mem_noc_cid_width_p-1:0]       dst_cid_i</pre>
<pre>    , output [mem_resp_packet_width_lp-1:0] packet_o</pre>
<pre>    );</pre>
<pre></pre>
<pre style="background-color: #FF0000;">  `declare_bsg_wormhole_concentrator_packet_s(mem_noc_cord_width_p, mem_noc_len_width_p, mem_noc_cid_width_p, $bits(bp_resp_wormhole_payload_s), bp_resp_wormhole_packet_s);</pre>
<pre>  bp_resp_wormhole_packet_s packet_cast_o;</pre>
<pre></pre>
<pre>  assign packet_o       = packet_cast_o;</pre>
<pre></pre>
<pre></pre>
<pre>    `BSG_CDIV(mem_resp_packet_width_lp-$bits(mem_resp_cast_i.data), mem_noc_flit_width_p) - 1;</pre>
<pre>  localparam mem_resp_data_len_1_lp =</pre>
<pre>    `BSG_CDIV(mem_resp_packet_width_lp-$bits(mem_resp_cast_i.data) + 8*1, mem_noc_flit_width_p) - 1;</pre>
<pre>  localparam mem_resp_data_len_2_lp =</pre>
<pre>    `BSG_CDIV(mem_resp_packet_width_lp-$bits(mem_resp_cast_i.data) + 8*2, mem_noc_flit_width_p) - 1;</pre>
<pre>  localparam mem_resp_data_len_4_lp =</pre>
<pre>    `BSG_CDIV(mem_resp_packet_width_lp-$bits(mem_resp_cast_i.data) + 8*4, mem_noc_flit_width_p) - 1;</pre>
<pre>  localparam mem_resp_data_len_8_lp =</pre>
<pre>    `BSG_CDIV(mem_resp_packet_width_lp-$bits(mem_resp_cast_i.data) + 8*8, mem_noc_flit_width_p) - 1;</pre>
<pre>  localparam mem_resp_data_len_16_lp =</pre>
<pre>    `BSG_CDIV(mem_resp_packet_width_lp-$bits(mem_resp_cast_i.data) + 8*16, mem_noc_flit_width_p) - 1;</pre>
<pre>  localparam mem_resp_data_len_32_lp =</pre>
<pre>    `BSG_CDIV(mem_resp_packet_width_lp-$bits(mem_resp_cast_i.data) + 8*32, mem_noc_flit_width_p) - 1;</pre>
<pre>  localparam mem_resp_data_len_64_lp =</pre>
<pre>    `BSG_CDIV(mem_resp_packet_width_lp-$bits(mem_resp_cast_i.data) + 8*64, mem_noc_flit_width_p) - 1;</pre>
<pre></pre>
<pre></pre>
<pre>    payload_li.data = mem_resp_i;</pre>
<pre>    payload_li.reserved = '0;</pre>
<pre>    payload_li.src_cord = src_cord_i;</pre>
<pre>    payload_li.src_cid = src_cid_i;</pre>
<pre></pre>
<pre>    packet_cast_o.cid     = dst_cid_i;</pre>
<pre>    packet_cast_o.cord    = dst_cord_i;</pre>
<pre></pre>
<pre>      e_mem_size_1 : data_resp_len_li = mem_noc_len_width_p'(mem_resp_data_len_1_lp);</pre>
<pre>      e_mem_size_2 : data_resp_len_li = mem_noc_len_width_p'(mem_resp_data_len_2_lp);</pre>
<pre>      e_mem_size_4 : data_resp_len_li = mem_noc_len_width_p'(mem_resp_data_len_4_lp);</pre>
<pre>      e_mem_size_8 : data_resp_len_li = mem_noc_len_width_p'(mem_resp_data_len_8_lp);</pre>
<pre>      e_mem_size_16: data_resp_len_li = mem_noc_len_width_p'(mem_resp_data_len_16_lp);</pre>
<pre>      e_mem_size_32: data_resp_len_li = mem_noc_len_width_p'(mem_resp_data_len_32_lp);</pre>
<pre>      e_mem_size_64: data_resp_len_li = mem_noc_len_width_p'(mem_resp_data_len_64_lp);</pre>
<pre>      default: data_resp_len_li = '0;</pre>
<pre>    endcase</pre>
<pre>    case (mem_resp_cast_i.msg_type)</pre>
<pre>      e_cce_mem_rd</pre>
<pre>      ,e_cce_mem_wr</pre>
<pre>      ,e_cce_mem_uc_rd: packet_cast_o.len = data_resp_len_li;</pre>
<pre>      e_cce_mem_uc_wr</pre>
<pre>      ,e_cce_mem_wb   : packet_cast_o.len = mem_noc_len_width_p'(mem_resp_ack_len_lp);</pre>
<pre>      default: packet_cast_o = '0;</pre>
<pre>    endcase</pre>
<pre>endmodule</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<h3>./bp_me/src/v/cce/bp_cce_top.v</h3>
<pre> *</pre>
<pre style="background-color: #FF0000;"> * Notes:</pre>
<pre> *   All inputs from the LCE are buffered. LCE Responses require a FIFO that can hold up to</pre>
<pre>module bp_cce_top</pre>
<pre>    `declare_bp_proc_params(cfg_p)</pre>
<pre>    , localparam lg_num_cce_lp          = `BSG_SAFE_CLOG2(num_cce_p)</pre>
<pre>    , localparam wg_per_cce_lp          = (lce_sets_p / num_cce_p)</pre>
<pre></pre>
<pre>   , input                                                 reset_i</pre>
<pre>   , input                                                 freeze_i</pre>
<pre></pre>
<pre>   , input [cfg_addr_width_p-1:0]                          cfg_addr_i</pre>
<pre>   , input [cfg_data_width_p-1:0]                          cfg_data_i</pre>
<pre></pre>
<pre>   , input                                                 lce_req_v_i</pre>
<pre>   , output logic                                          lce_req_ready_o</pre>
<pre></pre>
<pre>   , input                                                 lce_resp_v_i</pre>
<pre>   , output logic                                          lce_resp_ready_o</pre>
<pre></pre>
<pre>   , output logic                                          lce_cmd_v_o</pre>
<pre>   , input                                                 lce_cmd_ready_i</pre>
<pre></pre>
<pre>   , input                                                 mem_resp_v_i</pre>
<pre>   , output logic                                          mem_resp_ready_o</pre>
<pre></pre>
<pre>   , input                                                 mem_cmd_v_i</pre>
<pre>   , output logic                                          mem_cmd_ready_o</pre>
<pre></pre>
<pre>   , output logic                                          mem_cmd_v_o</pre>
<pre>   , input                                                 mem_cmd_yumi_i</pre>
<pre></pre>
<pre>   , output logic                                          mem_resp_v_o</pre>
<pre>   , input                                                 mem_resp_yumi_i</pre>
<pre></pre>
<pre>   , input [lg_num_cce_lp-1:0]                             cce_id_i</pre>
<pre>  );</pre>
<pre></pre>
<pre>  logic [lce_cce_req_width_lp-1:0]               lce_req_to_cce;</pre>
<pre>  logic                                          lce_req_v_to_cce;</pre>
<pre>  logic                                          lce_req_yumi_from_cce;</pre>
<pre>  logic [lce_cce_resp_width_lp-1:0]              lce_resp_to_cce;</pre>
<pre>  logic                                          lce_resp_v_to_cce;</pre>
<pre>  logic                                          lce_resp_yumi_from_cce;</pre>
<pre>  logic [cce_mem_msg_width_lp-1:0]               mem_resp_to_cce;</pre>
<pre>  logic                                          mem_resp_v_to_cce;</pre>
<pre>  logic                                          mem_resp_yumi_from_cce;</pre>
<pre>  logic [cce_mem_msg_width_lp-1:0]               mem_cmd_to_cce;</pre>
<pre>  logic                                          mem_cmd_v_to_cce;</pre>
<pre>  logic                                          mem_cmd_yumi_from_cce;</pre>
<pre>  logic [cce_mem_msg_width_lp-1:0]               mem_cmd_from_cce;</pre>
<pre>  logic                                          mem_cmd_v_from_cce;</pre>
<pre>  logic                                          mem_cmd_ready_to_cce;</pre>
<pre>  logic [cce_mem_msg_width_lp-1:0]               mem_resp_from_cce;</pre>
<pre>  logic                                          mem_resp_v_from_cce;</pre>
<pre>  logic                                          mem_resp_ready_to_cce;</pre>
<pre></pre>
<pre>  // Inbound LCE to CCE</pre>
<pre style="background-color: #FF0000;">  bsg_two_fifo</pre>
<pre>    #(.width_p(lce_cce_req_width_lp)</pre>
<pre>      )</pre>
<pre>     (.clk_i(clk_i)</pre>
<pre>      ,.reset_i(reset_i)</pre>
<pre>      ,.v_i(lce_req_v_i)</pre>
<pre>      ,.data_i(lce_req_i)</pre>
<pre>      ,.ready_o(lce_req_ready_o)</pre>
<pre>      ,.v_o(lce_req_v_to_cce)</pre>
<pre>      ,.data_o(lce_req_to_cce)</pre>
<pre>      ,.yumi_i(lce_req_yumi_from_cce)</pre>
<pre>      );</pre>
<pre></pre>
<pre>  bsg_fifo_1r1w_small</pre>
<pre>    #(.width_p(lce_cce_resp_width_lp)</pre>
<pre>      // See top comments about sizing</pre>
<pre>      )</pre>
<pre>    lce_cce_resp_fifo</pre>
<pre>     (.clk_i(clk_i)</pre>
<pre>      ,.reset_i(reset_i)</pre>
<pre>      ,.v_i(lce_resp_v_i)</pre>
<pre>      ,.data_i(lce_resp_i)</pre>
<pre>      ,.ready_o(lce_resp_ready_o)</pre>
<pre>      ,.v_o(lce_resp_v_to_cce)</pre>
<pre>      ,.data_o(lce_resp_to_cce)</pre>
<pre>      ,.yumi_i(lce_resp_yumi_from_cce)</pre>
<pre>      );</pre>
<pre></pre>
<pre>  // Inbound Mem to CCE</pre>
<pre>  bsg_fifo_1r1w_small</pre>
<pre>    #(.width_p(cce_mem_msg_width_lp)</pre>
<pre>      // See top comments about sizing</pre>
<pre>      ,.els_p(wg_per_cce_lp)</pre>
<pre>      )</pre>
<pre style="background-color: #FF0000;">    mem_cce_resp_fifo</pre>
<pre style="background-color: #FF0000;">     (.clk_i(clk_i)</pre>
<pre>      ,.reset_i(reset_i)</pre>
<pre>      ,.v_i(mem_resp_v_i)</pre>
<pre>      ,.data_i(mem_resp_i)</pre>
<pre>      ,.ready_o(mem_resp_ready_o)</pre>
<pre>      ,.v_o(mem_resp_v_to_cce)</pre>
<pre>      ,.data_o(mem_resp_to_cce)</pre>
<pre>      ,.yumi_i(mem_resp_yumi_from_cce)</pre>
<pre>      );</pre>
<pre></pre>
<pre>    #(.width_p(cce_mem_msg_width_lp)</pre>
<pre>      )</pre>
<pre style="background-color: #FF0000;">     (.clk_i(clk_i)</pre>
<pre>      ,.reset_i(reset_i)</pre>
<pre>      ,.v_i(mem_cmd_v_i)</pre>
<pre>      ,.data_i(mem_cmd_i)</pre>
<pre>      ,.ready_o(mem_cmd_ready_o)</pre>
<pre>      ,.v_o(mem_cmd_v_to_cce)</pre>
<pre>      ,.data_o(mem_cmd_to_cce)</pre>
<pre>      ,.yumi_i(mem_cmd_yumi_from_cce)</pre>
<pre>      );</pre>
<pre>    #(.width_p(cce_mem_msg_width_lp)</pre>
<pre>      )</pre>
<pre style="background-color: #FF0000;">     (.clk_i(clk_i)</pre>
<pre>      ,.reset_i(reset_i)</pre>
<pre>      ,.v_i(mem_cmd_v_from_cce)</pre>
<pre>      ,.data_i(mem_cmd_from_cce)</pre>
<pre>      ,.ready_o(mem_cmd_ready_to_cce)</pre>
<pre>      ,.v_o(mem_cmd_v_o)</pre>
<pre>      ,.data_o(mem_cmd_o)</pre>
<pre>      ,.yumi_i(mem_cmd_yumi_i)</pre>
<pre>      );</pre>
<pre>    #(.width_p(cce_mem_msg_width_lp)</pre>
<pre>      )</pre>
<pre style="background-color: #FF0000;">     (.clk_i(clk_i)</pre>
<pre>      ,.reset_i(reset_i)</pre>
<pre>      ,.v_i(mem_resp_v_from_cce)</pre>
<pre>      ,.data_i(mem_resp_from_cce)</pre>
<pre>      ,.ready_o(mem_resp_ready_to_cce)</pre>
<pre>      ,.v_o(mem_resp_v_o)</pre>
<pre>      ,.data_o(mem_resp_o)</pre>
<pre>      ,.yumi_i(mem_resp_yumi_i)</pre>
<pre>      );</pre>
<pre>    #(.cfg_p(cfg_p))</pre>
<pre>    bp_cce</pre>
<pre style="background-color: #FF0000;">     (.clk_i(clk_i)</pre>
<pre>      ,.reset_i(reset_i)</pre>
<pre>      ,.freeze_i(freeze_i)</pre>
<pre></pre>
<pre></pre>
<pre>      ,.cfg_addr_i(cfg_addr_i)</pre>
<pre>      ,.cfg_data_i(cfg_data_i)</pre>
<pre></pre>
<pre>      ,.lce_req_v_i(lce_req_v_to_cce)</pre>
<pre>      ,.lce_req_yumi_o(lce_req_yumi_from_cce)</pre>
<pre>      ,.lce_resp_i(lce_resp_to_cce)</pre>
<pre>      ,.lce_resp_v_i(lce_resp_v_to_cce)</pre>
<pre>      ,.lce_resp_yumi_o(lce_resp_yumi_from_cce)</pre>
<pre></pre>
<pre>      ,.lce_cmd_v_o(lce_cmd_v_o)</pre>
<pre>      ,.lce_cmd_ready_i(lce_cmd_ready_i)</pre>
<pre></pre>
<pre>      ,.mem_resp_v_i(mem_resp_v_to_cce)</pre>
<pre>      ,.mem_resp_yumi_o(mem_resp_yumi_from_cce)</pre>
<pre>      ,.mem_cmd_i(mem_cmd_to_cce)</pre>
<pre>      ,.mem_cmd_v_i(mem_cmd_v_to_cce)</pre>
<pre>      ,.mem_cmd_yumi_o(mem_cmd_yumi_from_cce)</pre>
<pre></pre>
<pre>      ,.mem_cmd_v_o(mem_cmd_v_from_cce)</pre>
<pre>      ,.mem_cmd_ready_i(mem_cmd_ready_to_cce)</pre>
<pre>      ,.mem_resp_o(mem_resp_from_cce)</pre>
<pre>      ,.mem_resp_v_o(mem_resp_v_from_cce)</pre>
<pre>      ,.mem_resp_ready_i(mem_resp_ready_to_cce)</pre>
<pre>      );</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./bp_me/src/v/wormhole/bp_me_wormhole_packet_encode_lce_cmd.v</h3>
<pre> *</pre>
<pre style="background-color: #FF0000;"> *    packet = {payload, length, cord}</pre>
<pre> */</pre>
<pre>module bp_me_wormhole_packet_encode_lce_cmd</pre>
<pre>    `declare_bp_proc_params(cfg_p)</pre>
<pre>        `bsg_wormhole_concentrator_packet_width(coh_noc_cord_width_p, coh_noc_len_width_p, coh_noc_cid_width_p, lce_cmd_width_lp)</pre>
<pre>    , output [lce_cmd_packet_width_lp-1:0] packet_o</pre>
<pre>    );</pre>
<pre style="background-color: #FF0000;">  `declare_bp_lce_cce_if(num_cce_p, num_lce_p, paddr_width_p, lce_assoc_p, dword_width_p, cce_block_width_p);</pre>
<pre>  `declare_bsg_wormhole_concentrator_packet_s(coh_noc_cord_width_p, coh_noc_len_width_p, coh_noc_cid_width_p, lce_cmd_width_lp, lce_cmd_packet_s);</pre>
<pre></pre>
<pre>  bp_lce_cmd_s payload_cast_i;</pre>
<pre>  lce_cmd_packet_s packet_cast_o;</pre>
<pre>  assign payload_cast_i = payload_i;</pre>
<pre>  assign packet_o = packet_cast_o;</pre>
<pre></pre>
<pre>  localparam lce_cmd_cmd_len_lp = </pre>
<pre>    `BSG_CDIV(lce_cmd_packet_width_lp-$bits(payload_cast_i.msg.cmd.pad), coh_noc_flit_width_p) - 1;</pre>
<pre>  localparam lce_cmd_data_len_lp = </pre>
<pre>    `BSG_CDIV(lce_cmd_packet_width_lp, coh_noc_flit_width_p) - 1;</pre>
<pre>  localparam lce_cmd_uc_data_len_lp =</pre>
<pre>    `BSG_CDIV(lce_cmd_packet_width_lp-(cce_block_width_p-dword_width_p), coh_noc_flit_width_p) - 1;</pre>
<pre></pre>
<pre>  logic [coh_noc_cid_width_p-1:0]  lce_cid_li;</pre>
<pre>  bp_me_lce_id_to_cord</pre>
<pre>   #(.cfg_p(cfg_p))</pre>
<pre>   router_cord</pre>
<pre>    (.lce_id_i(payload_cast_i.dst_id)</pre>
<pre>     ,.lce_cord_o(lce_cord_li)</pre>
<pre>     ,.lce_cid_o(lce_cid_li)</pre>
<pre>     );</pre>
<pre>    packet_cast_o.payload = payload_cast_i;</pre>
<pre>    packet_cast_o.cid     = lce_cid_li;</pre>
<pre>    packet_cast_o.cord    = lce_cord_li;</pre>
<pre></pre>
<pre>      e_lce_cmd_sync</pre>
<pre>      ,e_lce_cmd_set_clear</pre>
<pre>      ,e_lce_cmd_transfer</pre>
<pre>      ,e_lce_cmd_writeback</pre>
<pre>      ,e_lce_cmd_set_tag</pre>
<pre>      ,e_lce_cmd_set_tag_wakeup</pre>
<pre>      ,e_lce_cmd_invalidate_tag</pre>
<pre>      ,e_lce_cmd_uc_st_done: packet_cast_o.len = coh_noc_len_width_p'(lce_cmd_cmd_len_lp);</pre>
<pre>      e_lce_cmd_data       : packet_cast_o.len = coh_noc_len_width_p'(lce_cmd_data_len_lp);</pre>
<pre>      e_lce_cmd_uc_data    : packet_cast_o.len = coh_noc_len_width_p'(lce_cmd_uc_data_len_lp); </pre>
<pre>      default: packet_cast_o = '0;</pre>
<pre>    endcase</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./bp_me/src/v/wormhole/bp_me_wormhole_packet_encode_mem_cmd.v</h3>
<pre style="background-color: #FF0000;"> *</pre>
<pre style="background-color: #FF0000;"> *    packet = {payload, length, cord}</pre>
<pre style="background-color: #FF0000;"> */</pre>
<pre>module bp_me_wormhole_packet_encode_mem_cmd</pre>
<pre>  import bp_common_aviary_pkg::*;</pre>
<pre>  import bp_cce_pkg::*;</pre>
<pre>  import bp_me_pkg::*;</pre>
<pre>  #(parameter bp_cfg_e cfg_p = e_bp_inv_cfg</pre>
<pre>    `declare_bp_proc_params(cfg_p)</pre>
<pre style="background-color: #FF0000;">    `declare_bp_me_if_widths(paddr_width_p, cce_block_width_p, num_lce_p, lce_assoc_p)</pre>
<pre></pre>
<pre>        `bp_mem_wormhole_payload_width(mem_noc_reserved_width_p, mem_noc_cord_width_p, mem_noc_cid_width_p, cce_mem_msg_width_lp)</pre>
<pre>        `bsg_wormhole_concentrator_packet_width(mem_noc_cord_width_p, mem_noc_len_width_p, mem_noc_cid_width_p, mem_cmd_payload_width_lp)</pre>
<pre>    </pre>
<pre>    , input [mem_noc_cord_width_p-1:0]     src_cord_i</pre>
<pre>    , input [mem_noc_cid_width_p-1:0]      src_cid_i</pre>
<pre>    , input [mem_noc_cord_width_p-1:0]     dst_cord_i</pre>
<pre>    , input [mem_noc_cid_width_p-1:0]      dst_cid_i</pre>
<pre></pre>
<pre>    , output [mem_cmd_packet_width_lp-1:0] packet_o</pre>
<pre>    );</pre>
<pre style="background-color: #FF0000;">  `declare_bsg_wormhole_concentrator_packet_s(mem_noc_cord_width_p, mem_noc_len_width_p, mem_noc_cid_width_p, $bits(bp_cmd_wormhole_payload_s), bp_cmd_wormhole_packet_s);</pre>
<pre>  bp_cmd_wormhole_packet_s packet_cast_o;</pre>
<pre></pre>
<pre>  assign packet_o       = packet_cast_o;</pre>
<pre></pre>
<pre></pre>
<pre>    `BSG_CDIV(mem_cmd_packet_width_lp-$bits(mem_cmd_cast_i.data), mem_noc_flit_width_p) - 1;</pre>
<pre>  localparam mem_cmd_data_len_1_lp =</pre>
<pre>    `BSG_CDIV(mem_cmd_packet_width_lp-$bits(mem_cmd_cast_i.data) + 8*1, mem_noc_flit_width_p) - 1;</pre>
<pre>  localparam mem_cmd_data_len_2_lp =</pre>
<pre>    `BSG_CDIV(mem_cmd_packet_width_lp-$bits(mem_cmd_cast_i.data) + 8*2, mem_noc_flit_width_p) - 1;</pre>
<pre>  localparam mem_cmd_data_len_4_lp =</pre>
<pre>    `BSG_CDIV(mem_cmd_packet_width_lp-$bits(mem_cmd_cast_i.data) + 8*4, mem_noc_flit_width_p) - 1;</pre>
<pre>  localparam mem_cmd_data_len_8_lp =</pre>
<pre>    `BSG_CDIV(mem_cmd_packet_width_lp-$bits(mem_cmd_cast_i.data) + 8*8, mem_noc_flit_width_p) - 1;</pre>
<pre>  localparam mem_cmd_data_len_16_lp =</pre>
<pre>    `BSG_CDIV(mem_cmd_packet_width_lp-$bits(mem_cmd_cast_i.data) + 8*16, mem_noc_flit_width_p) - 1;</pre>
<pre>  localparam mem_cmd_data_len_32_lp =</pre>
<pre>    `BSG_CDIV(mem_cmd_packet_width_lp-$bits(mem_cmd_cast_i.data) + 8*32, mem_noc_flit_width_p) - 1;</pre>
<pre>  localparam mem_cmd_data_len_64_lp =</pre>
<pre>    `BSG_CDIV(mem_cmd_packet_width_lp-$bits(mem_cmd_cast_i.data) + 8*64, mem_noc_flit_width_p) - 1;</pre>
<pre></pre>
<pre></pre>
<pre>    payload_li.data = mem_cmd_i;</pre>
<pre>    payload_li.reserved = '0;</pre>
<pre>    payload_li.src_cord = src_cord_i;</pre>
<pre>    payload_li.src_cid  = src_cid_i;</pre>
<pre></pre>
<pre>    packet_cast_o.cord    = dst_cord_i;</pre>
<pre>    packet_cast_o.cid     = dst_cid_i;</pre>
<pre></pre>
<pre>      e_mem_size_1 : data_cmd_len_li = mem_noc_len_width_p'(mem_cmd_data_len_1_lp);</pre>
<pre>      e_mem_size_2 : data_cmd_len_li = mem_noc_len_width_p'(mem_cmd_data_len_2_lp);</pre>
<pre>      e_mem_size_4 : data_cmd_len_li = mem_noc_len_width_p'(mem_cmd_data_len_4_lp);</pre>
<pre>      e_mem_size_8 : data_cmd_len_li = mem_noc_len_width_p'(mem_cmd_data_len_8_lp);</pre>
<pre>      e_mem_size_16: data_cmd_len_li = mem_noc_len_width_p'(mem_cmd_data_len_16_lp);</pre>
<pre>      e_mem_size_32: data_cmd_len_li = mem_noc_len_width_p'(mem_cmd_data_len_32_lp);</pre>
<pre>      e_mem_size_64: data_cmd_len_li = mem_noc_len_width_p'(mem_cmd_data_len_64_lp);</pre>
<pre>      default: data_cmd_len_li = '0;</pre>
<pre>    endcase</pre>
<pre>    case (mem_cmd_cast_i.msg_type)</pre>
<pre>      e_cce_mem_rd</pre>
<pre>      ,e_cce_mem_wr</pre>
<pre>      ,e_cce_mem_uc_rd</pre>
<pre>      ,e_mem_cce_inv  : packet_cast_o.len = mem_noc_len_width_p'(mem_cmd_req_len_lp);</pre>
<pre>      e_cce_mem_uc_wr</pre>
<pre>      ,e_cce_mem_wb   : packet_cast_o.len = data_cmd_len_li;</pre>
<pre>      default: packet_cast_o = '0;</pre>
<pre>    endcase</pre>
<pre>endmodule</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<h3>./bp_me/src/v/wormhole/bp_me_cce_to_wormhole_link_master.v</h3>
<pre>module bp_me_cce_to_wormhole_link_master</pre>
<pre>  import bp_cce_pkg::*;</pre>
<pre style="background-color: #FF0000;">  import bp_common_pkg::*;</pre>
<pre>  import bp_common_aviary_pkg::*;</pre>
<pre>  `declare_bp_proc_params(cfg_p)</pre>
<pre>  , localparam bsg_ready_and_link_sif_width_lp = `bsg_ready_and_link_sif_width(mem_noc_flit_width_p)</pre>
<pre>  )</pre>
<pre>  </pre>
<pre>  (input                                         clk_i</pre>
<pre>  , input                                        reset_i</pre>
<pre></pre>
<pre>  , input                                        mem_cmd_v_i</pre>
<pre>  , output                                       mem_cmd_ready_o</pre>
<pre>                                                  </pre>
<pre>  , output                                       mem_resp_v_o</pre>
<pre>  , input                                        mem_resp_yumi_i</pre>
<pre>                                                 </pre>
<pre>  // Configuration</pre>
<pre>  , input [mem_noc_cord_width_p-1:0]             my_cord_i</pre>
<pre>  , input [mem_noc_cid_width_p-1:0]              my_cid_i</pre>
<pre>  , input [mem_noc_cord_width_p-1:0]             mmio_cord_i</pre>
<pre>  , input [mem_noc_cord_width_p-1:0]             dram_cord_i</pre>
<pre>  , input [mem_noc_cord_width_p-1:0]             host_cord_i</pre>
<pre>  </pre>
<pre>  , output [bsg_ready_and_link_sif_width_lp-1:0] cmd_link_o</pre>
<pre></pre>
<pre>  , output [bsg_ready_and_link_sif_width_lp-1:0] resp_link_o</pre>
<pre>  );</pre>
<pre>  </pre>
<pre></pre>
<pre>assign mem_resp_o = mem_resp_cast_o;</pre>
<pre></pre>
<pre>`declare_bsg_wormhole_concentrator_packet_s(mem_noc_cord_width_p, mem_noc_len_width_p, mem_noc_cid_width_p, $bits(mem_cmd_payload_s), mem_cmd_packet_s);</pre>
<pre style="background-color: #FF0000;">`declare_bsg_wormhole_concentrator_packet_s(mem_noc_cord_width_p, mem_noc_len_width_p, mem_noc_cid_width_p, $bits(mem_resp_payload_s), mem_resp_packet_s);</pre>
<pre>logic [mem_noc_cid_width_p-1:0]  mem_cmd_dst_cid_lo;</pre>
<pre>bp_addr_map</pre>
<pre> #(.cfg_p(cfg_p))</pre>
<pre> cmd_map</pre>
<pre>  (.paddr_i(mem_cmd_cast_i.addr)</pre>
<pre></pre>
<pre>  ,.dram_cord_i(dram_cord_i)</pre>
<pre>  ,.host_cord_i(host_cord_i)</pre>
<pre></pre>
<pre>  ,.dst_cord_o(mem_cmd_dst_cord_lo)</pre>
<pre>  );</pre>
<pre>bp_me_wormhole_packet_encode_mem_cmd</pre>
<pre> #(.cfg_p(cfg_p))</pre>
<pre> mem_cmd_encode</pre>
<pre style="background-color: #FF0000;">  (.mem_cmd_i(mem_cmd_cast_i)</pre>
<pre>   ,.src_cord_i(my_cord_i)</pre>
<pre>   ,.src_cid_i(my_cid_i)</pre>
<pre>   ,.dst_cord_i(mem_cmd_dst_cord_lo)</pre>
<pre>   ,.dst_cid_i(mem_cmd_dst_cid_lo)</pre>
<pre>   ,.packet_o(mem_cmd_packet_li)</pre>
<pre>   );</pre>
<pre> #(.max_payload_width_p($bits(mem_cmd_payload_s)+mem_noc_cid_width_p)</pre>
<pre>   ,.len_width_p(mem_noc_len_width_p)</pre>
<pre>   ,.cord_width_p(mem_noc_cord_width_p)</pre>
<pre>   ,.flit_width_p(mem_noc_flit_width_p)</pre>
<pre>   )</pre>
<pre> mem_cmd_adapter_in</pre>
<pre>  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>   ,.packet_i(mem_cmd_packet_li)</pre>
<pre>   ,.v_i(mem_cmd_v_i)</pre>
<pre>   ,.ready_o(mem_cmd_ready_o)</pre>
<pre></pre>
<pre>   ,.link_i(cmd_link_i)</pre>
<pre>   ,.link_o(cmd_link_o)</pre>
<pre>   );</pre>
<pre></pre>
<pre>bsg_wormhole_router_adapter_out</pre>
<pre> #(.max_payload_width_p($bits(mem_resp_payload_s)+mem_noc_cid_width_p)</pre>
<pre>   ,.len_width_p(mem_noc_len_width_p)</pre>
<pre>   ,.cord_width_p(mem_noc_cord_width_p)</pre>
<pre>   ,.flit_width_p(mem_noc_flit_width_p)</pre>
<pre>   )</pre>
<pre> mem_resp_adapter_out</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>    ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>    ,.link_o(resp_link_o)</pre>
<pre></pre>
<pre>    ,.packet_o(mem_resp_packet_lo)</pre>
<pre>    ,.v_o(mem_resp_v_o)</pre>
<pre>    ,.yumi_i(mem_resp_yumi_i)</pre>
<pre>    );</pre>
<pre>mem_resp_payload_s mem_resp_payload_lo;</pre>
<pre>assign mem_resp_payload_lo = mem_resp_packet_lo.payload;</pre>
<pre>assign mem_resp_cast_o = mem_resp_payload_lo.data;</pre>
<pre></pre>
<pre>endmodule</pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<h3>./bp_top/src/v/bp_tile.v</h3>
<pre>module bp_tile</pre>
<pre> import bp_common_pkg::*;</pre>
<pre> import bp_common_aviary_pkg::*;</pre>
<pre> import bp_be_pkg::*;</pre>
<pre> import bsg_wormhole_router_pkg::*;</pre>
<pre> import bp_me_pkg::*;</pre>
<pre> #(parameter bp_cfg_e cfg_p = e_bp_inv_cfg</pre>
<pre>   `declare_bp_proc_params(cfg_p)</pre>
<pre>   , localparam mem_noc_ral_link_width_lp = `bsg_ready_and_link_sif_width(mem_noc_flit_width_p)</pre>
<pre></pre>
<pre>   , localparam proc_cfg_width_lp = `bp_proc_cfg_width(num_core_p, num_cce_p, num_lce_p)</pre>
<pre>   , input                                                    reset_i</pre>
<pre></pre>
<pre>   , input [proc_cfg_width_lp-1:0]                            proc_cfg_i</pre>
<pre></pre>
<pre>   // Memory side connection</pre>
<pre>   , input [mem_noc_cid_width_p-1:0]                          my_cid_i</pre>
<pre>   , input [mem_noc_cord_width_p-1:0]                         dram_cord_i</pre>
<pre>   , input [mem_noc_cord_width_p-1:0]                         mmio_cord_i</pre>
<pre>   , input [mem_noc_cord_width_p-1:0]                         host_cord_i</pre>
<pre></pre>
<pre>   , input [cfg_addr_width_p-1:0]                             cfg_addr_i</pre>
<pre>   , input [cfg_data_width_p-1:0]                             cfg_data_i</pre>
<pre></pre>
<pre>   , output [coh_noc_ral_link_width_lp-1:0]                   lce_req_link_o</pre>
<pre></pre>
<pre>   , output [coh_noc_ral_link_width_lp-1:0]                   lce_cmd_link_o</pre>
<pre></pre>
<pre>   , output [coh_noc_ral_link_width_lp-1:0]                   lce_resp_link_o</pre>
<pre></pre>
<pre>   , output [mem_noc_ral_link_width_lp-1:0]                   cmd_link_o</pre>
<pre></pre>
<pre>   , output [mem_noc_ral_link_width_lp-1:0]                   resp_link_o</pre>
<pre></pre>
<pre>   , input                                                    software_int_i</pre>
<pre>   , input                                                    external_int_i</pre>
<pre>   );</pre>
<pre style="background-color: #FF0000;">`declare_bp_common_proc_cfg_s(num_core_p, num_cce_p, num_lce_p)</pre>
<pre style="background-color: #FF0000;">`declare_bp_lce_cce_if(num_cce_p, num_lce_p, paddr_width_p, lce_assoc_p, dword_width_p, cce_block_width_p)</pre>
<pre></pre>
<pre style="background-color: #FF0000;">`declare_bsg_ready_and_link_sif_s(coh_noc_flit_width_p, bp_coh_ready_and_link_s);</pre>
<pre></pre>
<pre>bp_coh_ready_and_link_s lce_req_link_cast_i, lce_req_link_cast_o;</pre>
<pre>bp_coh_ready_and_link_s lce_resp_link_cast_i, lce_resp_link_cast_o;</pre>
<pre>bp_coh_ready_and_link_s lce_cmd_link_cast_i, lce_cmd_link_cast_o;</pre>
<pre></pre>
<pre>assign lce_req_link_cast_i  = lce_req_link_i;</pre>
<pre>assign lce_cmd_link_cast_i  = lce_cmd_link_i;</pre>
<pre>assign lce_resp_link_cast_i = lce_resp_link_i;</pre>
<pre></pre>
<pre>assign lce_req_link_o  = lce_req_link_cast_o;</pre>
<pre>assign lce_cmd_link_o  = lce_cmd_link_cast_o;</pre>
<pre>assign lce_resp_link_o = lce_resp_link_cast_o;</pre>
<pre></pre>
<pre>logic             [1:0] lce_req_v_lo, lce_req_ready_li;</pre>
<pre>bp_lce_cce_resp_s [1:0] lce_resp_lo;</pre>
<pre>logic             [1:0] lce_resp_v_lo, lce_resp_ready_li;</pre>
<pre>bp_lce_cmd_s      [1:0] lce_cmd_li;</pre>
<pre>logic             [1:0] lce_cmd_v_li, lce_cmd_ready_lo;</pre>
<pre>bp_lce_cmd_s      [1:0] lce_cmd_lo;</pre>
<pre>logic             [1:0] lce_cmd_v_lo, lce_cmd_ready_li;</pre>
<pre></pre>
<pre>// CCE connections</pre>
<pre>bp_lce_cce_req_s  cce_lce_req_li;</pre>
<pre>logic             cce_lce_req_v_li, cce_lce_req_ready_lo;</pre>
<pre>bp_lce_cmd_s      cce_lce_cmd_lo;</pre>
<pre>logic             cce_lce_cmd_v_lo, cce_lce_cmd_ready_li;</pre>
<pre>bp_lce_cce_resp_s cce_lce_resp_li;</pre>
<pre>logic             cce_lce_resp_v_li, cce_lce_resp_ready_lo;</pre>
<pre></pre>
<pre>// Mem connections</pre>
<pre>bp_cce_mem_msg_s       mem_cmd_lo;</pre>
<pre>logic                  mem_cmd_v_lo, mem_cmd_ready_li;</pre>
<pre>bp_cce_mem_msg_s       mem_resp_lo;</pre>
<pre>logic                  mem_resp_v_lo, mem_resp_ready_li;</pre>
<pre>bp_cce_mem_msg_s       mem_resp_li;</pre>
<pre>logic                  mem_resp_v_li, mem_resp_ready_lo;</pre>
<pre>bp_cce_mem_msg_s       mem_cmd_li;</pre>
<pre>logic                  mem_cmd_v_li, mem_cmd_ready_lo;</pre>
<pre></pre>
<pre>// TODO: connect mem_cmd_li and mem_resp_lo</pre>
<pre>assign mem_cmd_li = '0;</pre>
<pre>assign mem_cmd_v_li = '0;</pre>
<pre>assign mem_resp_ready_li = '0;</pre>
<pre></pre>
<pre>bp_proc_cfg_s proc_cfg_cast_i;</pre>
<pre>assign proc_cfg_cast_i = proc_cfg_i;</pre>
<pre></pre>
<pre>logic reset_r;</pre>
<pre>always_ff @(posedge clk_i)</pre>
<pre>  begin</pre>
<pre>    if (reset_i)</pre>
<pre>      reset_r <= 1'b1;</pre>
<pre>    else if (cfg_w_v_i & (cfg_addr_i == bp_cfg_reg_reset_gp))</pre>
<pre>      reset_r <= cfg_data_i[0];</pre>
<pre>  end</pre>
<pre>logic freeze_r;</pre>
<pre>always_ff @(posedge clk_i)</pre>
<pre>  begin</pre>
<pre>    if (reset_i)</pre>
<pre>      freeze_r <= 1'b1;</pre>
<pre>    else if (cfg_w_v_i & (cfg_addr_i == bp_cfg_reg_freeze_gp))</pre>
<pre>      freeze_r <= cfg_data_i[0];</pre>
<pre>  end</pre>
<pre>// Module instantiations</pre>
<pre>bp_core   </pre>
<pre> #(.cfg_p(cfg_p))</pre>
<pre> core </pre>
<pre>  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_r)</pre>
<pre></pre>
<pre>   ,.freeze_i(freeze_r)</pre>
<pre>   ,.proc_cfg_i(proc_cfg_i)</pre>
<pre></pre>
<pre style="background-color: #FF0000;">   ,.cfg_w_v_i(cfg_w_v_i)</pre>
<pre>   ,.cfg_addr_i(cfg_addr_i)</pre>
<pre>   ,.cfg_data_i(cfg_data_i)</pre>
<pre></pre>
<pre>   ,.lce_req_o(lce_req_lo)</pre>
<pre>   ,.lce_req_v_o(lce_req_v_lo)</pre>
<pre>   ,.lce_req_ready_i(lce_req_ready_li)</pre>
<pre></pre>
<pre>   ,.lce_resp_o(lce_resp_lo)</pre>
<pre>   ,.lce_resp_v_o(lce_resp_v_lo)</pre>
<pre>   ,.lce_resp_ready_i(lce_resp_ready_li)</pre>
<pre></pre>
<pre>   ,.lce_cmd_i(lce_cmd_li)</pre>
<pre>   ,.lce_cmd_v_i(lce_cmd_v_li)</pre>
<pre>   ,.lce_cmd_ready_o(lce_cmd_ready_lo)</pre>
<pre></pre>
<pre>   ,.lce_cmd_v_o(lce_cmd_v_lo)</pre>
<pre>   ,.lce_cmd_ready_i(lce_cmd_ready_li)</pre>
<pre>    </pre>
<pre>   ,.software_int_i(software_int_i)</pre>
<pre>   ,.external_int_i(external_int_i)</pre>
<pre>   );</pre>
<pre> #(.cfg_p(cfg_p))</pre>
<pre> cce</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_r)</pre>
<pre>   ,.freeze_i(freeze_r)</pre>
<pre></pre>
<pre>   ,.cfg_addr_i(cfg_addr_i)</pre>
<pre>   ,.cfg_data_i(cfg_data_i)</pre>
<pre></pre>
<pre>   ,.lce_req_v_i(cce_lce_req_v_li)</pre>
<pre>   ,.lce_req_ready_o(cce_lce_req_ready_lo)</pre>
<pre></pre>
<pre>   ,.lce_resp_v_i(cce_lce_resp_v_li)</pre>
<pre>   ,.lce_resp_ready_o(cce_lce_resp_ready_lo)</pre>
<pre></pre>
<pre>   ,.lce_cmd_v_o(cce_lce_cmd_v_lo)</pre>
<pre>   ,.lce_cmd_ready_i(cce_lce_cmd_ready_li)</pre>
<pre></pre>
<pre>   ,.mem_resp_v_i(mem_resp_v_li)</pre>
<pre>   ,.mem_resp_ready_o(mem_resp_ready_lo)</pre>
<pre></pre>
<pre>   ,.mem_cmd_v_i(mem_cmd_v_li)</pre>
<pre>   ,.mem_cmd_ready_o(mem_cmd_ready_lo)</pre>
<pre></pre>
<pre>   ,.mem_cmd_v_o(mem_cmd_v_lo)</pre>
<pre>   ,.mem_cmd_yumi_i(mem_cmd_ready_li & mem_cmd_v_lo)</pre>
<pre></pre>
<pre>   ,.mem_resp_v_o(mem_resp_v_lo)</pre>
<pre>   ,.mem_resp_yumi_i(mem_resp_ready_li & mem_resp_v_lo)</pre>
<pre></pre>
<pre>   );</pre>
<pre style="background-color: #FF0000;">`declare_bsg_wormhole_concentrator_packet_s(coh_noc_cord_width_p, coh_noc_len_width_p, coh_noc_cid_width_p, lce_cce_req_width_lp, lce_req_packet_s);</pre>
<pre style="background-color: #FF0000;">`declare_bsg_wormhole_concentrator_packet_s(coh_noc_cord_width_p, coh_noc_len_width_p, coh_noc_cid_width_p, lce_cmd_width_lp, lce_cmd_packet_s);</pre>
<pre style="background-color: #FF0000;">`declare_bsg_wormhole_concentrator_packet_s(coh_noc_cord_width_p, coh_noc_len_width_p, coh_noc_cid_width_p, lce_cce_resp_width_lp, lce_resp_packet_s);</pre>
<pre>lce_cmd_packet_s [1:0]  lce_cmd_packet_lo, lce_cmd_packet_li;</pre>
<pre>lce_resp_packet_s [1:0] lce_resp_packet_lo;</pre>
<pre></pre>
<pre>bp_coh_ready_and_link_s [1:0] lce_cmd_link_li, lce_cmd_link_lo;</pre>
<pre>bp_coh_ready_and_link_s [1:0] lce_resp_link_li, lce_resp_link_lo;</pre>
<pre></pre>
<pre>bp_coh_ready_and_link_s cce_lce_cmd_link_li, cce_lce_cmd_link_lo;</pre>
<pre>bp_coh_ready_and_link_s cce_lce_resp_link_li, cce_lce_resp_link_lo;</pre>
<pre></pre>
<pre>  begin : lce</pre>
<pre>    bp_me_wormhole_packet_encode_lce_req</pre>
<pre>     #(.cfg_p(cfg_p))</pre>
<pre>     req_encode</pre>
<pre style="background-color: #FF0000;">      (.payload_i(lce_req_lo[i])</pre>
<pre>       ,.packet_o(lce_req_packet_lo[i])</pre>
<pre>       );</pre>
<pre>     #(.max_payload_width_p($bits(lce_req_packet_s)-coh_noc_cord_width_p-coh_noc_len_width_p)</pre>
<pre>       ,.len_width_p(coh_noc_len_width_p)</pre>
<pre>       ,.cord_width_p(coh_noc_cord_width_p)</pre>
<pre>       ,.flit_width_p(coh_noc_flit_width_p)</pre>
<pre>       )</pre>
<pre style="background-color: #FF0000;">      (.clk_i(clk_i)</pre>
<pre>       ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>       ,.v_i(lce_req_v_lo[i])</pre>
<pre>       ,.ready_o(lce_req_ready_li[i])</pre>
<pre></pre>
<pre>       ,.link_o(lce_req_link_lo[i])</pre>
<pre>       );</pre>
<pre>     #(.cfg_p(cfg_p))</pre>
<pre>     cmd_encode</pre>
<pre style="background-color: #FF0000;">      (.payload_i(lce_cmd_lo[i])</pre>
<pre>       ,.packet_o(lce_cmd_packet_lo[i])</pre>
<pre>       );</pre>
<pre>     #(.max_payload_width_p($bits(lce_cmd_packet_s)-coh_noc_cord_width_p-coh_noc_len_width_p)</pre>
<pre>       ,.len_width_p(coh_noc_len_width_p)</pre>
<pre>       ,.cord_width_p(coh_noc_cord_width_p)</pre>
<pre>       ,.flit_width_p(coh_noc_flit_width_p)</pre>
<pre>       )</pre>
<pre style="background-color: #FF0000;">      (.clk_i(clk_i)</pre>
<pre>       ,.reset_i(reset_r)</pre>
<pre></pre>
<pre>       ,.v_i(lce_cmd_v_lo[i])</pre>
<pre>       ,.ready_o(lce_cmd_ready_li[i])</pre>
<pre></pre>
<pre>       ,.link_o(lce_cmd_link_lo[i])</pre>
<pre></pre>
<pre>       ,.v_o(lce_cmd_v_li[i])</pre>
<pre>       ,.yumi_i(lce_cmd_ready_lo[i] & lce_cmd_v_li[i])</pre>
<pre>       );</pre>
<pre></pre>
<pre>     #(.cfg_p(cfg_p))</pre>
<pre>     resp_encode</pre>
<pre style="background-color: #FF0000;">      (.payload_i(lce_resp_lo[i])</pre>
<pre>       ,.packet_o(lce_resp_packet_lo[i])</pre>
<pre>       );</pre>
<pre>     #(.max_payload_width_p($bits(lce_resp_packet_s)-coh_noc_cord_width_p-coh_noc_len_width_p)</pre>
<pre>       ,.len_width_p(coh_noc_len_width_p)</pre>
<pre>       ,.cord_width_p(coh_noc_cord_width_p)</pre>
<pre>       ,.flit_width_p(coh_noc_flit_width_p)</pre>
<pre>       )</pre>
<pre style="background-color: #FF0000;">     lce_resp_adapter_in</pre>
<pre style="background-color: #FF0000;">      (.clk_i(clk_i)</pre>
<pre>       ,.reset_i(reset_r)</pre>
<pre></pre>
<pre style="background-color: #FF0000;">       ,.packet_i(lce_resp_packet_lo[i])</pre>
<pre>       ,.v_i(lce_resp_v_lo[i])</pre>
<pre>       ,.ready_o(lce_resp_ready_li[i])</pre>
<pre></pre>
<pre>       ,.link_o(lce_resp_link_lo[i])</pre>
<pre>       );</pre>
<pre>  lce_req_packet_s cce_lce_req_packet_li;</pre>
<pre>  bsg_wormhole_router_adapter_out</pre>
<pre>   #(.max_payload_width_p($bits(lce_req_packet_s)-coh_noc_cord_width_p-coh_noc_len_width_p)</pre>
<pre>     ,.len_width_p(coh_noc_len_width_p)</pre>
<pre>     ,.cord_width_p(coh_noc_cord_width_p)</pre>
<pre>     ,.flit_width_p(coh_noc_flit_width_p)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">   (.clk_i(clk_i)</pre>
<pre>    ,.reset_i(reset_r)</pre>
<pre>  </pre>
<pre>    ,.link_o(cce_lce_req_link_lo)</pre>
<pre>  </pre>
<pre style="background-color: #FF0000;">    ,.packet_o(cce_lce_req_packet_li)</pre>
<pre>    ,.v_o(cce_lce_req_v_li)</pre>
<pre>    ,.yumi_i(cce_lce_req_ready_lo & cce_lce_req_v_li)</pre>
<pre>    );</pre>
<pre>      </pre>
<pre>  bp_me_wormhole_packet_encode_lce_cmd</pre>
<pre>   #(.cfg_p(cfg_p))</pre>
<pre>   cmd_encode</pre>
<pre style="background-color: #FF0000;">    (.payload_i(cce_lce_cmd_lo)</pre>
<pre>     ,.packet_o(cce_lce_cmd_packet_lo)</pre>
<pre>     );</pre>
<pre>   #(.max_payload_width_p($bits(lce_cmd_packet_s)-coh_noc_cord_width_p-coh_noc_len_width_p)</pre>
<pre>     ,.len_width_p(coh_noc_len_width_p)</pre>
<pre>     ,.cord_width_p(coh_noc_cord_width_p)</pre>
<pre>     ,.flit_width_p(coh_noc_flit_width_p)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">    (.clk_i(clk_i)</pre>
<pre>     ,.reset_i(reset_r)</pre>
<pre>  </pre>
<pre>     ,.v_i(cce_lce_cmd_v_lo)</pre>
<pre>     ,.ready_o(cce_lce_cmd_ready_li)</pre>
<pre>  </pre>
<pre>     ,.link_o(cce_lce_cmd_link_lo)</pre>
<pre>     );</pre>
<pre>  bsg_wormhole_router_adapter_out</pre>
<pre>   #(.max_payload_width_p($bits(lce_resp_packet_s)-coh_noc_cord_width_p-coh_noc_len_width_p)</pre>
<pre>     ,.len_width_p(coh_noc_len_width_p)</pre>
<pre>     ,.cord_width_p(coh_noc_cord_width_p)</pre>
<pre>     ,.flit_width_p(coh_noc_flit_width_p)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">   (.clk_i(clk_i)</pre>
<pre>    ,.reset_i(reset_r)</pre>
<pre>  </pre>
<pre>    ,.link_o(cce_lce_resp_link_lo)</pre>
<pre>  </pre>
<pre>    ,.v_o(cce_lce_resp_v_li)</pre>
<pre>    ,.yumi_i(cce_lce_resp_ready_lo & cce_lce_resp_v_li)</pre>
<pre>    );</pre>
<pre></pre>
<pre>  bp_coh_ready_and_link_s cmd_concentrated_link_li, cmd_concentrated_link_lo;</pre>
<pre>  bp_coh_ready_and_link_s resp_concentrated_link_li, resp_concentrated_link_lo;</pre>
<pre></pre>
<pre>  assign lce_req_link_cast_o = '{data          : req_concentrated_link_lo.data</pre>
<pre>                                 ,v            : req_concentrated_link_lo.v</pre>
<pre>                                 ,ready_and_rev: cce_lce_req_link_lo.ready_and_rev</pre>
<pre>                                 };</pre>
<pre style="background-color: #FF0000;">  bsg_wormhole_concentrator_in</pre>
<pre>   #(.flit_width_p(coh_noc_flit_width_p)</pre>
<pre>     ,.len_width_p(coh_noc_len_width_p)</pre>
<pre>     ,.cid_width_p(coh_noc_cid_width_p)</pre>
<pre>     ,.num_in_p(2)</pre>
<pre>     ,.cord_width_p(coh_noc_cord_width_p)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">    (.clk_i(clk_i)</pre>
<pre>     ,.reset_i(reset_r)</pre>
<pre></pre>
<pre>     ,.links_o(lce_req_link_li)</pre>
<pre></pre>
<pre>     ,.concentrated_link_o(req_concentrated_link_lo)</pre>
<pre>     );</pre>
<pre>  assign lce_cmd_link_cast_o = cmd_concentrated_link_lo;</pre>
<pre>  bsg_wormhole_concentrator</pre>
<pre>   #(.flit_width_p(coh_noc_flit_width_p)</pre>
<pre>     ,.len_width_p(coh_noc_len_width_p)</pre>
<pre>     ,.cid_width_p(coh_noc_cid_width_p)</pre>
<pre>     ,.num_in_p(3)</pre>
<pre>     ,.cord_width_p(coh_noc_cord_width_p)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">    (.clk_i(clk_i)</pre>
<pre>     ,.reset_i(reset_r)</pre>
<pre></pre>
<pre>     ,.links_o({cce_lce_cmd_link_li, lce_cmd_link_li})</pre>
<pre></pre>
<pre>     ,.concentrated_link_o(cmd_concentrated_link_lo)</pre>
<pre>     );</pre>
<pre>  assign lce_resp_link_cast_o = '{data          : resp_concentrated_link_lo.data</pre>
<pre>                                  ,v            : resp_concentrated_link_lo.v</pre>
<pre>                                  ,ready_and_rev: cce_lce_resp_link_lo.ready_and_rev</pre>
<pre>                                  };</pre>
<pre style="background-color: #FF0000;">  bsg_wormhole_concentrator_in</pre>
<pre>   #(.flit_width_p(coh_noc_flit_width_p)</pre>
<pre>     ,.len_width_p(coh_noc_len_width_p)</pre>
<pre>     ,.cid_width_p(coh_noc_cid_width_p)</pre>
<pre>     ,.num_in_p(2)</pre>
<pre>     ,.cord_width_p(coh_noc_cord_width_p)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">    (.clk_i(clk_i)</pre>
<pre>     ,.reset_i(reset_r)</pre>
<pre></pre>
<pre>     ,.links_o(lce_resp_link_li)</pre>
<pre></pre>
<pre>     ,.concentrated_link_o(resp_concentrated_link_lo)</pre>
<pre>     );</pre>
<pre> #(.cfg_p(cfg_p))</pre>
<pre> master_link</pre>
<pre style="background-color: #FF0000;">  (.clk_i(clk_i)</pre>
<pre>   ,.reset_i(reset_r)</pre>
<pre></pre>
<pre>   ,.mem_cmd_v_i(mem_cmd_v_lo)</pre>
<pre>   ,.mem_cmd_ready_o(mem_cmd_ready_li)</pre>
<pre></pre>
<pre>   ,.mem_resp_v_o(mem_resp_v_li)</pre>
<pre>   ,.mem_resp_yumi_i(mem_resp_ready_lo & mem_resp_v_li)</pre>
<pre></pre>
<pre>   ,.my_cid_i(my_cid_i)</pre>
<pre>   ,.dram_cord_i(dram_cord_i)</pre>
<pre>   ,.mmio_cord_i(mmio_cord_i)</pre>
<pre>   ,.host_cord_i(host_cord_i)</pre>
<pre></pre>
<pre>   ,.cmd_link_o(cmd_link_o)</pre>
<pre></pre>
<pre>   ,.resp_link_o(resp_link_o)</pre>
<pre>   );</pre>
<h3>./bp_top/src/v/bp_mmio_node.v</h3>
<pre>module bp_mmio_node</pre>
<pre> import bsg_noc_pkg::*;</pre>
<pre style="background-color: #FF0000;"> import bsg_wormhole_router_pkg::*;</pre>
<pre> import bp_me_pkg::*;</pre>
<pre>   `declare_bp_proc_params(cfg_p)</pre>
<pre>   `declare_bp_me_if_widths(paddr_width_p, cce_block_width_p, num_lce_p, lce_assoc_p)</pre>
<pre>   , localparam mem_noc_ral_link_width_lp = `bsg_ready_and_link_sif_width(mem_noc_flit_width_p)</pre>
<pre>   )</pre>
<pre>  (input                                           core_clk_i</pre>
<pre>   , input                                         core_reset_i</pre>
<pre></pre>
<pre>   , input                                         mem_reset_i</pre>
<pre></pre>
<pre>   , input [mem_noc_cid_width_p-1:0]               my_cid_i</pre>
<pre></pre>
<pre>   , output [num_core_p-1:0][cfg_addr_width_p-1:0] cfg_addr_o</pre>
<pre>   , output [num_core_p-1:0][cfg_data_width_p-1:0] cfg_data_o</pre>
<pre></pre>
<pre>   , output [num_core_p-1:0]                       timer_irq_o</pre>
<pre>   , output [num_core_p-1:0]                       external_irq_o</pre>
<pre></pre>
<pre>   , output [S:W][mem_noc_ral_link_width_lp-1:0]   mem_cmd_link_o</pre>
<pre></pre>
<pre>   , output [S:W][mem_noc_ral_link_width_lp-1:0]   mem_resp_link_o</pre>
<pre>   );</pre>
<pre style="background-color: #FF0000;">`declare_bsg_ready_and_link_sif_s(mem_noc_flit_width_p, mem_noc_ral_link_s);</pre>
<pre>mem_noc_ral_link_s mmio_resp_link_li, mmio_resp_link_lo;</pre>
<pre></pre>
<pre>   #(.cfg_p(cfg_p))</pre>
<pre>   mmio</pre>
<pre>    (.clk_i(core_clk_i)</pre>
<pre>     ,.reset_i(core_reset_i)</pre>
<pre>  </pre>
<pre>     ,.my_cid_i(my_cid_i)</pre>
<pre>  </pre>
<pre>     ,.cfg_addr_o(cfg_addr_o)</pre>
<pre>     ,.cfg_data_o(cfg_data_o)</pre>
<pre>  </pre>
<pre>     ,.timer_irq_o(timer_irq_o)</pre>
<pre>     ,.external_irq_o(external_irq_o)</pre>
<pre>  </pre>
<pre>     ,.cmd_link_o(mmio_cmd_link_lo)</pre>
<pre>  </pre>
<pre>     ,.resp_link_o(mmio_resp_link_lo)</pre>
<pre>     );</pre>
<pre>mem_noc_ral_link_s mem_resp_link_li, mem_resp_link_lo;</pre>
<pre></pre>
<pre>if (async_mem_clk_p == 1)</pre>
<pre style="background-color: #FF0000;">  begin : async_mem</pre>
<pre style="background-color: #FF0000;">    logic mmio_cmd_full_lo;</pre>
<pre>    assign mmio_cmd_link_li.ready_and_rev = ~mmio_cmd_full_lo;</pre>
<pre>    wire mmio_cmd_enq_li = mmio_cmd_link_lo.v & mmio_cmd_link_li.ready_and_rev;</pre>
<pre>    wire mem_cmd_deq_li = mem_cmd_link_lo.v & mem_cmd_link_li.ready_and_rev;</pre>
<pre style="background-color: #FF0000;">    bsg_async_fifo</pre>
<pre style="background-color: #FF0000;">     #(.lg_size_p(3)</pre>
<pre>       ,.width_p(mem_noc_flit_width_p)</pre>
<pre style="background-color: #FF0000;">       )</pre>
<pre>     mem_cmd_link_async_fifo_to_rtr</pre>
<pre>      (.w_clk_i(core_clk_i)</pre>
<pre>       ,.w_reset_i(core_reset_i)</pre>
<pre style="background-color: #FF0000;">       ,.w_enq_i(mmio_cmd_enq_li)</pre>
<pre>       ,.w_data_i(mmio_cmd_link_lo.data)</pre>
<pre>       ,.w_full_o(mmio_cmd_full_lo)</pre>
<pre></pre>
<pre>       ,.r_reset_i(mem_reset_i)</pre>
<pre>       ,.r_deq_i(mem_cmd_deq_li)</pre>
<pre>       ,.r_data_o(mem_cmd_link_lo.data)</pre>
<pre>       ,.r_valid_o(mem_cmd_link_lo.v)</pre>
<pre>       );</pre>
<pre></pre>
<pre>    logic mmio_resp_full_lo;</pre>
<pre>    assign mmio_resp_link_li.ready_and_rev = ~mmio_resp_full_lo;</pre>
<pre>    wire mmio_resp_enq_li = mmio_resp_link_lo.v & mmio_resp_link_li.ready_and_rev;</pre>
<pre style="background-color: #FF0000;">    wire mem_resp_deq_li = mem_resp_link_lo.v & mem_resp_link_li.ready_and_rev;</pre>
<pre>    bsg_async_fifo</pre>
<pre>     #(.lg_size_p(3)</pre>
<pre style="background-color: #FF0000;">       ,.width_p(mem_noc_flit_width_p)</pre>
<pre>       )</pre>
<pre>     mem_resp_link_async_fifo_to_rtr</pre>
<pre>      (.w_clk_i(core_clk_i)</pre>
<pre>       ,.w_reset_i(core_reset_i)</pre>
<pre style="background-color: #FF0000;">       ,.w_enq_i(mmio_resp_enq_li)</pre>
<pre>       ,.w_data_i(mmio_resp_link_lo.data)</pre>
<pre>       ,.w_full_o(mmio_resp_full_lo)</pre>
<pre style="background-color: #FF0000;">    </pre>
<pre>       ,.r_clk_i(mem_clk_i)</pre>
<pre>       ,.r_reset_i(mem_reset_i)</pre>
<pre>       ,.r_deq_i(mem_resp_deq_li)</pre>
<pre>       ,.r_data_o(mem_resp_link_lo.data)</pre>
<pre>       ,.r_valid_o(mem_resp_link_lo.v)</pre>
<pre>       );</pre>
<pre>    </pre>
<pre>    logic mem_cmd_full_lo;</pre>
<pre>    assign mem_cmd_link_lo.ready_and_rev = ~mem_cmd_full_lo;</pre>
<pre>    wire mem_cmd_enq_li = mem_cmd_link_li.v & mem_cmd_link_lo.ready_and_rev;</pre>
<pre>    wire mmio_cmd_deq_li = mmio_cmd_link_li.v & mmio_cmd_link_lo.ready_and_rev;</pre>
<pre>    bsg_async_fifo</pre>
<pre style="background-color: #FF0000;">     #(.lg_size_p(3)</pre>
<pre style="background-color: #FF0000;">       ,.width_p(mem_noc_flit_width_p)</pre>
<pre>       )</pre>
<pre>     mem_cmd_link_async_fifo_from_rtr</pre>
<pre>      (.w_clk_i(mem_clk_i)</pre>
<pre style="background-color: #FF0000;">       ,.w_reset_i(mem_reset_i)</pre>
<pre>       ,.w_enq_i(mem_cmd_enq_li)</pre>
<pre>       ,.w_data_i(mem_cmd_link_li.data)</pre>
<pre>       ,.w_full_o(mem_cmd_full_lo)</pre>
<pre>    </pre>
<pre>       ,.r_clk_i(core_clk_i)</pre>
<pre>       ,.r_reset_i(core_reset_i)</pre>
<pre>       ,.r_deq_i(mmio_cmd_deq_li)</pre>
<pre>       ,.r_data_o(mmio_cmd_link_li.data)</pre>
<pre>       ,.r_valid_o(mmio_cmd_link_li.v)</pre>
<pre>       );</pre>
<pre></pre>
<pre>    logic mem_resp_full_lo;</pre>
<pre>    assign mem_resp_link_lo.ready_and_rev = ~mem_resp_full_lo;</pre>
<pre>    wire mem_resp_enq_li = mem_resp_link_li.v & mem_resp_link_lo.ready_and_rev;</pre>
<pre style="background-color: #FF0000;">    wire mmio_resp_deq_li = mmio_resp_link_li.v & mmio_resp_link_lo.ready_and_rev;</pre>
<pre style="background-color: #FF0000;">    bsg_async_fifo</pre>
<pre>     #(.lg_size_p(3)</pre>
<pre>       ,.width_p(mem_noc_flit_width_p)</pre>
<pre style="background-color: #FF0000;">       )</pre>
<pre>     mem_resp_link_async_fifo_from_rtr</pre>
<pre>      (.w_clk_i(mem_clk_i)</pre>
<pre>       ,.w_reset_i(mem_reset_i)</pre>
<pre>       ,.w_enq_i(mem_resp_enq_li)</pre>
<pre style="background-color: #FF0000;">       ,.w_data_i(mem_resp_link_li.data)</pre>
<pre>       ,.w_full_o(mem_resp_full_lo)</pre>
<pre style="background-color: #FF0000;">    </pre>
<pre style="background-color: #FF0000;">       ,.r_reset_i(core_reset_i)</pre>
<pre style="background-color: #FF0000;">       ,.r_deq_i(mmio_resp_deq_li)</pre>
<pre style="background-color: #FF0000;">       ,.r_data_o(mmio_resp_link_li.data)</pre>
<pre style="background-color: #FF0000;">       ,.r_valid_o(mmio_resp_link_li.v)</pre>
<pre>       );</pre>
<pre>      assign mem_cmd_link_lo  = mmio_cmd_link_lo;</pre>
<pre>      assign mem_resp_link_lo = mmio_resp_link_lo;</pre>
<pre></pre>
<pre>      assign mmio_resp_link_li = mem_resp_link_li;</pre>
<pre>    end</pre>
<pre>   #(.flit_width_p(mem_noc_flit_width_p)</pre>
<pre>     ,.dims_p(mem_noc_dims_p)</pre>
<pre>     ,.cord_markers_pos_p(mem_noc_cord_markers_pos_p)</pre>
<pre>     ,.len_width_p(mem_noc_len_width_p)</pre>
<pre>     ,.reverse_order_p(0)</pre>
<pre>     ,.routing_matrix_p(StrictXY | XY_Allow_S)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">   (.clk_i(mem_clk_i)</pre>
<pre>    ,.reset_i(mem_reset_i)</pre>
<pre>    ,.my_cord_i(my_cord_i)</pre>
<pre>    ,.link_i({mem_cmd_link_i, mem_cmd_link_lo})</pre>
<pre>    ,.link_o({mem_cmd_link_o, mem_cmd_link_li})</pre>
<pre>    );</pre>
<pre>   #(.flit_width_p(mem_noc_flit_width_p)</pre>
<pre>     ,.dims_p(mem_noc_dims_p)</pre>
<pre>     ,.cord_markers_pos_p(mem_noc_cord_markers_pos_p)</pre>
<pre>     ,.len_width_p(mem_noc_len_width_p)</pre>
<pre>     ,.reverse_order_p(0)</pre>
<pre>     ,.routing_matrix_p(StrictXY | XY_Allow_S)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">    (.clk_i(mem_clk_i)</pre>
<pre>     ,.reset_i(mem_reset_i)</pre>
<pre>     ,.my_cord_i(my_cord_i)</pre>
<pre>     ,.link_i({mem_resp_link_i, mem_resp_link_lo})</pre>
<pre>     ,.link_o({mem_resp_link_o, mem_resp_link_li})</pre>
<pre>     );</pre>
<h3>./bp_top/src/v/bp_core_complex.v</h3>
<pre></pre>
<pre>module bp_core_complex</pre>
<pre> import bp_common_pkg::*;</pre>
<pre> import bsg_noc_pkg::*;</pre>
<pre> import bsg_wormhole_router_pkg::*;</pre>
<pre> import bp_cfg_link_pkg::*;</pre>
<pre> import bp_me_pkg::*;</pre>
<pre>   `declare_bp_proc_params(cfg_p)</pre>
<pre>   , localparam coh_noc_ral_link_width_lp = `bsg_ready_and_link_sif_width(coh_noc_flit_width_p)</pre>
<pre>   )</pre>
<pre>   , input                                                         core_reset_i</pre>
<pre></pre>
<pre>   , input                                                         coh_clk_i</pre>
<pre>   , input                                                         coh_reset_i</pre>
<pre></pre>
<pre>   , input                                                         mem_reset_i</pre>
<pre></pre>
<pre>   , input [mem_noc_cord_width_p-1:0]                              dram_cord_i</pre>
<pre>   , input [mem_noc_cord_width_p-1:0]                              mmio_cord_i</pre>
<pre>   , input [mem_noc_cord_width_p-1:0]                              host_cord_i</pre>
<pre></pre>
<pre>   , input [num_core_p-1:0][cfg_addr_width_p-1:0]                  cfg_addr_i</pre>
<pre>   , input [num_core_p-1:0][cfg_data_width_p-1:0]                  cfg_data_i</pre>
<pre></pre>
<pre>   , input [num_core_p-1:0]                                        soft_irq_i</pre>
<pre>   , input [num_core_p-1:0]                                        external_irq_i</pre>
<pre></pre>
<pre>   , output [mem_noc_x_dim_p-1:0][mem_noc_ral_link_width_lp-1:0]   mem_cmd_link_o</pre>
<pre></pre>
<pre>   , output [mem_noc_x_dim_p-1:0][mem_noc_ral_link_width_lp-1:0]   mem_resp_link_o</pre>
<pre>   );</pre>
<pre style="background-color: #FF0000;">`declare_bp_common_proc_cfg_s(num_core_p, num_cce_p, num_lce_p)</pre>
<pre style="background-color: #FF0000;">`declare_bsg_ready_and_link_sif_s(coh_noc_flit_width_p, coh_noc_ral_link_s);</pre>
<pre style="background-color: #FF0000;">`declare_bsg_ready_and_link_sif_s(mem_noc_flit_width_p, mem_noc_ral_link_s);</pre>
<pre>logic [coh_noc_y_dim_p-1:0][coh_noc_x_dim_p-1:0][cfg_addr_width_p-1:0] cfg_addr_lo;</pre>
<pre>logic [coh_noc_y_dim_p-1:0][coh_noc_x_dim_p-1:0][cfg_data_width_p-1:0] cfg_data_lo;</pre>
<pre></pre>
<pre></pre>
<pre>coh_noc_ral_link_s [coh_noc_y_dim_p-1:0][coh_noc_x_dim_p-1:0][S:W] lce_cmd_link_lo, lce_cmd_link_li;</pre>
<pre>coh_noc_ral_link_s [coh_noc_y_dim_p-1:0][coh_noc_x_dim_p-1:0][S:W] lce_resp_link_lo, lce_resp_link_li;</pre>
<pre></pre>
<pre>mem_noc_ral_link_s [mem_noc_y_dim_p-1:0][mem_noc_x_dim_p-1:0][S:W] mem_resp_link_lo, mem_resp_link_li;</pre>
<pre></pre>
<pre>coh_noc_ral_link_s [S:N][mem_noc_x_dim_p-1:0] lce_req_ver_link_li, lce_req_ver_link_lo;</pre>
<pre>coh_noc_ral_link_s [E:W][mem_noc_y_dim_p-1:0] lce_cmd_hor_link_li, lce_cmd_hor_link_lo;</pre>
<pre>coh_noc_ral_link_s [S:N][mem_noc_x_dim_p-1:0] lce_cmd_ver_link_li, lce_cmd_ver_link_lo;</pre>
<pre>coh_noc_ral_link_s [E:W][mem_noc_y_dim_p-1:0] lce_resp_hor_link_li, lce_resp_hor_link_lo;</pre>
<pre>coh_noc_ral_link_s [S:N][mem_noc_x_dim_p-1:0] lce_resp_ver_link_li, lce_resp_ver_link_lo;</pre>
<pre></pre>
<pre>mem_noc_ral_link_s [S:N][mem_noc_x_dim_p-1:0] mem_cmd_ver_link_li, mem_cmd_ver_link_lo;</pre>
<pre>mem_noc_ral_link_s [E:W][mem_noc_y_dim_p-1:0] mem_resp_hor_link_li, mem_resp_hor_link_lo;</pre>
<pre>mem_noc_ral_link_s [S:N][mem_noc_x_dim_p-1:0] mem_resp_ver_link_li, mem_resp_ver_link_lo;</pre>
<pre></pre>
<pre>for (genvar j = 0; j < mem_noc_y_dim_p; j++)</pre>
<pre>  begin : y</pre>
<pre>    for (genvar i = 0; i < mem_noc_x_dim_p; i++) </pre>
<pre>      begin : x</pre>
<pre>        localparam tile_idx = j*mem_noc_x_dim_p + i;</pre>
<pre></pre>
<pre>        bp_proc_cfg_s proc_cfg;</pre>
<pre>        assign proc_cfg.core_id   = tile_idx;</pre>
<pre>        assign proc_cfg.cce_id    = tile_idx;</pre>
<pre>        assign proc_cfg.icache_id = (tile_idx*2 + 0);</pre>
<pre>        assign proc_cfg.dcache_id = (tile_idx*2 + 1);</pre>
<pre></pre>
<pre>        // TODO: Num stages arbitrarily set, should be based on PD</pre>
<pre>        logic cfg_w_v_li, timer_irq_li, soft_irq_li, external_irq_li;</pre>
<pre>        logic [cfg_addr_width_p-1:0] cfg_addr_li;</pre>
<pre>        logic [cfg_data_width_p-1:0] cfg_data_li;</pre>
<pre>        bsg_dff_chain</pre>
<pre>         #(.width_p(3+1+cfg_addr_width_p+cfg_data_width_p), .num_stages_p(10))</pre>
<pre>         slow_pipe</pre>
<pre>          (.clk_i(core_clk_i)</pre>
<pre>           ,.data_i({cfg_w_v_i[tile_idx]</pre>
<pre>                     ,cfg_addr_i[tile_idx]</pre>
<pre>                     ,cfg_data_i[tile_idx]</pre>
<pre>                     ,timer_irq_i[tile_idx]</pre>
<pre>                     ,soft_irq_i[tile_idx]</pre>
<pre>                     ,external_irq_i[tile_idx]</pre>
<pre>                     })</pre>
<pre>           ,.data_o({cfg_w_v_li</pre>
<pre>                     ,cfg_addr_li</pre>
<pre>                     ,cfg_data_li</pre>
<pre>                     ,timer_irq_li</pre>
<pre>                     ,soft_irq_li</pre>
<pre>                     ,external_irq_li})</pre>
<pre>           );</pre>
<pre>    </pre>
<pre>        bp_tile_node</pre>
<pre>         #(.cfg_p(cfg_p))</pre>
<pre>         tile_node</pre>
<pre>          (.core_clk_i(core_clk_i)</pre>
<pre>           ,.core_reset_i(core_reset_i)</pre>
<pre></pre>
<pre style="background-color: #FF0000;">           ,.coh_clk_i(coh_clk_i)</pre>
<pre>           ,.coh_reset_i(coh_reset_i)</pre>
<pre></pre>
<pre>           ,.mem_clk_i(mem_clk_i)</pre>
<pre>           ,.mem_reset_i(mem_reset_i)</pre>
<pre>    </pre>
<pre>           ,.proc_cfg_i(proc_cfg)</pre>
<pre>    </pre>
<pre>           ,.my_cord_i(tile_cord_i[tile_idx])</pre>
<pre>           ,.my_cid_i(mem_noc_cid_width_p'(0))</pre>
<pre>           ,.dram_cord_i(dram_cord_i)</pre>
<pre>           ,.mmio_cord_i(mmio_cord_i)</pre>
<pre>           ,.host_cord_i(host_cord_i)</pre>
<pre>    </pre>
<pre>           ,.cfg_w_v_i(cfg_w_v_li)</pre>
<pre>           ,.cfg_addr_i(cfg_addr_li)</pre>
<pre>           ,.cfg_data_i(cfg_data_li)</pre>
<pre>    </pre>
<pre>           ,.timer_int_i(timer_irq_li)</pre>
<pre>           ,.software_int_i(soft_irq_li)</pre>
<pre>           ,.external_int_i(external_irq_li)</pre>
<pre></pre>
<pre>           ,.coh_lce_req_link_i(lce_req_link_li[j][i])</pre>
<pre>           ,.coh_lce_resp_link_i(lce_resp_link_li[j][i])</pre>
<pre>           ,.coh_lce_cmd_link_i(lce_cmd_link_li[j][i])</pre>
<pre>    </pre>
<pre>           ,.coh_lce_req_link_o(lce_req_link_lo[j][i])</pre>
<pre>           ,.coh_lce_resp_link_o(lce_resp_link_lo[j][i])</pre>
<pre>           ,.coh_lce_cmd_link_o(lce_cmd_link_lo[j][i])</pre>
<pre>    </pre>
<pre>           ,.mem_cmd_link_i(mem_cmd_link_li[j][i])</pre>
<pre>           ,.mem_resp_link_i(mem_resp_link_li[j][i])</pre>
<pre>    </pre>
<pre>           ,.mem_resp_link_o(mem_resp_link_lo[j][i])</pre>
<pre>           );</pre>
<pre>  assign lce_req_ver_link_li = '0;</pre>
<pre>  bsg_mesh_stitch</pre>
<pre>   #(.width_p($bits(coh_noc_ral_link_s))</pre>
<pre>     ,.x_max_p(coh_noc_x_dim_p)</pre>
<pre>     ,.y_max_p(coh_noc_y_dim_p)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">    (.outs_i(lce_req_link_lo)</pre>
<pre>     ,.ins_o(lce_req_link_li)</pre>
<pre></pre>
<pre>     ,.hor_o(lce_req_hor_link_lo)</pre>
<pre></pre>
<pre>     ,.ver_o(lce_req_ver_link_lo)</pre>
<pre>     );</pre>
<pre>  assign lce_cmd_ver_link_li = '0;</pre>
<pre>  bsg_mesh_stitch</pre>
<pre>   #(.width_p($bits(coh_noc_ral_link_s))</pre>
<pre>     ,.x_max_p(coh_noc_x_dim_p)</pre>
<pre>     ,.y_max_p(coh_noc_y_dim_p)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">    (.outs_i(lce_cmd_link_lo)</pre>
<pre>     ,.ins_o(lce_cmd_link_li)</pre>
<pre></pre>
<pre>     ,.hor_o(lce_cmd_hor_link_lo)</pre>
<pre></pre>
<pre>     ,.ver_o(lce_cmd_ver_link_lo)</pre>
<pre>     );</pre>
<pre>  assign lce_resp_ver_link_li = '0;</pre>
<pre>  bsg_mesh_stitch</pre>
<pre>   #(.width_p($bits(coh_noc_ral_link_s))</pre>
<pre>     ,.x_max_p(coh_noc_x_dim_p)</pre>
<pre>     ,.y_max_p(coh_noc_y_dim_p)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">    (.outs_i(lce_resp_link_lo)</pre>
<pre>     ,.ins_o(lce_resp_link_li)</pre>
<pre></pre>
<pre>     ,.hor_o(lce_resp_hor_link_lo)</pre>
<pre></pre>
<pre>     ,.ver_o(lce_resp_ver_link_lo)</pre>
<pre>     );</pre>
<pre>  assign mem_cmd_ver_link_li[N] = mem_cmd_link_i;</pre>
<pre>  assign mem_cmd_ver_link_li[S] = '0;</pre>
<pre>  bsg_mesh_stitch</pre>
<pre>   #(.width_p($bits(mem_noc_ral_link_s))</pre>
<pre>     ,.x_max_p(mem_noc_x_dim_p)</pre>
<pre>     ,.y_max_p(mem_noc_y_dim_p)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">    (.outs_i(mem_cmd_link_lo)</pre>
<pre>     ,.ins_o(mem_cmd_link_li)</pre>
<pre></pre>
<pre>     ,.hor_o(mem_cmd_hor_link_lo)</pre>
<pre></pre>
<pre>     ,.ver_o(mem_cmd_ver_link_lo)</pre>
<pre>     );</pre>
<pre></pre>
<pre>  assign mem_resp_ver_link_li[N] = mem_resp_link_i;</pre>
<pre>  assign mem_resp_ver_link_li[S] = '0;</pre>
<pre>  bsg_mesh_stitch</pre>
<pre>   #(.width_p($bits(mem_noc_ral_link_s))</pre>
<pre>     ,.x_max_p(mem_noc_x_dim_p)</pre>
<pre>     ,.y_max_p(mem_noc_y_dim_p)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">    (.outs_i(mem_resp_link_lo)</pre>
<pre>     ,.ins_o(mem_resp_link_li)</pre>
<pre></pre>
<pre>     ,.hor_o(mem_resp_hor_link_lo)</pre>
<pre></pre>
<pre>     ,.ver_o(mem_resp_ver_link_lo)</pre>
<pre>     );</pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./bp_top/src/v/bp_core.v</h3>
<pre> *  icache is connected to 0.</pre>
<pre style="background-color: #FF0000;"> *  dcache is connected to 1.</pre>
<pre style="background-color: #FF0000;"> */</pre>
<pre></pre>
<pre>module bp_core</pre>
<pre> import bp_common_pkg::*;</pre>
<pre> import bp_common_aviary_pkg::*;</pre>
<pre> import bp_be_pkg::*;</pre>
<pre> import bp_common_rv64_pkg::*;</pre>
<pre> import bp_cfg_link_pkg::*;</pre>
<pre>  #(parameter bp_cfg_e cfg_p = e_bp_inv_cfg</pre>
<pre>    `declare_bp_proc_params(cfg_p)</pre>
<pre>    `declare_bp_fe_be_if_widths(vaddr_width_p</pre>
<pre>                                ,paddr_width_p</pre>
<pre>                                ,asid_width_p</pre>
<pre>                                ,branch_metadata_fwd_width_p</pre>
<pre>                                )</pre>
<pre>    `declare_bp_lce_cce_if_widths(num_cce_p</pre>
<pre>                                  ,num_lce_p</pre>
<pre>                                  ,paddr_width_p</pre>
<pre>                                  ,lce_assoc_p</pre>
<pre>                                  ,dword_width_p</pre>
<pre>                                  ,cce_block_width_p</pre>
<pre></pre>
<pre>    // Should go away with manycore bridge </pre>
<pre>    , localparam proc_cfg_width_lp = `bp_proc_cfg_width(num_core_p, num_cce_p, num_lce_p)</pre>
<pre>    )</pre>
<pre>   (</pre>
<pre>    input                                          clk_i</pre>
<pre>    , input                                        reset_i</pre>
<pre>    , input                                        freeze_i</pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;">    // Config channel</pre>
<pre>    , input [cfg_addr_width_p-1:0]                 cfg_addr_i</pre>
<pre>    , input [cfg_data_width_p-1:0]                 cfg_data_i</pre>
<pre></pre>
<pre>    , output [1:0][lce_cce_req_width_lp-1:0]       lce_req_o</pre>
<pre>    , output [1:0]                                 lce_req_v_o</pre>
<pre>    , input [1:0]                                  lce_req_ready_i</pre>
<pre></pre>
<pre style="background-color: #FF0000;">    , output [1:0][lce_cce_resp_width_lp-1:0]      lce_resp_o</pre>
<pre>    , output [1:0]                                 lce_resp_v_o</pre>
<pre>    , input [1:0]                                  lce_resp_ready_i</pre>
<pre></pre>
<pre>    // CCE-LCE interface</pre>
<pre style="background-color: #FF0000;">    , input [1:0][lce_cmd_width_lp-1:0]            lce_cmd_i</pre>
<pre>    , input [1:0]                                  lce_cmd_v_i</pre>
<pre>    , output [1:0]                                 lce_cmd_ready_o</pre>
<pre></pre>
<pre style="background-color: #FF0000;">    , output [1:0][lce_cmd_width_lp-1:0]           lce_cmd_o</pre>
<pre>    , output [1:0]                                 lce_cmd_v_o</pre>
<pre>    , input [1:0]                                  lce_cmd_ready_i</pre>
<pre></pre>
<pre style="background-color: #FF0000;">    , input                                        timer_int_i</pre>
<pre>    , input                                        software_int_i</pre>
<pre>    , input                                        external_int_i</pre>
<pre>    );</pre>
<pre></pre>
<pre style="background-color: #FF0000;">  `declare_bp_common_proc_cfg_s(num_core_p, num_cce_p, num_lce_p)</pre>
<pre style="background-color: #FF0000;">  `declare_bp_fe_be_if(vaddr_width_p, paddr_width_p, asid_width_p, branch_metadata_fwd_width_p);</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">  bp_proc_cfg_s proc_cfg_cast_i;</pre>
<pre>  assign proc_cfg_cast_i = proc_cfg_i;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">  bp_fe_queue_s fe_queue_li, fe_queue_lo;</pre>
<pre>  logic fe_queue_v_li, fe_queue_ready_lo;</pre>
<pre>  logic fe_queue_v_lo, fe_queue_yumi_li;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">  bp_fe_cmd_s fe_cmd_li, fe_cmd_lo;</pre>
<pre>  logic fe_cmd_v_li, fe_cmd_ready_lo;</pre>
<pre>  logic fe_cmd_v_lo, fe_cmd_yumi_li;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">  logic fe_cmd_processed_li;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">  bp_fe_top</pre>
<pre>   #(.cfg_p(cfg_p))</pre>
<pre>   fe </pre>
<pre style="background-color: #FF0000;">    (.clk_i(clk_i)</pre>
<pre>     ,.reset_i(reset_i)</pre>
<pre>     ,.freeze_i(freeze_i)</pre>
<pre></pre>
<pre>     ,.lce_id_i(proc_cfg_cast_i.icache_id)</pre>
<pre></pre>
<pre>     ,.cfg_w_v_i(cfg_w_v_i)</pre>
<pre>     ,.cfg_addr_i(cfg_addr_i)</pre>
<pre>     ,.cfg_data_i(cfg_data_i)</pre>
<pre></pre>
<pre>     ,.fe_queue_o(fe_queue_li)</pre>
<pre>     ,.fe_queue_v_o(fe_queue_v_li)</pre>
<pre>     ,.fe_queue_ready_i(fe_queue_ready_lo)</pre>
<pre></pre>
<pre>     ,.fe_cmd_i(fe_cmd_lo)</pre>
<pre>     ,.fe_cmd_v_i(fe_cmd_v_lo)</pre>
<pre>     ,.fe_cmd_yumi_o(fe_cmd_yumi_li)</pre>
<pre>     ,.fe_cmd_processed_o(fe_cmd_processed_li)</pre>
<pre></pre>
<pre>     ,.lce_req_o(lce_req_o[0])</pre>
<pre>     ,.lce_req_v_o(lce_req_v_o[0])</pre>
<pre>     ,.lce_req_ready_i(lce_req_ready_i[0])</pre>
<pre></pre>
<pre>     ,.lce_resp_o(lce_resp_o[0])</pre>
<pre>     ,.lce_resp_v_o(lce_resp_v_o[0])</pre>
<pre>     ,.lce_resp_ready_i(lce_resp_ready_i[0])</pre>
<pre></pre>
<pre style="background-color: #FF0000;">     ,.lce_cmd_i(lce_cmd_i[0])</pre>
<pre>     ,.lce_cmd_v_i(lce_cmd_v_i[0])</pre>
<pre>     ,.lce_cmd_ready_o(lce_cmd_ready_o[0])</pre>
<pre></pre>
<pre>     ,.lce_cmd_o(lce_cmd_o[0])</pre>
<pre>     ,.lce_cmd_v_o(lce_cmd_v_o[0])</pre>
<pre>     ,.lce_cmd_ready_i(lce_cmd_ready_i[0])</pre>
<pre>     );</pre>
<pre></pre>
<pre>  logic fe_fence_r;</pre>
<pre>  wire fe_cmd_nonattaboy_v_li = fe_cmd_v_li & (fe_cmd_li.opcode != e_op_attaboy);</pre>
<pre>  bsg_fifo_1r1w_fence</pre>
<pre>   #(.width_p(fe_cmd_width_lp)</pre>
<pre>     ,.els_p(fe_cmd_fifo_els_p)</pre>
<pre>     ,.ready_THEN_valid_p(1)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">   fe_cmd_fifo</pre>
<pre style="background-color: #FF0000;">    (.clk_i(clk_i)</pre>
<pre>     ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>     ,.fence_set_i(fe_cmd_nonattaboy_v_li)</pre>
<pre>     ,.fence_clr_i(fe_cmd_processed_li)</pre>
<pre>     ,.fence_o(fe_fence_r)</pre>
<pre>      </pre>
<pre>     ,.data_i(fe_cmd_li)</pre>
<pre>     ,.v_i(fe_cmd_v_li)</pre>
<pre>     ,.ready_o(fe_cmd_ready_lo)</pre>
<pre>                  </pre>
<pre>     ,.data_o(fe_cmd_lo)</pre>
<pre>     ,.v_o(fe_cmd_v_lo)</pre>
<pre>     ,.yumi_i(fe_cmd_yumi_li)</pre>
<pre>     );</pre>
<pre></pre>
<pre>  logic fe_queue_deq_li, fe_queue_roll_li;</pre>
<pre>  wire fe_queue_clr_li = fe_fence_r & fe_cmd_processed_li;</pre>
<pre>  bsg_fifo_1r1w_rolly </pre>
<pre>   #(.width_p(fe_queue_width_lp)</pre>
<pre>     ,.els_p(fe_queue_fifo_els_p)</pre>
<pre>     ,.ready_THEN_valid_p(1)</pre>
<pre>     )</pre>
<pre>   fe_queue_fifo</pre>
<pre>    (.clk_i(clk_i)</pre>
<pre>     ,.reset_i(reset_i)</pre>
<pre></pre>
<pre>     ,.clr_v_i(fe_queue_clr_li)</pre>
<pre>     ,.deq_v_i(fe_queue_deq_li)</pre>
<pre>     ,.roll_v_i(fe_queue_roll_li)</pre>
<pre></pre>
<pre>     ,.v_i(fe_queue_v_li)</pre>
<pre>     ,.ready_o(fe_queue_ready_lo)</pre>
<pre></pre>
<pre>     ,.data_o(fe_queue_lo)</pre>
<pre>     ,.v_o(fe_queue_v_lo)</pre>
<pre>     ,.yumi_i(fe_queue_yumi_li)</pre>
<pre>     );</pre>
<pre></pre>
<pre>  bp_be_top </pre>
<pre>   #(.cfg_p(cfg_p))</pre>
<pre>   be</pre>
<pre style="background-color: #FF0000;">    (.clk_i(clk_i)</pre>
<pre>     ,.reset_i(reset_i)</pre>
<pre>     ,.freeze_i(freeze_i)</pre>
<pre>     </pre>
<pre></pre>
<pre>     ,.cfg_addr_i(cfg_addr_i)</pre>
<pre>     ,.cfg_data_i(cfg_data_i)</pre>
<pre></pre>
<pre>     ,.fe_queue_roll_o(fe_queue_roll_li)</pre>
<pre></pre>
<pre>     ,.fe_queue_v_i(~fe_fence_r & fe_queue_v_lo)</pre>
<pre>     ,.fe_queue_yumi_o(fe_queue_yumi_li)</pre>
<pre></pre>
<pre>     ,.fe_cmd_v_o(fe_cmd_v_li)</pre>
<pre>     ,.fe_cmd_ready_i(~fe_fence_r & fe_cmd_ready_lo)</pre>
<pre></pre>
<pre>     ,.lce_req_v_o(lce_req_v_o[1])</pre>
<pre>     ,.lce_req_ready_i(lce_req_ready_i[1])</pre>
<pre></pre>
<pre>     ,.lce_resp_v_o(lce_resp_v_o[1])</pre>
<pre>     ,.lce_resp_ready_i(lce_resp_ready_i[1])</pre>
<pre></pre>
<pre>     ,.lce_cmd_v_i(lce_cmd_v_i[1])</pre>
<pre>     ,.lce_cmd_ready_o(lce_cmd_ready_o[1])</pre>
<pre></pre>
<pre>     ,.lce_cmd_v_o(lce_cmd_v_o[1])</pre>
<pre>     ,.lce_cmd_ready_i(lce_cmd_ready_i[1])</pre>
<pre></pre>
<pre>     ,.software_int_i(software_int_i)</pre>
<pre>     ,.external_int_i(external_int_i)</pre>
<pre>     );</pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<h3>./bp_top/src/v/bp_mem_complex.v</h3>
<pre>module bp_mem_complex</pre>
<pre> import bsg_wormhole_router_pkg::*;</pre>
<pre style="background-color: #FF0000;"> #(parameter bp_cfg_e cfg_p = e_bp_inv_cfg</pre>
<pre>   `declare_bp_proc_params(cfg_p)</pre>
<pre>   )</pre>
<pre>  (input                                                               core_clk_i</pre>
<pre>   , input                                                             core_reset_i</pre>
<pre></pre>
<pre>   , input                                                             mem_clk_i</pre>
<pre>   , input                                                             mem_reset_i</pre>
<pre></pre>
<pre></pre>
<pre>   , output [num_core_p-1:0][cfg_addr_width_p-1:0]                     cfg_addr_o</pre>
<pre>   , output [num_core_p-1:0][cfg_data_width_p-1:0]                     cfg_data_o</pre>
<pre></pre>
<pre>   , output [num_core_p-1:0]                                           timer_irq_o</pre>
<pre>   , output [num_core_p-1:0]                                           external_irq_o</pre>
<pre></pre>
<pre>   , output [mem_noc_x_dim_p-1:0][bsg_ready_and_link_sif_width_lp-1:0] mem_cmd_link_o</pre>
<pre></pre>
<pre>   , output [mem_noc_x_dim_p-1:0][bsg_ready_and_link_sif_width_lp-1:0] mem_resp_link_o</pre>
<pre></pre>
<pre>   , output [bsg_ready_and_link_sif_width_lp-1:0]                      prev_cmd_link_o</pre>
<pre></pre>
<pre>   , output [bsg_ready_and_link_sif_width_lp-1:0]                      prev_resp_link_o</pre>
<pre></pre>
<pre>   , output [bsg_ready_and_link_sif_width_lp-1:0]                      next_cmd_link_o</pre>
<pre></pre>
<pre>   , output [bsg_ready_and_link_sif_width_lp-1:0]                      next_resp_link_o</pre>
<pre>   );</pre>
<pre>`declare_bsg_ready_and_link_sif_s(mem_noc_flit_width_p, bsg_ready_and_link_sif_s);</pre>
<pre>bsg_ready_and_link_sif_s [S:N][num_mem_p-1:0] cmd_ver_link_li, cmd_ver_link_lo, resp_ver_link_li, resp_ver_link_lo;</pre>
<pre>bsg_ready_and_link_sif_s [E:W]                cmd_hor_link_li, cmd_hor_link_lo, resp_hor_link_li, resp_hor_link_lo;</pre>
<pre></pre>
<pre>  begin : node</pre>
<pre>    if (i == mmio_x_pos_p)</pre>
<pre>      begin : mmio</pre>
<pre>        bp_mmio_node</pre>
<pre>         #(.cfg_p(cfg_p))</pre>
<pre>         mmio</pre>
<pre style="background-color: #FF0000;">          (.core_clk_i(core_clk_i)</pre>
<pre>           ,.core_reset_i(core_reset_i)</pre>
<pre></pre>
<pre>           ,.mem_reset_i(mem_reset_i)</pre>
<pre></pre>
<pre>           ,.my_cid_i('0)</pre>
<pre></pre>
<pre>           ,.cfg_addr_o(cfg_addr_o)</pre>
<pre>           ,.cfg_data_o(cfg_data_o)</pre>
<pre></pre>
<pre>           ,.timer_irq_o(timer_irq_o)</pre>
<pre>           ,.external_irq_o(external_irq_o)</pre>
<pre></pre>
<pre>           ,.mem_cmd_link_o(cmd_link_lo[i])</pre>
<pre></pre>
<pre>           ,.mem_resp_link_o(resp_link_lo[i])</pre>
<pre>           );</pre>
<pre>        bsg_ready_and_link_sif_s rtr_cmd_link_li, rtr_cmd_link_lo;</pre>
<pre>        bsg_ready_and_link_sif_s rtr_resp_link_li, rtr_resp_link_lo;</pre>
<pre></pre>
<pre>        bsg_wormhole_router</pre>
<pre>         #(.flit_width_p(mem_noc_flit_width_p)</pre>
<pre>           ,.dims_p(mem_noc_dims_p)</pre>
<pre>           ,.cord_dims_p(mem_noc_dims_p)</pre>
<pre>           ,.cord_markers_pos_p(mem_noc_cord_markers_pos_p)</pre>
<pre>           ,.len_width_p(mem_noc_len_width_p)</pre>
<pre>           ,.reverse_order_p(0)</pre>
<pre>           ,.routing_matrix_p(StrictXY | XY_Allow_S)</pre>
<pre>           )</pre>
<pre>         (.clk_i(mem_clk_i)</pre>
<pre>          ,.reset_i(mem_reset_i)</pre>
<pre>          ,.my_cord_i(mem_cord_i[i])</pre>
<pre>          ,.link_i({cmd_link_li[i], rtr_cmd_link_li})</pre>
<pre>          ,.link_o({cmd_link_lo[i], rtr_cmd_link_lo})</pre>
<pre>          );</pre>
<pre>        </pre>
<pre style="background-color: #FF0000;">        assign rtr_resp_link_li = '0;</pre>
<pre>        bsg_wormhole_router</pre>
<pre>         #(.flit_width_p(mem_noc_flit_width_p)</pre>
<pre>           ,.dims_p(mem_noc_dims_p)</pre>
<pre>           ,.cord_dims_p(mem_noc_dims_p)</pre>
<pre>           ,.cord_markers_pos_p(mem_noc_cord_markers_pos_p)</pre>
<pre>           ,.len_width_p(mem_noc_len_width_p)</pre>
<pre>           ,.reverse_order_p(0)</pre>
<pre>           ,.routing_matrix_p(StrictXY | XY_Allow_S)</pre>
<pre>           )</pre>
<pre>         resp_router </pre>
<pre>          (.clk_i(mem_clk_i)</pre>
<pre>           ,.reset_i(mem_reset_i)</pre>
<pre>           ,.my_cord_i(mem_cord_i[i])</pre>
<pre>           ,.link_i({resp_link_li[i], rtr_resp_link_li})</pre>
<pre>           ,.link_o({resp_link_lo[i], rtr_resp_link_lo})</pre>
<pre>           );</pre>
<pre>  assign cmd_ver_link_li[N] = '0;</pre>
<pre>  assign cmd_ver_link_li[S] = {bsg_ready_and_link_sif_width_lp'('0), mem_cmd_link_i, bsg_ready_and_link_sif_width_lp'('0)};</pre>
<pre>  assign cmd_hor_link_li[W] = prev_cmd_link_i;</pre>
<pre>  assign cmd_hor_link_li[E] = next_cmd_link_i;</pre>
<pre>  bsg_mesh_stitch</pre>
<pre>   #(.width_p(bsg_ready_and_link_sif_width_lp)</pre>
<pre>     ,.x_max_p(num_mem_p)</pre>
<pre>     ,.y_max_p(1)</pre>
<pre>     )</pre>
<pre>   cmd_mesh</pre>
<pre>    (.outs_i(cmd_link_lo)</pre>
<pre>     ,.ins_o(cmd_link_li)</pre>
<pre></pre>
<pre>     ,.hor_i(cmd_hor_link_li)</pre>
<pre>     ,.hor_o(cmd_hor_link_lo)</pre>
<pre>     ,.ver_i(cmd_ver_link_li)</pre>
<pre>     ,.ver_o(cmd_ver_link_lo)</pre>
<pre>     );</pre>
<pre>  assign mem_cmd_link_o  = cmd_ver_link_lo[S][num_mem_p-1:1];</pre>
<pre>  assign prev_cmd_link_o = cmd_hor_link_lo[W];</pre>
<pre>  assign next_cmd_link_o = cmd_hor_link_lo[E];</pre>
<pre></pre>
<pre>  assign resp_ver_link_li[N] = '0;</pre>
<pre>  assign resp_ver_link_li[S] = {bsg_ready_and_link_sif_width_lp'('0), mem_resp_link_i, bsg_ready_and_link_sif_width_lp'('0)};</pre>
<pre>  assign resp_hor_link_li[W] = prev_resp_link_i;</pre>
<pre>  assign resp_hor_link_li[E] = next_resp_link_i;</pre>
<pre>  bsg_mesh_stitch</pre>
<pre>   #(.width_p(bsg_ready_and_link_sif_width_lp)</pre>
<pre>     ,.x_max_p(num_mem_p)</pre>
<pre>     ,.y_max_p(1)</pre>
<pre>     )</pre>
<pre style="background-color: #FF0000;">    (.outs_i(resp_link_lo)</pre>
<pre>     ,.ins_o(resp_link_li)</pre>
<pre></pre>
<pre>     ,.hor_o(resp_hor_link_lo)</pre>
<pre>     ,.ver_i(resp_ver_link_li)</pre>
<pre>     ,.ver_o(resp_ver_link_lo)</pre>
<pre>     );</pre>
<pre>  assign prev_resp_link_o = resp_hor_link_lo[W];</pre>
<pre>  assign next_resp_link_o = resp_hor_link_lo[E];</pre>
<pre></pre>
<h3>./bp_common/src/v/bp_addr_map.v</h3>
<pre>module bp_addr_map</pre>
<pre>   `declare_bp_proc_params(cfg_p)</pre>
<pre>   , input [mem_noc_cord_width_p-1:0]  dram_cord_i</pre>
<pre>   , input [mem_noc_cord_width_p-1:0]  host_cord_i</pre>
<pre></pre>
<pre></pre>
<pre>   , output [mem_noc_cid_width_p-1:0]  dst_cid_o</pre>
<pre>   );</pre>
<pre></pre>
<pre></pre>
<pre>  casez (paddr_i)</pre>
<pre>    cfg_link_dev_base_addr_gp, clint_dev_base_addr_gp, plic_dev_base_addr_gp:</pre>
<pre>             clint_not_dram = 1'b1;</pre>
<pre>    default: clint_not_dram = 1'b0;</pre>
<pre>  endcase</pre>
<pre>assign dst_cid_o  = '0; // currently unused</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre></pre>
</body>
</html>
